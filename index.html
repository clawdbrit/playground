<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <meta name="theme-color" content="#fafafa">
    <title>Wallet Memo</title>
    <meta name="description" content="A sticky note for your Apple Wallet. Write a memo, save it to your wallet, and never forget.">
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Wallet Memo">
    <meta property="og:description" content="A sticky note for your Apple Wallet.">
    <meta property="og:image" content="https://walletmemo.com/assets/og/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:url" content="https://walletmemo.com/">
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Wallet Memo">
    <meta name="twitter:description" content="A sticky note for your Apple Wallet.">
    <meta name="twitter:image" content="https://walletmemo.com/assets/og/og-image.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&family=Inter:wght@300&family=Cormorant+Garamond:wght@300&display=swap" rel="stylesheet">
    <script>
      // Load CJK fonts only when needed (saves ~400KB for non-CJK users)
      (function() {
        var lang = localStorage.getItem('wm-lang') || navigator.language || '';
        lang = lang.substring(0, 2).toLowerCase();
        var cjkMap = { ja: 'Noto+Serif+JP', ko: 'Noto+Serif+KR', zh: 'Noto+Serif+SC' };
        var family = cjkMap[lang];
        if (family) {
          var link = document.createElement('link');
          link.rel = 'stylesheet';
          link.href = 'https://fonts.googleapis.com/css2?family=' + family + ':wght@900&display=swap';
          document.head.appendChild(link);
        }
      })();
    </script>
    <link rel="stylesheet" href="https://cdn.hugeicons.com/font/hgi-stroke-rounded.css">
    <script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>
    <link rel="stylesheet" href="lang-picker.css?v=2">
    <link rel="stylesheet" href="./style.css?v=17" />
    <!-- Hreflang alternate links for SEO -->
    <link rel="alternate" hreflang="en" href="https://walletmemo.com/" />
    <link rel="alternate" hreflang="es" href="https://walletmemo.com/?lang=es" />
    <link rel="alternate" hreflang="fr" href="https://walletmemo.com/?lang=fr" />
    <link rel="alternate" hreflang="de" href="https://walletmemo.com/?lang=de" />
    <link rel="alternate" hreflang="ja" href="https://walletmemo.com/?lang=ja" />
    <link rel="alternate" hreflang="zh" href="https://walletmemo.com/?lang=zh" />
    <link rel="alternate" hreflang="ko" href="https://walletmemo.com/?lang=ko" />
    <link rel="alternate" hreflang="pt" href="https://walletmemo.com/?lang=pt" />
    <link rel="alternate" hreflang="x-default" href="https://walletmemo.com/" />
          <!-- GoatCounter analytics -->
    <script data-goatcounter="https://walletmemo.goatcounter.com/count"
            async src="//gc.zgo.at/count.js"></script>
  </head>
  <body>
    <style>
      html { background: linear-gradient(to bottom, #fafafa, #e5e5e5); background-attachment: fixed; min-height: 100vh; scrollbar-gutter: stable; }
      html, body { overflow-x: hidden; }
      html::-webkit-scrollbar { width: 8px; }
      html::-webkit-scrollbar-track { background: transparent; }
      html::-webkit-scrollbar-thumb { background: rgba(0,0,0,.15); border-radius: 4px; }
      html::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,.3); }
      @supports (scrollbar-width: thin) { html { scrollbar-width: thin; scrollbar-color: rgba(0,0,0,.15) transparent; } }
      html.page-slide-out-left .page-content { animation: slideOutLeft 0.35s ease-in forwards; }
      html.page-slide-in-left .page-content { animation: slideInFromLeft 0.4s ease-out forwards; }
      @keyframes slideOutLeft {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(-100vw); opacity: 0; }
      }
      @keyframes slideInFromLeft {
        from { transform: translateX(-100vw); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
    </style>
    <script>
      // If returning from changelog, just clean up the flag (skip animation for now)
      if (sessionStorage.getItem('page-transition') === 'back') {
        sessionStorage.removeItem('page-transition');
      }
    </script>
    <!-- Language picker (outside page-content so it doesn't slide) -->
    <div class="lang-picker" id="lang-picker">
      <button class="lang-btn" id="lang-btn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <circle cx="12" cy="12" r="10"/>
          <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
        </svg>
        <span id="current-lang">EN</span>
        <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M6 9l6 6 6-6"/>
        </svg>
      </button>
      <div class="lang-dropdown" id="lang-dropdown">
        <button class="lang-option" data-lang="en">English</button>
        <button class="lang-option" data-lang="es">Espa&#241;ol</button>
        <button class="lang-option" data-lang="fr">Fran&#231;ais</button>
        <button class="lang-option" data-lang="de">Deutsch</button>
        <button class="lang-option" data-lang="ja">&#26085;&#26412;&#35486;</button>
        <button class="lang-option" data-lang="zh">&#20013;&#25991;</button>
        <button class="lang-option" data-lang="ko">&#54620;&#44397;&#50612;</button>
        <button class="lang-option" data-lang="pt">Portugu&#234;s</button>
      </div>
    </div>

    <div class="page-content">
    <div class="focus-overlay" id="focus-overlay"></div>
    <div class="content-group">
      <div class="hero-text">
        <div class="hero-title" data-i18n="heroTitle">Wallet Memo</div>
        <div class="hero-tagline" id="hero-tagline">A sticky note for your Apple Wallet</div>
      </div>

      <main class="container">
      <div class="note-wrapper" id="note-wrapper">
        <!-- Shadow layer (behind note) -->
        <div class="note-shadow" id="note-shadow"></div>
        <!-- Sticky note SVG - inlined for dynamic color updates -->
        <svg class="note-paper" id="note-paper" data-state="one" width="287" height="270" viewBox="0 0 287 270" fill="none" xmlns="http://www.w3.org/2000/svg">
          <g filter="url(#noteFilter)">
            <path id="note-shape" d="M34.6016 19.2695L250.102 18.5996C250.102 18.5996 249.602 49.0996 257.602 228.6L28.6016 231.1C36.6029 66.5996 34.6016 19.2695 34.6016 19.2695Z" fill="url(#noteGradient)"/>
          </g>
          <!-- Bottom edge darkening handled by gradient stop-0 -->
          <defs>
            <filter id="noteFilter" x="0.00156212" y="-0.000391006" width="286.2" height="269.7" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
              <feFlood flood-opacity="0" result="BackgroundImageFix"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset/>
              <feGaussianBlur stdDeviation="5.14583"/>
              <feColorMatrix id="shadowColor1" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"/>
              <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset dy="10"/>
              <feGaussianBlur stdDeviation="14.3"/>
              <feColorMatrix id="shadowColor2" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"/>
              <feBlend mode="normal" in2="effect1_dropShadow" result="effect2_dropShadow"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset dy="0.2"/>
              <feComposite in2="hardAlpha" operator="out"/>
              <feColorMatrix id="shadowColor3" type="matrix" values="0 0 0 0 0.425615 0 0 0 0 0.695906 0 0 0 0 0.842314 0 0 0 1 0"/>
              <feBlend mode="normal" in2="effect2_dropShadow" result="effect3_dropShadow"/>
              <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
              <feTurbulence type="fractalNoise" baseFrequency="1.6666666269302368 1.6666666269302368" stitchTiles="stitch" numOctaves="3" result="noise" seed="6167"/>
              <feComponentTransfer in="noise" result="coloredNoise1">
                <feFuncR type="linear" slope="2" intercept="-0.5"/>
                <feFuncG type="linear" slope="2" intercept="-0.5"/>
                <feFuncB type="linear" slope="2" intercept="-0.5"/>
                <feFuncA type="discrete" tableValues="1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"/>
              </feComponentTransfer>
              <feComposite operator="in" in2="shape" in="coloredNoise1" result="noise1Clipped"/>
              <feComponentTransfer in="noise1Clipped" result="color1">
                <feFuncA type="table" tableValues="0 0.06"/>
              </feComponentTransfer>
              <feMerge result="effect4_noise">
                <feMergeNode in="shape"/>
                <feMergeNode in="color1"/>
              </feMerge>
              <feBlend mode="normal" in="effect4_noise" in2="effect3_dropShadow" result="effect4_noise"/>
            </filter>
            <linearGradient id="noteGradient" x1="153.102" y1="231.1" x2="143.601" y2="18.5996" gradientUnits="userSpaceOnUse">
              <stop id="grad-stop-0" stop-color="#89C5E0"/>
              <stop id="grad-stop-1" offset="0.255906" stop-color="#98C4DA"/>
              <stop id="grad-stop-2" offset="0.812358" stop-color="#9BC8E7"/>
              <stop id="grad-stop-3" offset="0.864881" stop-color="#ACD7E9"/>
              <stop id="grad-stop-4" offset="0.954264" stop-color="#B8E3F3"/>
              <stop id="grad-stop-5" offset="1" stop-color="#C4E9F5"/>
            </linearGradient>
          </defs>
        </svg>
        <script>
          // Peel-to-reveal: immediately set tight curl + visual state before first paint
          if (!sessionStorage.getItem('wm-note-state') && (true || !sessionStorage.getItem('wm-intro-seen'))) {
            console.log('[intro] Setting tight curl');
            document.getElementById('note-shape').setAttribute('d',
              'M34.6016 19.2695 L250.102 18.5996 C250.102 18.5996 249.602 49.0996 255 210 L28.6016 231.1 C36.6029 66.5996 34.6016 19.2695 34.6016 19.2695 Z'
            );
            // Mark that intro needs gradient lightening (applied after color theme loads)
            window._introNeedsGradient = true;
            var nw = document.getElementById('note-wrapper');
            nw.style.transition = 'none';
          }
        </script>
        <div class="note" id="sticky-note">
          <!-- Ellipsis menu button -->
          <button class="note-menu-btn" id="menu-btn">
            <svg viewBox="0 0 24 24">
              <circle cx="12" cy="5" r="2"/>
              <circle cx="12" cy="12" r="2"/>
              <circle cx="12" cy="19" r="2"/>
            </svg>
          </button>

          <!-- Dropdown menu -->
          <div class="note-dropdown" id="note-dropdown">
            <button class="dropdown-item" id="change-color-btn">
              <span class="color-icon" id="color-icon"></span>
              <span data-i18n="changeColor">Change Color</span>
            </button>
            <div class="color-submenu" id="color-submenu">
              <div class="color-swatch" data-color="blue" style="background: #B4DCE8;"></div>
              <div class="color-swatch" data-color="yellow" style="background: #EAD264;"></div>
              <div class="color-swatch" data-color="pink" style="background: #ECBDC5;"></div>
            </div>
            <button class="dropdown-item" id="add-stamp-btn" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="11" width="18" height="10" rx="2"/>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
              </svg>
              <span data-i18n="addStamp">Add Stamp</span> <span class="coming-soon-tag" data-i18n="comingSoon">Coming soon</span>
            </button>
            <button class="dropdown-item" id="add-sticker-btn" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                <line x1="9" y1="9" x2="9.01" y2="9"/>
                <line x1="15" y1="9" x2="15.01" y2="9"/>
              </svg>
              <span data-i18n="stickers">Stickers</span> <span class="coming-soon-tag" data-i18n="comingSoon">Coming soon</span>
            </button>
            <button class="dropdown-item" id="draw-btn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                <path d="M2 2l7.586 7.586"/>
              </svg>
              <span data-i18n="drawOnNote">Draw on Note</span>
            </button>
          </div>

          <!-- Drawing layer for finished drawings -->
          <canvas class="note-drawing-layer" id="note-drawing-layer"></canvas>

          <textarea
            id="memo"
            class="textarea"
            placeholder=""
            maxlength="140"
          ></textarea>
        </div>
        <!-- Drawing toolbar -->
      </div>

      <!-- Drawing toolbar: shared across all notes, positioned via JS -->
      <div class="drawing-toolbar" id="drawing-toolbar">
        <button class="toolbar-btn cancel" id="cancel-drawing"><i class="hgi-stroke hgi-cancel-01"></i></button>
        <div class="toolbar-divider"></div>
        <button class="toolbar-btn clear" id="clear-drawing"><i class="hgi-stroke hgi-delete-02"></i></button>
        <div class="toolbar-divider"></div>
        <div class="pen-color-picker">
          <button class="pen-color-current" id="pen-color-current" style="background:#1a1a1a"></button>
          <div class="pen-color-popup" id="pen-color-popup">
            <button class="pen-color active" data-color="26,26,26" style="background:#1a1a1a"></button>
            <button class="pen-color" data-color="229,57,53" style="background:#e53935"></button>
            <button class="pen-color" data-color="30,136,229" style="background:#1e88e5"></button>
            <button class="pen-color" data-color="67,160,71" style="background:#43a047"></button>
            <button class="pen-color" data-color="142,36,170" style="background:#8e24aa"></button>
          </div>
        </div>
        <div class="toolbar-divider"></div>
        <button class="toolbar-btn done" id="done-drawing"><i class="hgi-stroke hgi-tick-02"></i></button>
      </div>

      <div class="wallet-wrapper">
        <div class="wallet-buttons">
          <a href="#" class="wallet-btn-link" id="apple-wallet-btn">
            <img id="apple-wallet-img" src="./assets/wallet-buttons/apple-wallet-buttons/Locale=EN.svg" alt="Add to Apple Wallet">
            <div class="wallet-qr" id="wallet-qr"></div>
          </a>
          <a href="#" class="wallet-btn-link" id="google-wallet-btn" style="display: none;">
            <img id="google-wallet-img" src="./assets/wallet-buttons/google-wallet-buttons/Locale=EN, Type=Primary.svg" alt="Add to Google Wallet">
          </a>
        </div>
        <div class="wallet-message" id="wallet-message" data-i18n="comingSoonExcl">Coming soon!</div>
        <div class="build-hover-area"><a href="mailto:ram@agentmail.to" class="footer-link"><svg class="mail-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-right:4px;position:relative;top:1.5px;"><rect x="2" y="4" width="20" height="16" rx="3"/><path d="M2 7l10 7 10-7"/></svg><span data-i18n="emailUs">Email Us</span></a> &#183; <span class="copyright">&#169; 2026 Wallet Memo</span><span class="test-version" id="test-version"></span><!-- Build 196 --></div>
      </div>
    </main>
    
<!-- build number moved to end of body -->
    </div>

    <script>
      // Prevent pinch-to-zoom on iOS Safari
      document.addEventListener('gesturestart', function(e) { e.preventDefault(); });
      document.addEventListener('gesturechange', function(e) { e.preventDefault(); });
      document.addEventListener('gestureend', function(e) { e.preventDefault(); });


      // ==========================================
      // Note Registry & Active Note Tracking
      // ==========================================
      window.noteRegistry = new Map();
      window.activeNoteId = null;
      window.lastActiveNoteId = null;

      window.setActiveNote = function(noteId) {
        window.activeNoteId = noteId;
      };
      window.deactivateNote = function() {
        if (window.activeNoteId) {
          window.lastActiveNoteId = window.activeNoteId;
          window.activeNoteId = null;
        }
      };
      window.getTargetNote = function() {
        var id = window.activeNoteId || window.lastActiveNoteId;
        if (id && window.noteRegistry.has(id)) return window.noteRegistry.get(id);
        // fallback to note-0
        if (window.noteRegistry.has('note-0')) return window.noteRegistry.get('note-0');
        return null;
      };

      // ==========================================
      // i18n Translations
      // ==========================================
      const i18n = {
        en: {
          heroTitle: "Wallet Memo",
          heroTagline: "A sticky note for your Apple Wallet",
          changeColor: "Change Color",
          addStamp: "Add Stamp",
          comingSoon: "Coming soon",
          stickers: "Stickers",
          drawOnNote: "Draw on Note",
          emailUs: "Email Us",
          changelog: "Changelog",
          comingSoonExcl: "Coming soon!",
          placeholders: [
            "Buy oat milk\nText mom\nDon't forget\u00e2\u20ac\u00a6",
            "Pick up groceries\nCall dentist\nStretch!",
            "Idea: build an app\nResearch competitors\nSketch wireframes",
            "Monday meeting\nBring snacks\nAsk about timeline",
            "Gift ideas:\nNew headphones?\nBook about space",
            "Workout plan\nRun 2 miles\nDrink more water",
            "Movie night picks:\nInterstellar\nEverything Everywhere",
            "Pack for trip\nCharger\nPassport\nSnacks",
            "Learn something new\nWatch a tutorial\nTake notes",
            "Groceries:\nAvocados\nSourdough\nCoffee beans",
            "Weekend plans\nFarmers market\nCook dinner\nRead",
            "Buy it.\nUse it.\nBreak it.\nFix it.",
            "It doesn't have to\nbe done. It just has\nto be perfect.",
            "Drink water.",
            "Send the email.",
            "Stretch for\n30 seconds.\nCount it.",
            "Call dentist.",
            "Don't turn\nOff.",
          ]
        },
        es: {
          heroTitle: "Nota de Cartera",
          heroTagline: "Una nota adhesiva para tu Apple Wallet",
          changeColor: "Cambiar Color",
          addStamp: "A\u00f1adir Sello",
          comingSoon: "Pr\u00f3ximamente",
          stickers: "Stickers",
          drawOnNote: "Dibujar en Nota",
          emailUs: "Escr\u00edbenos",
          changelog: "Registro de cambios",
          comingSoonExcl: "\u00a1Pr\u00f3ximamente!",
          placeholders: [
            "Comprar leche\nLlamar a mam\u00e1\nNo olvidar\u2026",
            "Ir al s\u00faper\nLlamar al dentista\n\u00a1Estirar!",
            "Idea: crear una app\nInvestigar competencia\nHacer bocetos",
            "Reuni\u00f3n del lunes\nLlevar snacks\nPreguntar por plazos",
            "Ideas de regalo:\n\u00bfAud\u00edfonos nuevos?\nLibro de espacio",
            "Plan de ejercicio\nCorrer 3 km\nBeber m\u00e1s agua",
            "Noche de pelis:\nInterestelar\nEverything Everywhere",
            "Hacer maleta\nCargador\nPasaporte\nSnacks",
            "Aprender algo nuevo\nVer un tutorial\nTomar notas",
            "Compras:\nAguacates\nPan\nCaf\u00e9",
            "Planes del finde\nMercado\nCocinar\nLeer",
            "C\u00f3mpralo.\n\u00dasalo.\nR\u00f3mpelo.\nArr\u00e9glalo.",
            "No tiene que estar\nterminado. Solo tiene\nque ser perfecto.",
            "Bebe agua.",
            "Env\u00eda el correo.",
            "Estira por\n30 segundos.\nCu\u00e9ntalos.",
            "Llama al dentista.",
            "No te\napagues.",
          ]
        },
        fr: {
          heroTitle: "M\u00e9mo Portefeuille",
          heroTagline: "Un pense-b\u00eate pour votre Apple Wallet",
          changeColor: "Changer la Couleur",
          addStamp: "Ajouter un Tampon",
          comingSoon: "Bient\u00f4t",
          stickers: "Autocollants",
          drawOnNote: "Dessiner sur la Note",
          emailUs: "Nous \u00c9crire",
          changelog: "Journal des modifications",
          comingSoonExcl: "Bient\u00f4t disponible !",
          placeholders: [
            "Acheter du lait\nAppeler maman\nNe pas oublier\u2026",
            "Courses \u00e0 faire\nAppeler le dentiste\n\u00c9tirements !",
            "Id\u00e9e : cr\u00e9er une app\n\u00c9tudier la concurrence\nFaire des croquis",
            "R\u00e9union lundi\nApporter des g\u00e2teaux\nDemander le planning",
            "Id\u00e9es cadeaux :\nNouveaux \u00e9couteurs ?\nLivre sur l'espace",
            "Programme sport\nCourir 3 km\nBoire plus d'eau",
            "Soir\u00e9e cin\u00e9 :\nInterstellar\nEverything Everywhere",
            "Pr\u00e9parer la valise\nChargeur\nPasseport\nSnacks",
            "Apprendre quelque chose\nRegarder un tuto\nPrendre des notes",
            "Courses :\nAvocats\nPain\nGrains de caf\u00e9",
            "Plans du week-end\nMarch\u00e9\nCuisiner\nLire",
            "Ach\u00e8te-le.\nUtilise-le.\nCasse-le.\nR\u00e9pare-le.",
            "\u00c7a n'a pas besoin\nd'\u00eatre fini. Juste\nparfait.",
            "Bois de l'eau.",
            "Envoie le mail.",
            "\u00c9tire-toi\n30 secondes.\nCompte-les.",
            "Appelle le dentiste.",
            "Ne t'\u00e9teins\npas.",
          ]
        },
        de: {
          heroTitle: "Wallet-Notiz",
          heroTagline: "Ein Klebezettel f\u00fcr dein Apple Wallet",
          changeColor: "Farbe \u00c4ndern",
          addStamp: "Stempel Hinzuf\u00fcgen",
          comingSoon: "Demn\u00e4chst",
          stickers: "Sticker",
          drawOnNote: "Auf Notiz Zeichnen",
          emailUs: "Schreib Uns",
          changelog: "\u00c4nderungsprotokoll",
          comingSoonExcl: "Demn\u00e4chst verf\u00fcgbar!",
          placeholders: [
            "Milch kaufen\nMama anrufen\nNicht vergessen\u2026",
            "Einkaufen gehen\nZahnarzt anrufen\nDehnen!",
            "Idee: App bauen\nWettbewerb analysieren\nSkizzen machen",
            "Meeting am Montag\nSnacks mitbringen\nNach Zeitplan fragen",
            "Geschenkideen:\nNeue Kopfh\u00f6rer?\nBuch \u00fcber Weltraum",
            "Trainingsplan\n3 km laufen\nMehr Wasser trinken",
            "Filmabend:\nInterstellar\nEverything Everywhere",
            "Koffer packen\nLadeger\u00e4t\nReisepass\nSnacks",
            "Etwas Neues lernen\nTutorial schauen\nNotizen machen",
            "Einkaufsliste:\nAvocados\nBrot\nKaffeebohnen",
            "Wochenendpl\u00e4ne\nMarkt\nKochen\nLesen",
            "Kauf es.\nNutz es.\nBrich es.\nFix es.",
            "Es muss nicht\nfertig sein. Nur\nperfekt.",
            "Trink Wasser.",
            "Schick die E-Mail.",
            "Dehne dich\n30 Sekunden.\nZ\u00e4hle mit.",
            "Ruf den Zahnarzt an.",
            "Schalte nicht\nab.",
          ]
        },
        ja: {
          heroTitle: "\u30a6\u30a9\u30ec\u30c3\u30c8\u30e1\u30e2",
          heroTagline: "Apple Wallet\u306e\u4ed8\u7b8b\u30e1\u30e2",
          changeColor: "\u8272\u3092\u5909\u66f4",
          addStamp: "\u30b9\u30bf\u30f3\u30d7\u3092\u8ffd\u52a0",
          comingSoon: "\u8fd1\u65e5\u516c\u958b",
          stickers: "\u30b9\u30c6\u30c3\u30ab\u30fc",
          drawOnNote: "\u30e1\u30e2\u306b\u63cf\u304f",
          emailUs: "\u30e1\u30fc\u30eb\u3059\u308b",
          changelog: "\u5909\u66f4\u5c65\u6b74",
          comingSoonExcl: "\u8fd1\u65e5\u516c\u958b\uff01",
          placeholders: [
            "\u725b\u4e73\u3092\u8cb7\u3046\n\u304a\u6bcd\u3055\u3093\u306b\u96fb\u8a71\n\u5fd8\u308c\u306a\u3044\u3067\u2026",
            "\u8cb7\u3044\u7269\u306b\u884c\u304f\n\u6b6f\u533b\u8005\u306b\u96fb\u8a71\n\u30b9\u30c8\u30ec\u30c3\u30c1\uff01",
            "\u30a2\u30a4\u30c7\u30a2\uff1a\u30a2\u30d7\u30ea\u3092\u4f5c\u308b\n\u7af6\u5408\u3092\u8abf\u67fb\n\u30ef\u30a4\u30e4\u30fc\u30d5\u30ec\u30fc\u30e0\u3092\u63cf\u304f",
            "\u6708\u66dc\u306e\u4f1a\u8b70\n\u304a\u83d3\u5b50\u3092\u6301\u53c2\n\u30b9\u30b1\u30b8\u30e5\u30fc\u30eb\u3092\u78ba\u8a8d",
            "\u30d7\u30ec\u30bc\u30f3\u30c8\u306e\u30a2\u30a4\u30c7\u30a2\uff1a\n\u65b0\u3057\u3044\u30d8\u30c3\u30c9\u30db\u30f3\uff1f\n\u5b87\u5b99\u306e\u672c",
            "\u904b\u52d5\u8a08\u753b\n3km\u8d70\u308b\n\u3082\u3063\u3068\u6c34\u3092\u98f2\u3080",
            "\u6620\u753b\u30ca\u30a4\u30c8\uff1a\n\u30a4\u30f3\u30bf\u30fc\u30b9\u30c6\u30e9\u30fc\n\u30a8\u30d6\u30a8\u30d6",
            "\u65c5\u884c\u306e\u6e96\u5099\n\u5145\u96fb\u5668\n\u30d1\u30b9\u30dd\u30fc\u30c8\n\u304a\u83d3\u5b50",
            "\u65b0\u3057\u3044\u3053\u3068\u3092\u5b66\u3076\n\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u898b\u308b\n\u30e1\u30e2\u3092\u53d6\u308b",
            "\u8cb7\u3044\u7269\u30ea\u30b9\u30c8\uff1a\n\u30a2\u30dc\u30ab\u30c9\n\u30d1\u30f3\n\u30b3\u30fc\u30d2\u30fc\u8c46",
            "\u9031\u672b\u306e\u4e88\u5b9a\n\u5e02\u5834\n\u6599\u7406\u3059\u308b\n\u8aad\u66f8",
            "\u8cb7\u3046\u3002\n\u4f7f\u3046\u3002\n\u58ca\u3059\u3002\n\u76f4\u3059\u3002",
            "\u5b8c\u6210\u3057\u306a\u304f\u3066\u3044\u3044\u3002\n\u305f\u3060\u5b8c\u74a7\u3067\n\u3042\u308c\u3070\u3044\u3044\u3002",
            "\u6c34\u3092\u98f2\u3080\u3002",
            "\u30e1\u30fc\u30eb\u3092\u9001\u308b\u3002",
            "30\u79d2\n\u30b9\u30c8\u30ec\u30c3\u30c1\u3002\n\u6570\u3048\u3066\u3002",
            "\u6b6f\u533b\u8005\u306b\u96fb\u8a71\u3002",
            "\u6d88\u3048\u306a\u3044\u3067\u3002",
          ]
        },
        zh: {
          heroTitle: "\u94b1\u5305\u5907\u5fd8\u5f55",
          heroTagline: "Apple Wallet \u7684\u4fbf\u5229\u8d34",
          changeColor: "\u66f4\u6362\u989c\u8272",
          addStamp: "\u6dfb\u52a0\u5370\u7ae0",
          comingSoon: "\u5373\u5c06\u63a8\u51fa",
          stickers: "\u8d34\u7eb8",
          drawOnNote: "\u5728\u4fbf\u7b7e\u4e0a\u753b\u753b",
          emailUs: "\u53d1\u90ae\u4ef6\u7ed9\u6211\u4eec",
          changelog: "\u66f4\u65b0\u65e5\u5fd7",
          comingSoonExcl: "\u5373\u5c06\u63a8\u51fa\uff01",
          placeholders: [
            "\u4e70\u725b\u5976\n\u7ed9\u5988\u5988\u6253\u7535\u8bdd\n\u522b\u5fd8\u4e86\u2026",
            "\u53bb\u8d85\u5e02\n\u9884\u7ea6\u7259\u533b\n\u505a\u62c9\u4f38\uff01",
            "\u60f3\u6cd5\uff1a\u505a\u4e2aApp\n\u7814\u7a76\u7ade\u54c1\n\u753b\u7ebf\u6846\u56fe",
            "\u5468\u4e00\u5f00\u4f1a\n\u5e26\u96f6\u98df\n\u95ee\u8fdb\u5ea6",
            "\u793c\u7269\u6e05\u5355\uff1a\n\u65b0\u8033\u673a\uff1f\n\u592a\u7a7a\u4e66\u7c4d",
            "\u5065\u8eab\u8ba1\u5212\n\u8dd1\u6b653\u516c\u91cc\n\u591a\u559d\u6c34",
            "\u7535\u5f71\u4e4b\u591c\uff1a\n\u661f\u9645\u7a7f\u8d8a\n\u77ac\u606f\u5168\u5b87\u5b99",
            "\u6536\u62fe\u884c\u674e\n\u5145\u7535\u5668\n\u62a4\u7167\n\u96f6\u98df",
            "\u5b66\u70b9\u65b0\u4e1c\u897f\n\u770b\u6559\u7a0b\n\u505a\u7b14\u8bb0",
            "\u8d2d\u7269\u6e05\u5355\uff1a\n\u725b\u6cb9\u679c\n\u9762\u5305\n\u5496\u5561\u8c46",
            "\u5468\u672b\u8ba1\u5212\n\u901b\u5e02\u573a\n\u505a\u996d\n\u770b\u4e66",
            "\u4e70\u3002\n\u7528\u3002\n\u574f\u3002\n\u4fee\u3002",
            "\u4e0d\u9700\u8981\u5b8c\u6210\u3002\n\u53ea\u9700\u8981\n\u5b8c\u7f8e\u3002",
            "\u559d\u6c34\u3002",
            "\u53d1\u90ae\u4ef6\u3002",
            "\u62c9\u4f38\n30\u79d2\u3002\n\u6570\u4e00\u6570\u3002",
            "\u6253\u7535\u8bdd\u7ed9\u7259\u533b\u3002",
            "\u522b\u5173\u673a\u3002",
          ]
        },
        ko: {
          heroTitle: "\uc9c0\uac11 \uba54\ubaa8",
          heroTagline: "Apple Wallet\uc744 \uc704\ud55c \uba54\ubaa8 \uc2a4\ud2f0\ucee4",
          changeColor: "\uc0c9\uc0c1 \ubcc0\uacbd",
          addStamp: "\uc2a4\ud0ec\ud504 \ucd94\uac00",
          comingSoon: "\uace7 \ucd9c\uc2dc",
          stickers: "\uc2a4\ud2f0\ucee4",
          drawOnNote: "\uba54\ubaa8\uc5d0 \uadf8\ub9ac\uae30",
          emailUs: "\uc774\uba54\uc77c \ubcf4\ub0b4\uae30",
          changelog: "\ubcc0\uacbd \uc774\ub825",
          comingSoonExcl: "\uace7 \ucd9c\uc2dc\ub429\ub2c8\ub2e4!",
          placeholders: [
            "\uc6b0\uc720 \uc0ac\uae30\n\uc5c4\ub9c8\ud55c\ud14c \uc804\ud654\n\uc78a\uc9c0 \ub9d0\uae30\u2026",
            "\uc7a5\ubcf4\uae30\n\uce58\uacfc \uc608\uc57d\n\uc2a4\ud2b8\ub808\uce6d!",
            "\uc544\uc774\ub514\uc5b4: \uc571 \ub9cc\ub4e4\uae30\n\uacbd\uc7c1\uc0ac \uc870\uc0ac\n\uc640\uc774\uc5b4\ud504\ub808\uc784 \uadf8\ub9ac\uae30",
            "\uc6d4\uc694\uc77c \ud68c\uc758\n\uac04\uc2dd \uac00\uc838\uac00\uae30\n\uc77c\uc815 \ud655\uc778",
            "\uc120\ubb3c \uc544\uc774\ub514\uc5b4:\n\uc0c8 \ud5e4\ub4dc\ud3f0?\n\uc6b0\uc8fc \uad00\ub828 \ucc45",
            "\uc6b4\ub3d9 \uacc4\ud68d\n3km \ub2ec\ub9ac\uae30\n\ubb3c \ub354 \ub9c8\uc2dc\uae30",
            "\uc601\ud654 \ubc24:\n\uc778\ud130\uc2a4\ud154\ub77c\n\uc5d0\ube0c\ub9ac\uc53d \uc5d0\ube0c\ub9ac\uc6e8\uc5b4",
            "\uc5ec\ud589 \uc9d0 \uc2f8\uae30\n\ucda9\uc804\uae30\n\uc5ec\uad8c\n\uac04\uc2dd",
            "\uc0c8\ub85c\uc6b4 \uac83 \ubc30\uc6b0\uae30\n\ud29c\ud1a0\ub9ac\uc5bc \ubcf4\uae30\n\uba54\ubaa8\ud558\uae30",
            "\uc7a5\ubcf4\uae30:\n\uc544\ubcf4\uce74\ub3c4\n\ube75\n\ucee4\ud53c \uc6d0\ub450",
            "\uc8fc\ub9d0 \uacc4\ud68d\n\uc2dc\uc7a5 \uac00\uae30\n\uc694\ub9ac\ud558\uae30\n\ub3c5\uc11c",
            "\uc0ac\ub77c.\n\uc368\ub77c.\n\ubd80\uc234\ub77c.\n\uace0\uccd0\ub77c.",
            "\uc644\uc131\ud560 \ud544\uc694 \uc5c6\uc5b4.\n\uadf8\ub0e5 \uc644\ubcbd\ud558\uba74\n\ub3fc.",
            "\ubb3c \ub9c8\uc2dc\uae30.",
            "\uc774\uba54\uc77c \ubcf4\ub0b4\uae30.",
            "30\ucd08\n\uc2a4\ud2b8\ub808\uce6d.\n\uc138\uc5b4\ubd10.",
            "\uce58\uacfc\uc5d0 \uc804\ud654.",
            "\uaebc\uc9c0\uc9c0 \ub9c8.",
          ]
        },
        pt: {
          heroTitle: "Memo Carteira",
          heroTagline: "Um lembrete para o seu Apple Wallet",
          changeColor: "Mudar Cor",
          addStamp: "Adicionar Carimbo",
          comingSoon: "Em breve",
          stickers: "Adesivos",
          drawOnNote: "Desenhar na Nota",
          emailUs: "Envie um Email",
          changelog: "Registro de altera\u00e7\u00f5es",
          comingSoonExcl: "Em breve!",
          placeholders: [
            "Comprar leite\nLigar pra m\u00e3e\nN\u00e3o esquecer\u2026",
            "Ir ao mercado\nLigar pro dentista\nAlongar!",
            "Ideia: criar um app\nPesquisar concorr\u00eancia\nFazer esbo\u00e7os",
            "Reuni\u00e3o segunda\nLevar lanches\nPerguntar sobre prazos",
            "Ideias de presente:\nFones novos?\nLivro sobre espa\u00e7o",
            "Plano de treino\nCorrer 3 km\nBeber mais \u00e1gua",
            "Noite de filme:\nInterestelar\nEverything Everywhere",
            "Fazer mala\nCarregador\nPassaporte\nLanches",
            "Aprender algo novo\nVer tutorial\nFazer anota\u00e7\u00f5es",
            "Compras:\nAbacates\nP\u00e3o\nGr\u00e3os de caf\u00e9",
            "Planos de fim de semana\nFeira\nCozinhar\nLer",
            "Compre.\nUse.\nQuebre.\nConserte.",
            "N\u00e3o precisa estar\npronto. S\u00f3 precisa\nser perfeito.",
            "Beba \u00e1gua.",
            "Envie o email.",
            "Alongue por\n30 segundos.\nConte.",
            "Ligue pro dentista.",
            "N\u00e3o se\napague.",
          ]
        }
      };

      // Apply language to all translatable elements
      function applyLanguage(lang) {
        const t = i18n[lang] || i18n.en;
        // Set document lang attribute
        document.documentElement.lang = lang;
        // Page title
        if (t.heroTitle) document.title = t.heroTitle;
        // Hero tagline
        const tagline = document.getElementById('hero-tagline');
        if (tagline) tagline.textContent = t.heroTagline;
        // All data-i18n elements
        document.querySelectorAll('[data-i18n]').forEach(el => {
          const key = el.getAttribute('data-i18n');
          if (t[key]) el.textContent = t[key];
        });
        // Textarea placeholder (random from current language)
        const memo = document.getElementById('memo');
        if (memo) memo.placeholder = t.placeholders[Math.floor(Math.random() * t.placeholders.length)];
        // Store globally for new note placeholders
        window._currentI18nLang = lang;
      }

      // Randomize default note placeholder on load
      (function() {
        const ph = [
          "Buy oat milk\nText mom\nDon't forget\u00e2\u20ac\u00a6",
          "Pick up groceries\nCall dentist\nStretch!",
          "Idea: build an app\nResearch competitors\nSketch wireframes",
          "Monday meeting\nBring snacks\nAsk about timeline",
          "Gift ideas:\nNew headphones?\nBook about space",
          "Workout plan\nRun 2 miles\nDrink more water",
          "Movie night picks:\nInterstellar\nEverything Everywhere",
          "Pack for trip\nCharger\nPassport\nSnacks",
          "Learn something new\nWatch a tutorial\nTake notes",
          "Groceries:\nAvocados\nSourdough\nCoffee beans",
          "Weekend plans\nFarmers market\nCook dinner\nRead",
          "Buy it.\nUse it.\nBreak it.\nFix it.",
          "It doesn't have to\nbe done. It just has\nto be perfect.",
          "Drink water.",
          "Send the email.",
          "Stretch for\n30 seconds.\nCount it.",
          "Call dentist.",
          "Don't turn\nOff.",
        ];
        const memo = document.getElementById('memo');
        if (memo) memo.placeholder = ph[Math.floor(Math.random() * ph.length)];
      })();

      // Language picker and wallet buttons
      (function() {
        const appleImg = document.getElementById('apple-wallet-img');
        const googleImg = document.getElementById('google-wallet-img');
        const langPicker = document.getElementById('lang-picker');
        const langBtn = document.getElementById('lang-btn');
        const langDropdown = document.getElementById('lang-dropdown');
        const langOptions = document.querySelectorAll('.lang-option');
        const currentLangSpan = document.getElementById('current-lang');

        // Map language codes to button locale codes
        const appleLocaleMap = {
          'en': 'EN', 'es': 'ES', 'fr': 'FR', 'de': 'DE', 'ja': 'JP',
          'zh': 'CN', 'ko': 'KR', 'pt': 'PT'
        };

        const googleLocaleMap = {
          'en': 'EN', 'es': 'esES', 'fr': 'FR', 'de': 'DE', 'ja': 'JP',
          'zh': 'zhHK', 'ko': 'KO', 'pt': 'PT'
        };

        const langDisplayMap = {
          'en': 'EN', 'es': 'ES', 'fr': 'FR', 'de': 'DE',
          'ja': 'JA', 'zh': 'ZH', 'ko': 'KO', 'pt': 'PT'
        };

        // Get initial language from browser or localStorage
        let currentLang = localStorage.getItem('walletmemo-lang');
        if (!currentLang) {
          const browserLang = (navigator.language || navigator.userLanguage).split('-')[0];
          currentLang = appleLocaleMap[browserLang] ? browserLang : 'en';
        }

        function updateWalletButtons(lang) {
          const appleLocale = appleLocaleMap[lang] || 'EN';
          const googleLocale = googleLocaleMap[lang] || 'EN';

          appleImg.src = `./assets/wallet-buttons/apple-wallet-buttons/Locale=${appleLocale}.svg`;
          googleImg.src = `./assets/wallet-buttons/google-wallet-buttons/Locale=${googleLocale}, Type=Primary.svg`;

          // Update display
          currentLangSpan.textContent = langDisplayMap[lang] || 'EN';

          // Update active state
          langOptions.forEach(opt => {
            opt.classList.toggle('active', opt.dataset.lang === lang);
          });
        }

        // Fallback to English if locale file doesn't exist
        appleImg.onerror = () => {
          appleImg.src = './assets/wallet-buttons/apple-wallet-buttons/Locale=EN.svg';
        };
        googleImg.onerror = () => {
          googleImg.src = './assets/wallet-buttons/google-wallet-buttons/Locale=EN, Type=Primary.svg';
        };

        // Initialize
        updateWalletButtons(currentLang);
        applyLanguage(currentLang);

        // Toggle dropdown
        langBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          langPicker.classList.toggle('open');
        });

        // Close on outside click
        document.addEventListener('click', () => {
          langPicker.classList.remove('open');
        });

        // Language selection
        langOptions.forEach(opt => {
          opt.addEventListener('click', (e) => {
            e.stopPropagation();
            const lang = opt.dataset.lang;
            currentLang = lang;
            localStorage.setItem('walletmemo-lang', lang);
            updateWalletButtons(lang);
            applyLanguage(lang);
            langPicker.classList.remove('open');
          });
        });

        // Google Wallet - coming soon
        const walletMessage = document.getElementById('wallet-message');
        document.getElementById('google-wallet-btn').addEventListener('click', (e) => {
          e.preventDefault();
          walletMessage.classList.add('visible');
        });
      })();

      // ==========================================
      // Sticky Note Menu & Drawing System
      // ==========================================
      (function() {
        // Elements
        const stickyNote = document.getElementById('sticky-note');
        const menuBtn = document.getElementById('menu-btn');
        const dropdown = document.getElementById('note-dropdown');
        const changeColorBtn = document.getElementById('change-color-btn');
        const colorSubmenu = document.getElementById('color-submenu');
        const colorSwatches = document.querySelectorAll('.color-swatch');
        const addStampBtn = document.getElementById('add-stamp-btn');
        const drawBtn = document.getElementById('draw-btn');
        const colorIcon = document.getElementById('color-icon');
        const noteDrawingLayer = document.getElementById('note-drawing-layer');
        const drawingToolbar = document.getElementById('drawing-toolbar');

        // Position toolbar below note, or above if it would be off-screen
        window.positionToolbar = function(targetWrapper) {
          if (!drawingToolbar) return;
          const rect = targetWrapper.getBoundingClientRect();
          const toolbarH = 52; // approx height
          const belowY = rect.bottom + 12;
          const aboveY = rect.top - toolbarH - 12;
          drawingToolbar.style.bottom = 'auto';
          if (belowY + toolbarH > window.innerHeight) {
            drawingToolbar.style.top = aboveY + 'px';
          } else {
            drawingToolbar.style.top = belowY + 'px';
          }
          drawingToolbar.style.left = (rect.left + rect.width / 2) + 'px';
        }
        const clearBtn = document.getElementById('clear-drawing');
        const cancelBtn = document.getElementById('cancel-drawing');
        const doneBtn = document.getElementById('done-drawing');

        // Color theme definitions (exposed for spawned notes)
        window.colorThemes = {
          blue: {
            gradient: ['#89C5E0', '#98C4DA', '#9BC8E7', '#ACD7E9', '#B8E3F3', '#C4E9F5'],
            shadow1: [0.101961, 0.55098, 1],      // Blue tint
            shadow2: [0, 0.334596, 0.608357],     // Blue tint
            shadow3: [0.425615, 0.695906, 0.842314] // Blue edge
          },
          yellow: {
            gradient: ['#DAAF40', '#E0C04C', '#E6CC5E', '#EEDA70', '#F2E082', '#F7EA9C'],
            shadow1: [0.92, 0.65, 0.15],          // Orange-yellow tint
            shadow2: [0.7, 0.45, 0.1],            // Orange-yellow tint
            shadow3: [0.9, 0.7, 0.3]              // Orange-yellow edge
          },
          pink: {
            gradient: ['#D4899A', '#DE95A6', '#E8A8B8', '#F0BCC8', '#F4CED8', '#F8DEE3'],
            shadow1: [0.9, 0.55, 0.65],           // Pink tint
            shadow2: [0.6, 0.35, 0.45],           // Pink tint
            shadow3: [0.88, 0.72, 0.78]           // Pink edge
          }
        };

        // Weighted random color selection
        function getRandomColor() {
          const rand = Math.random();
          if (rand < 0.6) return 'blue';      // 60% chance
          if (rand < 0.9) return 'yellow';    // 30% chance
          return 'pink';                       // 10% chance
        }

        let currentColor = getRandomColor();

        // Color icon colors (mid-tone for each theme)
        window.colorIconColors = {
          blue: '#B4DCE8',
          yellow: '#E2D060',
          pink: '#E4B8C0'
        };

        // Update note colors dynamically
        function updateNoteColors(colorKey) {
          const theme = colorThemes[colorKey];
          if (!theme) return;

          // Update color icon
          if (colorIcon) {
            colorIcon.style.background = colorIconColors[colorKey];
          }

          // Update gradient stops
          theme.gradient.forEach((color, i) => {
            const stop = document.getElementById(`grad-stop-${i}`);
            if (stop) stop.setAttribute('stop-color', color);
          });

          // Update shadow colors
          const shadow1 = document.getElementById('shadowColor1');
          const shadow2 = document.getElementById('shadowColor2');
          const shadow3 = document.getElementById('shadowColor3');

          if (shadow1) {
            // SVG drop shadows disabled â€” using CSS .note-shadow rectangle instead
            shadow1.setAttribute('values', `0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0`);
          }
          if (shadow2) {
            shadow2.setAttribute('values', `0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0`);
          }

          // Update favicon to match note color
          if (window.updateFavicon) window.updateFavicon(colorKey);

          // Update CSS shadow rectangle color to match theme
          const shadowEl = document.getElementById('note-shadow');
          if (shadowEl && theme.shadow2) {
            const [r, g, b] = theme.shadow2;
            const cr = Math.round(r * 255), cg = Math.round(g * 255), cb = Math.round(b * 255);
            shadowEl.style.background = `linear-gradient(to bottom, rgba(${cr},${cg},${cb},0) 0%, rgba(${cr},${cg},${cb},0.18) 100%)`;
          }
          if (shadow3) {
            const [r, g, b] = theme.shadow3;
            shadow3.setAttribute('values', `0 0 0 0 ${r} 0 0 0 0 ${g} 0 0 0 0 ${b} 0 0 0 1 0`);
          }
        }

        // Dynamic favicon â€” sticky note silhouette matching current color
        (function initDynamicFavicon() {
          const canvas = document.createElement('canvas');
          canvas.width = 32; canvas.height = 32;
          const ctx = canvas.getContext('2d');
          // Create link element for favicon
          let link = document.querySelector("link[rel*='icon']");
          if (!link) {
            link = document.createElement('link');
            link.rel = 'icon';
            document.head.appendChild(link);
          }
          window.updateFavicon = function(colorKey) {
            const theme = colorThemes[colorKey];
            if (!theme) return;
            ctx.clearRect(0, 0, 32, 32);
            // Scale the sticky note path (viewBox 287x270) down to 32x32
            // Original points: M34.6,19.27 L250.1,18.6 257.6,228.6 L28.6,231.1
            const sx = 32 / 287, sy = 32 / 270;
            // Create gradient matching note direction (bottom to top)
            const grad = ctx.createLinearGradient(
              153.1 * sx, 231.1 * sy,
              143.6 * sx, 18.6 * sy
            );
            const offsets = [0, 0.2559, 0.8124, 0.8649, 0.9543, 1];
            theme.gradient.forEach((c, i) => grad.addColorStop(offsets[i], c));
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(34.6 * sx, 19.27 * sy);
            ctx.lineTo(250.1 * sx, 18.6 * sy);
            ctx.lineTo(257.6 * sx, 228.6 * sy);
            ctx.lineTo(28.6 * sx, 231.1 * sy);
            ctx.closePath();
            ctx.fill();
            // Draw :) on the note
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(':)', 16, 17);
            link.href = canvas.toDataURL('image/png');
          };
        })();

        // Note state toggle (click to switch between curled and flat)
        const noteWrapper = document.getElementById('note-wrapper');
        const notePaper = document.getElementById('note-paper');
        const noteShape = document.getElementById('note-shape');
        const noteShadow = document.getElementById('note-shadow');
        let isFlat = false;

        // SVG path points for the two states (matching structure for smooth morphing)
        // Structure: [M, L, C1, C2, C3, L, C1, C2, C3]
        window.statePoints = {
          // Slightly tighter curl for intro â€” bottom-right corner lifted
          tightCurl: [
            [34.6016, 19.2695],    // M - start (same)
            [250.102, 18.5996],    // L - top right (same)
            [250.102, 18.5996],    // C1 (same)
            [249.602, 42.0],       // C2 - slightly tighter curve
            [262.0, 195.0],        // C3 - bottom right lifted up ~35px
            [28.6016, 231.1],      // L - bottom left (same)
            [36.6029, 66.5996],    // C1 (same)
            [34.6016, 19.2695],    // C2 (same)
            [34.6016, 19.2695]     // C3 (same)
          ],
          curled: [
            [34.6016, 19.2695],    // M - start
            [250.102, 18.5996],    // L - top right
            [250.102, 18.5996],    // C1 - control 1
            [249.602, 49.0996],    // C2 - control 2
            [257.602, 228.6],      // C3 - end (bottom right)
            [28.6016, 231.1],      // L - bottom left
            [36.6029, 66.5996],    // C1 - control 1
            [34.6016, 19.2695],    // C2 - control 2
            [34.6016, 19.2695]     // C3 - end (back to start)
          ],
          flat: [
            [29, 18],              // M - start
            [258, 18],             // L - top right
            [258, 18],             // C1 - control 1 (on line)
            [258, 125],            // C2 - control 2 (midpoint)
            [258, 232],            // C3 - end (bottom right)
            [29, 232],             // L - bottom left
            [29, 125],             // C1 - control 1 (midpoint)
            [29, 18],              // C2 - control 2 (on line)
            [29, 18]               // C3 - end (back to start)
          ]
        };

        // Convert points array to SVG path string
        function pointsToPath(points) {
          return `M${points[0][0]} ${points[0][1]} L${points[1][0]} ${points[1][1]} C${points[2][0]} ${points[2][1]} ${points[3][0]} ${points[3][1]} ${points[4][0]} ${points[4][1]} L${points[5][0]} ${points[5][1]} C${points[6][0]} ${points[6][1]} ${points[7][0]} ${points[7][1]} ${points[8][0]} ${points[8][1]} Z`;
        }

        // Interpolate between two point arrays
        function lerpPoints(from, to, t) {
          return from.map((point, i) => [
            point[0] + (to[i][0] - point[0]) * t,
            point[1] + (to[i][1] - point[1]) * t
          ]);
        }

        // Easing function (ease-out cubic)
        function easeOutCubic(t) {
          return 1 - Math.pow(1 - t, 3);
        }

        // Sync drawing layer clip-path to current note shape
        window.syncDrawingClip = function syncDrawingClip(points, targetLayer) {
          const dl = targetLayer || document.getElementById('note-drawing-layer');
          if (!dl) return;
          // SVG viewBox is 287x270, map to percentages
          const vw = 287, vh = 270;
          // Points: [M, L, C1, C2, C3(bottom-right), L(bottom-left), C1, C2, C3]
          // Sample key corners for polygon
          const tl = points[0], tr = points[1], br = points[4], bl = points[5];
          // Inset by ~2px (as % of viewBox) to avoid bleeding past note edge
          const inX = 2/vw*100, inY = 2/vh*100;
          const poly = [tl, tr, br, bl].map((p, i) => {
            const px = p[0]/vw*100, py = p[1]/vh*100;
            // Nudge each corner inward
            const dx = (i === 0 || i === 3) ? inX : -inX; // left corners right, right corners left
            const dy = (i === 0 || i === 1) ? inY : -inY; // top corners down, bottom corners up
            return `${(px + dx).toFixed(1)}% ${(py + dy).toFixed(1)}%`;
          }).join(', ');
          dl.style.clipPath = `polygon(${poly})`;
        }

        // Update shadow position based on note's screen position
        // Light source is at viewport center â€” shadow shifts away from center
        window.updateShadowPosition = function(wrapper) {
          const shadow = wrapper.querySelector('.note-shadow');
          if (!shadow) return;
          const rect = wrapper.getBoundingClientRect();
          const cx = rect.left + rect.width / 2;
          const cy = rect.top + rect.height / 2;
          const vw = window.innerWidth / 2;
          const vh = window.innerHeight / 2;
          // -1 to 1 range, how far from center
          const dx = (cx - vw) / vw;
          const dy = (cy - vh) / vh;
          // Max shift: 20px horizontal, 14px vertical
          const shiftX = dx * 20;
          const shiftY = dy * 14;
          // Top-right = sharper + darker, bottom-left = softer + lighter
          // Combine dx and dy: top-right is dx>0, dy<0 â†’ factor goes negative
          const cornerFactor = (dx - dy) / 2; // -1 (bottom-left) to +1 (top-right)
          const isLifted = wrapper.classList.contains('flat') || wrapper.classList.contains('drawing-mode');
          const baseBlur = isLifted ? 52 : 30;
          const blurAdjust = cornerFactor * -10; // top-right: less blur (-10), bottom-left: more (+10)
          const opacityAdjust = cornerFactor * 0.22; // top-right: darker (+0.22)
          const blur = Math.max(10, baseBlur + blurAdjust);
          shadow.style.transform = `translate(${shiftX}px, ${shiftY}px)`;
          shadow.style.filter = `blur(${blur}px)`;
          shadow.style.opacity = Math.min(1, Math.max(0.2, 1 + opacityAdjust));
        }

        // "Peel off" easing â€” resists at first then pops free
        function easePeelOff(t) {
          return t < 0.4
            ? 0.15 * Math.pow(t / 0.4, 2)                    // slow resist
            : 0.15 + 0.85 * Math.pow((t - 0.4) / 0.6, 0.5);  // quick release
        }

        // Animate path morphing
        let animationId = null;
        function animatePath(from, to, duration = 400) {
          if (animationId) cancelAnimationFrame(animationId);

          const startTime = performance.now();

          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutCubic(progress);

            const currentPoints = lerpPoints(from, to, easedProgress);
            noteShape.setAttribute('d', pointsToPath(currentPoints));
            // Sync drawing layer clip to note shape
            syncDrawingClip(currentPoints);

            if (progress < 1) {
              animationId = requestAnimationFrame(animate);
            }
          }

          animationId = requestAnimationFrame(animate);
        }

        // Flat gradient colors (more uniform, less dynamic)
        const flatGradients = {
          blue: ['#B3DDEE', '#B3DDEE', '#B3DDEE', '#B8E0F0', '#BDE3F2', '#C2E6F4'],
          yellow: ['#EACC58', '#EACC58', '#EACC58', '#EED464', '#F0D86E', '#F4E07A'],
          pink: ['#F0B8C6', '#F0B8C6', '#F0B8C6', '#F2C2CE', '#F4CAD4', '#F6D2DA']
        };

        // Parse hex color to RGB array
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
          ] : [0, 0, 0];
        }

        // Convert RGB array to hex
        function rgbToHex(r, g, b) {
          return '#' + [r, g, b].map(x => {
            const hex = Math.round(x).toString(16);
            return hex.length === 1 ? '0' + hex : hex;
          }).join('');
        }

        // Animate gradient transition
        let gradientAnimationId = null;
        function animateGradient(toFlat, duration = 400) {
          if (gradientAnimationId) cancelAnimationFrame(gradientAnimationId);

          const theme = colorThemes[currentColor];
          const fromColors = toFlat ? theme.gradient : flatGradients[currentColor];
          const toColors = toFlat ? flatGradients[currentColor] : theme.gradient;

          const fromRgb = fromColors.map(hexToRgb);
          const toRgb = toColors.map(hexToRgb);

          const startTime = performance.now();

          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutCubic(progress);

            fromRgb.forEach((from, i) => {
              const r = from[0] + (toRgb[i][0] - from[0]) * easedProgress;
              const g = from[1] + (toRgb[i][1] - from[1]) * easedProgress;
              const b = from[2] + (toRgb[i][2] - from[2]) * easedProgress;
              const stop = document.getElementById(`grad-stop-${i}`);
              if (stop) stop.setAttribute('stop-color', rgbToHex(r, g, b));
            });

            if (progress < 1) {
              gradientAnimationId = requestAnimationFrame(animate);
            }
          }

          gradientAnimationId = requestAnimationFrame(animate);
        }

        // Initialize lift/stick animations on any note wrapper
        window.initNoteAnimations = function(wrapper, colorKey, noteId, stopElements) {
          const shape = wrapper.querySelector('.note-paper path');
          // Use passed-in stops or query from wrapper
          const stops = stopElements || wrapper.querySelectorAll('svg stop') || [];
          let noteIsFlat = false;
          let noteAnimId = null;
          let noteGradAnimId = null;

          // Track current color â€” can be updated by color swatches
          let currentColorKey = colorKey;
          wrapper._getNoteColor = () => currentColorKey;
          wrapper._setNoteColor = (ck) => { currentColorKey = ck; };

          function getTheme() { return colorThemes[currentColorKey]; }
          function getFlatGrads() { return flatGradients[currentColorKey]; }

          function animateNotePath(from, to, duration = 400, easeFn = easeOutCubic) {
            if (noteAnimId) cancelAnimationFrame(noteAnimId);
            const startTime = performance.now();
            function anim(t) {
              const elapsed = t - startTime;
              const progress = Math.min(elapsed / duration, 1);
              const ep = easeFn(progress);
              const pts = lerpPoints(from, to, ep);
              shape.setAttribute('d', pointsToPath(pts));
              // Sync drawing clip for this note's canvas
              const dl = wrapper.querySelector('.note-drawing-layer');
              if (dl) syncDrawingClip(pts, dl);
              if (progress < 1) noteAnimId = requestAnimationFrame(anim);
            }
            noteAnimId = requestAnimationFrame(anim);
          }

          function animateNoteGradient(toFlat, duration = 400, easeFn = easeOutCubic) {
            if (noteGradAnimId) cancelAnimationFrame(noteGradAnimId);
            const theme = getTheme();
            const flatGrads = getFlatGrads();
            const fromColors = (toFlat ? theme.gradient : flatGrads).map(hexToRgb);
            const toColors = (toFlat ? flatGrads : theme.gradient).map(hexToRgb);
            const startTime = performance.now();
            function anim(t) {
              const elapsed = t - startTime;
              const progress = Math.min(elapsed / duration, 1);
              const ep = easeFn(progress);
              fromColors.forEach((from, i) => {
                const r = from[0] + (toColors[i][0] - from[0]) * ep;
                const g = from[1] + (toColors[i][1] - from[1]) * ep;
                const b = from[2] + (toColors[i][2] - from[2]) * ep;
                if (stops[i]) stops[i].setAttribute('stop-color', rgbToHex(r, g, b));
              });
              if (progress < 1) noteGradAnimId = requestAnimationFrame(anim);
            }
            noteGradAnimId = requestAnimationFrame(anim);
          }

          wrapper.addEventListener('note:lift', () => {
            if (!noteIsFlat) {
              noteIsFlat = true;
              wrapper.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
              animateNotePath(statePoints.curled, statePoints.flat, 400, easeOutCubic);
              animateNoteGradient(true, 400, easeOutCubic);
              wrapper.classList.add('flat');
            }
          });

          wrapper.addEventListener('note:stick', () => {
            if (noteIsFlat) {
              noteIsFlat = false;
              wrapper.style.transition = 'transform 0.18s ease-out';
              animateNotePath(statePoints.flat, statePoints.curled, 180, easeOutCubic);
              animateNoteGradient(false, 180, easeOutCubic);
              wrapper.classList.remove('flat');
              setTimeout(() => { wrapper.style.transition = ''; }, 200);
            }
          });

          // Click anywhere on note to focus textarea
          const noteTextarea = wrapper.querySelector('textarea');
          if (noteTextarea) {
            wrapper.addEventListener('click', (e) => {
              if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown')) return;
              noteTextarea.focus();
            });

            noteTextarea.addEventListener('focus', () => {
              if (!noteIsFlat) {
                noteIsFlat = true;
                wrapper.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                animateNotePath(statePoints.curled, statePoints.flat, 400, easeOutCubic);
                animateNoteGradient(true, 400, easeOutCubic);
                wrapper.classList.add('flat');
                const current = wrapper.style.transform || '';
                const base = current.replace(/scale\([^)]*\)/g, '').trim();
                wrapper.style.transform = (base ? base + ' ' : '') + 'scale(1.1)';
              }
            });

            noteTextarea.addEventListener('blur', () => {
              if (noteIsFlat) {
                noteIsFlat = false;
                wrapper.style.transition = 'transform 0.18s ease-out';
                animateNotePath(statePoints.flat, statePoints.curled, 180, easeOutCubic);
                animateNoteGradient(false, 180, easeOutCubic);
                wrapper.classList.remove('flat');
                const current = wrapper.style.transform || '';
                wrapper.style.transform = current.replace(/scale\([^)]*\)/g, '').trim();
                setTimeout(() => { wrapper.style.transition = ''; }, 200);
              }
            });
          }
        };

        // Get textarea element
        const textarea = document.getElementById('memo');

        // Tap anywhere on the note to focus textarea (fixes mobile double-tap)
        noteWrapper.addEventListener('click', (e) => {
          // Don't steal clicks from menu, dropdown, or drawing layer
          if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown') || e.target.closest('.drawing-toolbar')) return;
          // Only focus if click is on the actual note, not the shadow/curl area below
          const note = e.target.closest('.note');
          if (!note) return;
          const rect = note.getBoundingClientRect();
          const relY = (e.clientY - rect.top) / rect.height;
          if (relY > 0.82) return; // bottom ~18% is curl/shadow area
          textarea.focus();
        });

        // Calculate mobile scale so note fills width
        function updateMobileLayout() {
          if (window.innerWidth > 600) return; // Desktop doesn't need this
          const noteWidth = noteWrapper.offsetWidth || 320;
          const baseScale = (window.innerWidth - 16) / noteWidth;
          document.documentElement.style.setProperty('--mobile-note-scale', baseScale.toFixed(3));
          // Focused state is bigger than base
          document.documentElement.style.setProperty('--mobile-note-focus-scale', (baseScale * 1.08).toFixed(3));
        }
        updateMobileLayout();
        window.addEventListener('resize', updateMobileLayout);

        // Mobile: touchend for immediate focus without double-tap
        noteWrapper.addEventListener('touchend', (e) => {
          if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown') || e.target.closest('.drawing-toolbar')) return;
          if (noteWrapper.classList.contains('drawing-mode')) return;
          const note = e.target.closest('.note');
          if (!note) return;
          const rect = note.getBoundingClientRect();
          const touch = e.changedTouches[0];
          const relY = (touch.clientY - rect.top) / rect.height;
          if (relY > 0.82) return;
          e.preventDefault();
          textarea.focus({ preventScroll: true });
        });

        // Focus/blur on textarea triggers the flat/curled animation
        const focusOverlay = document.getElementById('focus-overlay');
        const langPicker2 = document.getElementById('lang-picker');

        // Click overlay to dismiss focused/drawing note
        focusOverlay.addEventListener('click', () => {
          if (isDrawingMode) return; // don't dismiss drawing mode from overlay
          textarea.blur();
          // Blur any spawned note textareas
          document.querySelectorAll('.dragged-note .textarea').forEach(t => t.blur());
        });

        // Custom events for external code (e.g., drag) to trigger flat/curl
        noteWrapper.addEventListener('note:lift', () => {
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            noteWrapper.classList.add('flat');
          }
        });

        noteWrapper.addEventListener('note:stick', () => {
          if (isFlat) {
            isFlat = false;
            animatePath(statePoints.flat, statePoints.curled);
            animateGradient(false);
            noteWrapper.classList.remove('flat');
          }
        });

        textarea.addEventListener('focus', () => {
          if (window._restoringNotes) return;
          setActiveNote('note-0');
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            // noteShadow.src removed - now CSS div
            noteWrapper.classList.add('flat');
            noteWrapper.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
            const current = noteWrapper.style.transform || '';
            const base = current.replace(/scale\([^)]*\)/g, '').replace(/translateY\([^)]*\)/g, '').trim();
            const isMobileView = window.innerWidth <= 600;
            const mobileScale = getComputedStyle(document.documentElement).getPropertyValue('--mobile-note-focus-scale') || '1.15';
            if (isMobileView) {
              noteWrapper.style.transform = (base ? base + ' ' : '') + 'scale(' + mobileScale + ') translateY(-100px)';
            } else {
              noteWrapper.style.transform = (base ? base + ' ' : '') + 'scale(1.1)';
            }
            focusOverlay.classList.add('active');
            langPicker2.classList.add('hidden');
          }
        });

        textarea.addEventListener('blur', () => {
          deactivateNote();
          // Don't close note when entering drawing mode
          if (isDrawingMode) return;
          if (isFlat) {
            isFlat = false;
            animatePath(statePoints.flat, statePoints.curled);
            animateGradient(false);
            // noteShadow.src removed - now CSS div
            noteWrapper.classList.remove('flat');
            const current = noteWrapper.style.transform || '';
            noteWrapper.style.transform = current.replace(/scale\([^)]*\)/g, '').replace(/translateY\([^)]*\)/g, '').trim();
            focusOverlay.classList.remove('active');
            langPicker2.classList.remove('hidden');
          }
        });

        // Menu toggle
        // Prevent menu/dropdown from stealing focus from textarea
        menuBtn.addEventListener('mousedown', (e) => e.preventDefault());
        dropdown.addEventListener('mousedown', (e) => e.preventDefault());
        menuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          menuBtn.classList.toggle('active');
          dropdown.classList.toggle('open');
          // Re-focus textarea so note stays in focused state
          if (isFlat) textarea.focus({ preventScroll: true });
          // Clamp dropdown to viewport
          if (dropdown.classList.contains('open')) {
            requestAnimationFrame(() => {
              const rect = dropdown.getBoundingClientRect();
              if (rect.right > window.innerWidth) {
                const overflow = rect.right - window.innerWidth + 8;
                dropdown.style.right = (8 + overflow) + 'px';
              } else {
                dropdown.style.right = '';
              }
            });
          } else {
            dropdown.style.right = '';
          }
        });

        // Close menu when clicking/tapping outside
        function closeMenuOutside(e) {
          if (!dropdown.contains(e.target) && !menuBtn.contains(e.target)) {
            dropdown.classList.remove('open');
            menuBtn.classList.remove('active');
            colorSubmenu.classList.remove('open');
          }
        }
        document.addEventListener('click', closeMenuOutside);
        document.addEventListener('touchstart', closeMenuOutside);

        // Color change functionality
        changeColorBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          colorSubmenu.classList.toggle('open');
        });

        colorSwatches.forEach(swatch => {
          swatch.addEventListener('click', (e) => {
            e.stopPropagation();
            const colorKey = swatch.dataset.color;
            currentColor = colorKey;
            updateNoteColors(colorKey);
            // Update animation color so lift/stick uses new color
            if (noteWrapper._setNoteColor) noteWrapper._setNoteColor(colorKey);
            // Update registry
            var reg = window.noteRegistry.get('note-0');
            if (reg) reg.color = colorKey;

            // Clear drawing when color changes (drawing is tied to note color)
            if (drawingCtx) {
              drawingCtx.clearRect(0, 0, noteDrawingLayer.width, noteDrawingLayer.height);
            }

            // Update active state
            colorSwatches.forEach(s => s.classList.remove('active'));
            swatch.classList.add('active');

            // Close menu
            dropdown.classList.remove('open');
            menuBtn.classList.remove('active');
            colorSubmenu.classList.remove('open');
          });
        });

        // Add stamp (placeholder)
        addStampBtn.addEventListener('click', () => {
          alert('Stamp feature coming soon!');
          dropdown.classList.remove('open');
          menuBtn.classList.remove('active');
        });

        // ==========================================
        // Drawing Mode (draws directly on note)
        // ==========================================
        window.isDrawingMode = false;
        let drawingCtx = null;
        let isDrawing = false;
        let savedImageData = null;

        // Shared drawing state for multi-note support
        window.activeDrawingNote = null;    // which wrapper is in drawing mode
        window.activeDrawingCanvas = null;
        window.activeDrawingCtx = null;
        window.activeSavedImageData = null;

        // Initialize note drawing layer
        function initNoteDrawingLayer() {
          noteDrawingLayer.width = stickyNote.offsetWidth * 2;
          noteDrawingLayer.height = stickyNote.offsetHeight * 2;
          drawingCtx = noteDrawingLayer.getContext('2d');
          drawingCtx.scale(2, 2);
          drawingCtx.lineCap = 'round';
          drawingCtx.lineJoin = 'round';
          drawingCtx.strokeStyle = 'rgba(26, 26, 26, 0.7)';
          drawingCtx.lineWidth = 1.5;
        }
        
        // Pen settings â€” ballpoint pen: slightly thinner + semi-transparent
        window.currentPenColor = 'rgba(26, 26, 26, 0.7)';
        window.currentPenSize = 1.5;

        initNoteDrawingLayer();

        // Register original note as note-0
        noteWrapper.dataset.noteId = 'note-0';
        window.noteRegistry.set('note-0', {
          wrapper: noteWrapper,
          color: currentColor,
          getText: function() { return textarea.value; },
          getDrawing: function() { return noteDrawingLayer.toDataURL('image/png'); },
          getDrawingCanvas: function() { return noteDrawingLayer; }
        });
        window.lastActiveNoteId = 'note-0';

        // Close any active drawing mode (used when switching notes)
        window.closeActiveDrawingMode = function() {
          if (activeDrawingNote) {
            if (activeSavedImageData && activeDrawingCtx) {
              activeDrawingCtx.putImageData(activeSavedImageData, 0, 0);
            }
            document.body.classList.remove('drawing-mode-active');
            activeDrawingNote.classList.remove('drawing-mode');
            activeDrawingNote.dispatchEvent(new Event('note:stick'));
            activeDrawingNote = null;
            activeDrawingCanvas = null;
            activeDrawingCtx = null;
            activeSavedImageData = null;
          }
          isDrawingMode = false;
          isDrawing = false;
          const toolbar = document.getElementById('drawing-toolbar');
          if (toolbar) toolbar.classList.remove('visible');
          const focusOverlay = document.querySelector('.focus-overlay');
          if (focusOverlay) focusOverlay.classList.remove('active');
        };

        // Open drawing mode
        drawBtn.addEventListener('click', () => {
          dropdown.classList.remove('open');
          menuBtn.classList.remove('active');
          setActiveNote('note-0');

          // Close any other note's drawing mode
          if (activeDrawingNote && activeDrawingNote !== noteWrapper) {
            closeActiveDrawingMode();
          }

          isDrawingMode = true;

          // Save current drawing state for cancel
          savedImageData = drawingCtx.getImageData(0, 0, noteDrawingLayer.width, noteDrawingLayer.height);

          // Set shared active state
          activeDrawingNote = noteWrapper;
          activeDrawingCanvas = noteDrawingLayer;
          activeDrawingCtx = drawingCtx;
          activeSavedImageData = savedImageData;

          // Put note in flat state
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            // noteShadow.src removed - now CSS div
            noteWrapper.classList.add('flat');
          }

          // Hide keyboard but keep note open
          isDrawingMode = true;
          textarea.blur();
          // Re-assert flat state since blur removes it
          isFlat = true;
          noteWrapper.classList.add('flat');
          focusOverlay.classList.add('active');
          langPicker2.classList.add('hidden');

          // Enable drawing mode
          document.body.classList.add('drawing-mode-active');
          noteWrapper.classList.add('drawing-mode');
          // Position toolbar then show
          positionToolbar(noteWrapper);
          drawingToolbar.classList.add('visible');

          // Hide placeholder text if textarea is empty
          const memo = document.getElementById('memo');
          if (memo && !memo.value.trim()) {
            memo.classList.add('hide-for-drawing');
          }

          // Sync pen settings
          drawingCtx.strokeStyle = currentPenColor;
          drawingCtx.lineWidth = currentPenSize;
        });

        // Drawing on canvas - use event delegation via document for any active canvas
        function handleDrawPointerDown(e) {
          const canvas = e.target.closest('.note-drawing-layer');
          if (!canvas || !isDrawingMode) return;
          // Only draw on the active note's canvas
          if (activeDrawingCanvas && canvas !== activeDrawingCanvas) return;
          isDrawing = true;
          const ctx = activeDrawingCtx || drawingCtx;
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width / 2;
          const scaleY = canvas.height / rect.height / 2;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;
          ctx.beginPath();
          ctx.moveTo(x, y);
        }

        function handleDrawPointerMove(e) {
          if (!isDrawingMode || !isDrawing) return;
          const canvas = activeDrawingCanvas || noteDrawingLayer;
          const ctx = activeDrawingCtx || drawingCtx;
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width / 2;
          const scaleY = canvas.height / rect.height / 2;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;
          ctx.lineTo(x, y);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x, y);
        }

        function handleDrawPointerUp() {
          isDrawing = false;
        }

        document.addEventListener('pointerdown', handleDrawPointerDown);
        document.addEventListener('pointermove', handleDrawPointerMove);
        document.addEventListener('pointerup', handleDrawPointerUp);

        // Clear drawing
        clearBtn.addEventListener('click', () => {
          const ctx = activeDrawingCtx || drawingCtx;
          const canvas = activeDrawingCanvas || noteDrawingLayer;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        // Cancel drawing - restore previous state
        cancelBtn.addEventListener('click', () => {
          const ctx = activeDrawingCtx || drawingCtx;
          const sd = activeSavedImageData || savedImageData;
          if (sd) {
            ctx.putImageData(sd, 0, 0);
          }
          closeDrawingMode();
        });

        // Done drawing
        doneBtn.addEventListener('click', () => {
          closeDrawingMode();
        });

        function closeDrawingMode() {
          const targetWrapper = activeDrawingNote || noteWrapper;
          const isOriginalNote = (targetWrapper === noteWrapper);

          deactivateNote();
          isDrawingMode = false;
          isDrawing = false;
          savedImageData = null;
          document.body.classList.remove('drawing-mode-active');
          targetWrapper.classList.remove('drawing-mode');
          drawingToolbar.classList.remove('visible');
          // Check if canvas has drawing content
          const activeCanvas = activeDrawingCanvas;
          let hasDrawing = false;
          if (activeCanvas) {
            const ctx = activeCanvas.getContext('2d');
            const px = ctx.getImageData(0, 0, activeCanvas.width, activeCanvas.height).data;
            for (let i = 3; i < px.length; i += 4) {
              if (px[i] > 0) { hasDrawing = true; break; }
            }
          }

          // Restore placeholder â€” but hide it if there's a drawing and no typed text
          const memo2 = document.getElementById('memo');
          if (memo2) memo2.classList.remove('hide-for-drawing');
          const targetTa = targetWrapper.querySelector('.textarea');
          if (targetTa) {
            targetTa.classList.remove('hide-for-drawing');
            if (hasDrawing && !targetTa.value.trim()) {
              targetTa.placeholder = '';
            }
          }

          if (isOriginalNote) {
            // Original note: full close with animations
            if (isFlat) {
              isFlat = false;
              animatePath(statePoints.flat, statePoints.curled);
              animateGradient(false);
              // noteShadow.src removed - now CSS div
              noteWrapper.classList.remove('flat');
              const current = noteWrapper.style.transform || '';
              noteWrapper.style.transform = current.replace(/scale\([^)]*\)/g, '').replace(/translateY\([^)]*\)/g, '').trim();
              focusOverlay.classList.remove('active');
              langPicker2.classList.remove('hidden');
            }
            textarea.blur();
          } else {
            // Spawned note: dispatch stick event
            targetWrapper.dispatchEvent(new Event('note:stick'));
            targetWrapper.classList.remove('flat');
            const ta = targetWrapper.querySelector('textarea');
            if (ta) ta.blur();
          }

          // Clear active state
          activeDrawingNote = null;
          activeDrawingCanvas = null;
          activeDrawingCtx = null;
          activeSavedImageData = null;

          // Force Safari to re-render the SVG filter/shadow
          requestAnimationFrame(() => {
            const notePaperEl = targetWrapper.querySelector('.note-paper');
            if (notePaperEl) {
              notePaperEl.style.willChange = 'transform';
              requestAnimationFrame(() => {
                notePaperEl.style.willChange = '';
              });
            }
            targetWrapper.style.willChange = 'transform';
            requestAnimationFrame(() => {
              targetWrapper.style.willChange = '';
            });
          });
        }

        // Pen color picker
        // Color picker popup
        const penColorCurrent = document.getElementById('pen-color-current');
        const penColorPopup = document.getElementById('pen-color-popup');

        penColorCurrent.addEventListener('click', (e) => {
          e.stopPropagation();
          penColorPopup.classList.toggle('visible');
        });

        document.querySelectorAll('.pen-color').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.pen-color').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const rgb = btn.dataset.color;
            currentPenColor = `rgba(${rgb}, 0.7)`;
            const ctx = activeDrawingCtx || drawingCtx;
            if (ctx) ctx.strokeStyle = currentPenColor;
            // Update current swatch color
            penColorCurrent.style.background = btn.style.background;
            penColorPopup.classList.remove('visible');
          });
        });

        // Close color popup on outside click
        document.addEventListener('click', () => {
          penColorPopup.classList.remove('visible');
        });

        // Pen size picker
        document.querySelectorAll('.pen-size').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.pen-size').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentPenSize = parseInt(btn.dataset.size);
            const ctx = activeDrawingCtx || drawingCtx;
            if (ctx) ctx.lineWidth = currentPenSize;
          });
        });

        // Handle window resize â€” preserve drawing data
        window.addEventListener('resize', () => {
          const canvas = noteDrawingLayer;
          const oldData = drawingCtx ? canvas.toDataURL() : null;
          initNoteDrawingLayer();
          if (oldData) {
            const img = new Image();
            img.onload = () => {
              drawingCtx.save();
              drawingCtx.setTransform(1, 0, 0, 1, 0, 0);
              drawingCtx.drawImage(img, 0, 0, canvas.width, canvas.height);
              drawingCtx.restore();
            };
            img.src = oldData;
          }
        });

        // Apply random color on load and update active swatch
        updateNoteColors(currentColor);
        // Set initial drawing clip from curled state
        syncDrawingClip(statePoints.curled);
        colorSwatches.forEach(s => {
          s.classList.toggle('active', s.dataset.color === currentColor);
        });

        // Apply intro gradient lightening AFTER color theme is set
        if (window._introNeedsGradient) {
          const s0 = document.getElementById('grad-stop-0');
          const s1 = document.getElementById('grad-stop-1');
          window._introOrigStop0 = s0.getAttribute('stop-color');
          window._introOrigStop1 = s1.getAttribute('stop-color');
          function lightenWarm(hex) {
            const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
            return '#' + [
              Math.min(255, Math.round(r + (255-r)*0.4 + 15)),
              Math.min(255, Math.round(g + (255-g)*0.4 + 8)),
              Math.min(255, Math.round(b + (255-b)*0.3))
            ].map(c => c.toString(16).padStart(2,'0')).join('');
          }
          window._introLightStop0 = lightenWarm(window._introOrigStop0);
          window._introLightStop1 = lightenWarm(window._introOrigStop1);
          s0.setAttribute('stop-color', window._introLightStop0);
          s1.setAttribute('stop-color', window._introLightStop1);
        }

        // ==========================================
        // Apple Wallet Pass Generation
        // ==========================================
        const appleWalletBtn = document.getElementById('apple-wallet-btn');
        const walletMsg = document.getElementById('wallet-message');
        const walletQr = document.getElementById('wallet-qr');
        let qrVisible = false;

        // Detect if user is on mobile (iOS/Android)
        function isMobile() {
          return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        }

        appleWalletBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          const targetNote = window.getTargetNote();
          const text = targetNote ? targetNote.getText() : document.getElementById('memo').value;
          const noteColor = targetNote ? targetNote.color : currentColor;
          const drawCanvas = targetNote ? (targetNote.getDrawingCanvas ? targetNote.getDrawingCanvas() : null) : noteDrawingLayer;

          const BACKEND_URL = 'https://wallet-api.britonbaker.com';

          // Render strip: background color + drawing composited via canvas-to-canvas (no Image decode)
          let stripBlob = null;
          try {
            const STRIP_W = 1125, STRIP_H = 1032;
            const FC = { blue: '#9dd5ee', yellow: '#e2d060', pink: '#e4b8c0' };
            const sc = document.createElement('canvas');
            sc.width = STRIP_W; sc.height = STRIP_H;
            const sx = sc.getContext('2d');
            sx.fillStyle = FC[noteColor] || FC.blue;
            sx.fillRect(0, 0, STRIP_W, STRIP_H);
            if (drawCanvas && drawCanvas.width > 0 && drawCanvas.height > 0) {
              const scale = STRIP_W / drawCanvas.width;
              sx.drawImage(drawCanvas, 0, 0, STRIP_W, drawCanvas.height * scale);
            }
            stripBlob = await new Promise(r => sc.toBlob(r, 'image/png'));
          } catch(e) { console.warn('Strip render skipped:', e); }

          if (!isMobile()) {
            // Desktop: toggle QR code inside the button
            if (qrVisible) {
              appleWalletBtn.classList.remove('qr-open');
              setTimeout(() => { walletQr.innerHTML = ''; }, 400);
              qrVisible = false;
              return;
            }

            // Prepare pass on server (includes drawing), get token for QR
            try {
              // Show cycling placeholder QR codes while loading
              const placeholderTexts = ['walletmemo.com/loading', 'walletmemo.com/memo', 'walletmemo.com/pass'];
              let placeholderIdx = 0;
              function showPlaceholderQR() {
                const pqr = qrcode(0, 'M');
                pqr.addData(placeholderTexts[placeholderIdx % placeholderTexts.length]);
                pqr.make();
                const pImg = document.createElement('img');
                pImg.src = pqr.createDataURL(4, 4);
                pImg.style.cssText = 'width:100%;height:auto;display:block;opacity:0.35;transition:opacity 0.25s;';
                const pInner = document.createElement('div');
                pInner.style.cssText = 'background:#fff;border-radius:6px;padding:8px;width:100%;box-sizing:border-box;';
                pInner.appendChild(pImg);
                walletQr.innerHTML = '';
                walletQr.appendChild(pInner);
                placeholderIdx++;
              }
              showPlaceholderQR();
              const placeholderInterval = setInterval(showPlaceholderQR, 400);
              appleWalletBtn.classList.add('qr-open');
              
              const dFormData = new FormData();
              dFormData.append('text', text);
              dFormData.append('color', noteColor);
              if (stripBlob) dFormData.append('strip', stripBlob, 'strip.png');
              const prepRes = await fetch(`${BACKEND_URL}/api/prepare-pass`, {
                method: 'POST',
                body: dFormData
              });
              const { token } = await prepRes.json();
              const passUrl = `${BACKEND_URL}/api/download-pass/${token}`;
              
              const qr = qrcode(0, 'M');
              qr.addData(passUrl);
              qr.make();
              const btnImg = document.getElementById('apple-wallet-img');
              const btnWidth = btnImg ? btnImg.offsetWidth : 120;
              const img = document.createElement('img');
              img.src = qr.createDataURL(4, 4);
              img.style.width = '100%';
              img.style.height = 'auto';
              img.style.display = 'block';
              const qrInner = document.createElement('div');
              qrInner.style.cssText = 'background:#fff;border-radius:6px;padding:8px;width:100%;box-sizing:border-box;';
              qrInner.appendChild(img);
              clearInterval(placeholderInterval);
              walletQr.innerHTML = '';
              walletQr.appendChild(qrInner);
              qrVisible = true;
            } catch (err) {
              clearInterval(placeholderInterval);
              console.error('QR generation failed:', err);
              walletQr.innerHTML = '';
              appleWalletBtn.classList.remove('qr-open');
              alert('QR Error: ' + err.message);
            }
            return;
          }
          
          // Mobile: download pass directly
          const originalContent = appleWalletBtn.innerHTML;
          appleWalletBtn.style.opacity = '0.6';
          appleWalletBtn.style.pointerEvents = 'none';
          
          try {
            // Single-request pass generation via pass-redirect (no KV, no replication lag)
            const passText = btoa(unescape(encodeURIComponent(text || '')));
            window.location.href = `${BACKEND_URL}/api/pass-redirect?t=${encodeURIComponent(passText)}&c=${encodeURIComponent(noteColor)}`;
    // â”€â”€ âœ“ Added toast + note flies into wallet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            (function() {
              function dismissPill(pill, timer) {
                clearTimeout(timer);
                pill.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                requestAnimationFrame(function() {
                  pill.style.opacity = '0';
                  pill.style.transform = 'translateX(-50%) translateY(-20px)';
                  setTimeout(function() { pill.remove(); }, 350);
                });
              }

              // 1. Toast drops in from top after 3.5s
              setTimeout(function() {
                var pill = document.createElement('div');
                pill.className = 'wallet-added-pill';
                var label = document.createElement('span');
                label.textContent = 'Added to Wallet';
                pill.appendChild(label);
                var xBtn = document.createElement('button');
                xBtn.className = 'pill-dismiss';
                xBtn.textContent = 'x';
                xBtn.setAttribute('aria-label', 'Dismiss');
                pill.appendChild(xBtn);
                document.body.appendChild(pill);
                requestAnimationFrame(function() {
                  requestAnimationFrame(function() { pill.classList.add('pop-in'); });
                });
                var autoDismissTimer = setTimeout(function() {
                  dismissPill(pill, autoDismissTimer);
                }, 5000);
                xBtn.addEventListener('click', function() {
                  dismissPill(pill, autoDismissTimer);
                });
              }, 3500);

              // 2. Note flies into wallet — restart button in normal flow
              var targetNote = window.getTargetNote();
              var nw = (targetNote && targetNote.wrapper)
                ? targetNote.wrapper
                : document.getElementById('note-wrapper');

              if (nw) {
                var ta = nw.querySelector('textarea');
                if (ta) ta.value = '';

                // Insert restart button as a flow sibling — no coordinate math needed
                var restartBtn = document.createElement('div');
                restartBtn.className = 'add-note-btn';
                restartBtn.innerHTML = '<div class="plus-icon"></div>';
                restartBtn.style.position   = 'relative';
                restartBtn.style.display    = 'none';
                restartBtn.style.opacity    = '0';
                restartBtn.style.transition = 'opacity 0.35s ease';
                nw.parentNode.insertBefore(restartBtn, nw.nextSibling);

                // Fall animation
                nw.classList.add('note-wallet-exit');
                setTimeout(function() {
                  var cs = window.getComputedStyle(nw);
                  nw.style.display = 'none';
                  nw.classList.remove('note-wallet-exit');
                  nw.style.transform = '';

                  // Smaller button: 160px square, centered
                  restartBtn.style.width        = '160px';
                  restartBtn.style.height       = '160px';
                  restartBtn.style.marginBottom = cs.marginBottom;
                  restartBtn.style.marginLeft   = 'auto';
                  restartBtn.style.marginRight  = 'auto';
                  restartBtn.style.display      = 'flex';
                  // Fade in when the toast appears (3.5s), not immediately
                  setTimeout(function() {
                    restartBtn.style.opacity = '1';
                  }, 3500);

                  restartBtn.addEventListener('click', function onRestart() {
                    restartBtn.removeEventListener('click', onRestart);
                    restartBtn.style.opacity = '0';
                    setTimeout(function() { restartBtn.remove(); }, 350);
                    var note0 = document.getElementById('note-wrapper');
                    if (!note0) return;
                    var cvs = note0.querySelector('.note-drawing-layer');
                    if (cvs) { var ctx2 = cvs.getContext('2d'); if (ctx2) ctx2.clearRect(0,0,cvs.width,cvs.height); }
                    note0.dispatchEvent(new Event('note:stick'));
                    note0.classList.remove('flat','drawing-mode','note-wallet-exit');
                    var cur = note0.style.transform || '';
                    note0.style.transform = cur.replace(/scale\([^)]*\)/g,'').replace(/translateY\([^)]*\)/g,'').trim();
                    note0.style.display = '';
                    note0.classList.remove('note-land-in');
                    requestAnimationFrame(function() {
                      requestAnimationFrame(function() {
                        note0.classList.add('note-land-in');
                        note0.addEventListener('animationend', function() {
                          note0.classList.remove('note-land-in');
                        }, { once: true });
                      });
                    });
                  });
                }, 550);
              }
            })();
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

          } catch (error) {
            console.error('Error:', error);
            walletMsg.textContent = error.message.includes('fetch') 
              ? 'Backend not running. Start the server first!'
              : error.message;
            walletMsg.classList.add('visible');
            setTimeout(() => walletMsg.classList.remove('visible'), 3000);
          } finally {
            appleWalletBtn.style.opacity = '1';
            appleWalletBtn.style.pointerEvents = 'auto';
          }
        });
      })();

      // Desktop drag-to-move sticky note + "add new" pad
      (function() {
        if ('ontouchstart' in window) return; // Skip on mobile

        const mainArea = document.querySelector('main') || document.querySelector('.content-wrapper');
        const wrapper = document.getElementById('note-wrapper');
        const dragZoneHeight = 80;
        let noteCounter = 0;
        let hasMoved = false;

        // Create the "add new note" button that sits behind the note
        const addBtn = document.createElement('div');
        addBtn.className = 'add-note-btn';
        addBtn.innerHTML = '<div class="plus-icon"></div>';
        addBtn.style.display = 'none';
        wrapper.parentElement.insertBefore(addBtn, wrapper);

        function makeDraggable(el) {
          let isDragging = false;
          let startX, startY, origX = 0, origY = 0;
          let offsetX = 0, offsetY = 0;
          let tiltDeg = 3;

          el.addEventListener('mousemove', (e) => {
            if (isDragging) return;
            const rect = el.getBoundingClientRect();
            const relY = e.clientY - rect.top;
            if (relY < dragZoneHeight && !e.target.closest('.note-menu-btn') && !e.target.closest('.note-dropdown')) {
              el.classList.add('can-grab');
            } else {
              el.classList.remove('can-grab');
            }
          });

          el.addEventListener('mousedown', (e) => {
            const rect = el.getBoundingClientRect();
            const relY = e.clientY - rect.top;
            if (relY >= dragZoneHeight) return;
            if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown')) return;
            if (isDrawingMode) return;
            if (el.querySelector('.note-dropdown.open')) return;

            e.preventDefault();
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            origX = offsetX;
            origY = offsetY;
            el.classList.remove('can-grab');
            el.classList.add('is-grabbing');
            // Track active note
            if (el.dataset.noteId) setActiveNote(el.dataset.noteId);
            el.style.transition = 'none';
            // Lower all other notes, raise this one highest
            document.querySelectorAll('.note-wrapper').forEach(n => {
              if (n !== el) {
                n.style.zIndex = '1';
                n.style.transition = 'transform 0.3s ease';
              }
            });
            el.style.zIndex = '100';
            // Lift off the wall - go flat
            el.classList.add('flat');
            el.dispatchEvent(new Event('note:lift'));
            const elRect = el.getBoundingClientRect();
            tiltDeg = (e.clientX < elRect.left + elRect.width / 2) ? 3 : -3;
            el.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(1.03) rotate(${tiltDeg}deg)`;
            // Show add button immediately on grab
            if (!hasMoved) {
              hasMoved = true;
              addBtn.style.display = 'flex';
            }
          });

          document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            offsetX = origX + dx;
            offsetY = origY + dy;
            el.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(1.03) rotate(${tiltDeg}deg)`;
            updateShadowPosition(el);
          });

          document.addEventListener('mouseup', () => {
            if (!isDragging) return;
            isDragging = false;
            el.classList.remove('is-grabbing');
            el.classList.add('can-grab');
            deactivateNote();
            el.style.transition = '';
            // Stick back to wall - remove flat, go back to curled
            el.classList.remove('flat');
            el.dispatchEvent(new Event('note:stick'));
            el.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            updateShadowPosition(el);
            const ta = el.querySelector('textarea');
            if (ta) ta.blur();
            // Suppress the click event that fires after mouseup
            // so it doesn't re-focus the textarea and flatten the note
            el.addEventListener('click', function suppressClick(evt) {
              evt.stopPropagation();
              evt.preventDefault();
              el.removeEventListener('click', suppressClick, true);
            }, true);
          });
        }

        makeDraggable(wrapper);
        updateShadowPosition(wrapper);

        // (intro animation moved to standalone script block below)

        // Add new note button
        const placeholders = [
          "Pick up groceries\nCall dentist\nStretch!",
          "Idea: build an app\nResearch competitors\nSketch wireframes",
          "Monday meeting\nBring snacks\nAsk about timeline",
          "Gift ideas:\nNew headphones?\nBook about space",
          "Workout plan\nRun 2 miles\nDrink more water",
          "Movie night picks:\nInterstellar\nEverything Everywhere",
          "Pack for trip\nCharger\nPassport\nSnacks",
          "Learn something new\nWatch a tutorial\nTake notes",
          "Groceries:\nAvocados\nSourdough\nCoffee beans",
          "Weekend plans\nFarmers market\nCook dinner\nRead",
          "Buy it.\nUse it.\nBreak it.\nFix it.",
          "It doesn't have to\nbe done. It just has\nto be perfect.",
          "Drink water.",
          "Send the email.",
          "Stretch for\n30 seconds.\nCount it.",
          "Call dentist.",
          "Don't turn\nOff.",
        ];

        addBtn.addEventListener('click', () => {
          try {
          noteCounter++;
          const colors = ['blue', 'yellow', 'pink'];
          const color = colors[noteCounter % 3];

          // Color configs (gradient + shadow colors per theme)
          const colorMap = {
            blue: ['#89C5E0', '#98C4DA', '#9BC8E7', '#ACD7E9', '#B8E3F3', '#C4E9F5'],
            yellow: ['#DAAF40', '#E0C04C', '#E6CC5E', '#EEDA70', '#F2E082', '#F7EA9C'],
            pink: ['#D4899A', '#DE95A6', '#E8A8B8', '#F0BCC8', '#F4CED8', '#F8DEE3']
          };
          // SVG drop shadows disabled â€” using CSS .note-shadow rectangle instead
          const shadowMap = {
            blue: {
              s1: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
              s2: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
              s3: '0 0 0 0 0.425615 0 0 0 0 0.695906 0 0 0 0 0.842314 0 0 0 1 0'
            },
            yellow: {
              s1: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
              s2: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
              s3: '0 0 0 0 0.9 0 0 0 0 0.7 0 0 0 0 0.3 0 0 0 1 0'
            },
            pink: {
              s1: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
              s2: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
              s3: '0 0 0 0 0.88 0 0 0 0 0.72 0 0 0 0 0.78 0 0 0 1 0'
            }
          };
          const g = colorMap[color];
          const s = shadowMap[color];

          const newWrapper = document.createElement('div');
          newWrapper.className = 'note-wrapper dragged-note';
          newWrapper.style.position = 'absolute';
          newWrapper.style.top = wrapper.offsetTop + 'px';
          newWrapper.style.left = wrapper.offsetLeft + 'px';
          newWrapper.style.width = '360px';
          newWrapper.style.height = '340px';
          newWrapper.style.zIndex = String(10 + noteCounter);

          // Use DOMParser to create proper SVG namespace elements
          const svgMarkup = `<svg class="note-paper" width="287" height="270" viewBox="0 0 287 270" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g filter="url(#nf${noteCounter})">
                <path d="M34.6016 19.2695L250.102 18.5996C250.102 18.5996 249.602 49.0996 257.602 228.6L28.6016 231.1C36.6029 66.5996 34.6016 19.2695 34.6016 19.2695Z" fill="url(#ng${noteCounter})"/>
              </g>
              <defs>
                <linearGradient id="ng${noteCounter}" x1="153.102" y1="231.1" x2="143.601" y2="18.5996" gradientUnits="userSpaceOnUse">
                  <stop stop-color="${g[0]}"/>
                  <stop offset="0.255906" stop-color="${g[1]}"/>
                  <stop offset="0.812358" stop-color="${g[2]}"/>
                  <stop offset="0.864881" stop-color="${g[3]}"/>
                  <stop offset="0.954264" stop-color="${g[4]}"/>
                  <stop offset="1" stop-color="${g[5]}"/>
                </linearGradient>
                <filter id="nf${noteCounter}" x="0.00156212" y="-0.000391006" width="286.2" height="269.7" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
                  <feFlood flood-opacity="0" result="BackgroundImageFix"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
                  <feOffset/>
                  <feGaussianBlur stdDeviation="5.14583"/>
                  <feColorMatrix type="matrix" values="${s.s1}"/>
                  <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
                  <feOffset dy="10"/>
                  <feGaussianBlur stdDeviation="14.3"/>
                  <feColorMatrix type="matrix" values="${s.s2}"/>
                  <feBlend mode="normal" in2="effect1_dropShadow" result="effect2_dropShadow"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
                  <feOffset dy="0.2"/>
                  <feComposite in2="hardAlpha" operator="out"/>
                  <feColorMatrix type="matrix" values="${s.s3}"/>
                  <feBlend mode="normal" in2="effect2_dropShadow" result="effect3_dropShadow"/>
                  <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
                  <feTurbulence type="fractalNoise" baseFrequency="1.6666666269302368 1.6666666269302368" stitchTiles="stitch" numOctaves="3" result="noise" seed="${6167 + noteCounter}"/>
                  <feComponentTransfer in="noise" result="coloredNoise1">
                    <feFuncR type="linear" slope="2" intercept="-0.5"/>
                    <feFuncG type="linear" slope="2" intercept="-0.5"/>
                    <feFuncB type="linear" slope="2" intercept="-0.5"/>
                    <feFuncA type="discrete" tableValues="1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"/>
                  </feComponentTransfer>
                  <feComposite operator="in" in2="shape" in="coloredNoise1" result="noise1Clipped"/>
                  <feComponentTransfer in="noise1Clipped" result="color1">
                    <feFuncA type="table" tableValues="0 0.06"/>
                  </feComponentTransfer>
                  <feMerge result="effect4_noise">
                    <feMergeNode in="shape"/>
                    <feMergeNode in="color1"/>
                  </feMerge>
                  <feBlend mode="normal" in="effect4_noise" in2="effect3_dropShadow" result="effect4_noise"/>
                </filter>
              </defs>
            </svg>`;
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(svgMarkup, 'image/svg+xml');
          const svgNode = document.adoptNode(svgDoc.documentElement);
          
          const noteDiv = document.createElement('div');
          noteDiv.className = 'note';
          noteDiv.style.cssText = 'width:360px;height:340px;padding:48px 57px;position:absolute;top:0;left:0;z-index:2;display:flex;flex-direction:column;justify-content:center;';
          const ta = document.createElement('textarea');
          ta.className = 'textarea';
          ta.maxLength = 140;
          ta.style.cssText = "font-family:'Patrick Hand',cursive;font-size:20px;line-height:1.5;color:#1a1a1a;border:none;background:transparent;resize:none;outline:none;text-align:center;width:100%;overflow:hidden;";
          noteDiv.appendChild(ta);

          // Add drawing canvas to spawned note
          const spawnCanvas = document.createElement('canvas');
          spawnCanvas.className = 'note-drawing-layer';
          noteDiv.appendChild(spawnCanvas);
          // Apply initial clip-path matching note shape
          syncDrawingClip(statePoints.curled, spawnCanvas);

          // Add menu button to spawned note
          const spawnMenuBtn = document.createElement('button');
          spawnMenuBtn.className = 'note-menu-btn';
          spawnMenuBtn.innerHTML = '<svg viewBox="0 0 24 24"><circle cx="12" cy="5" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="12" cy="19" r="2"/></svg>';

          const spawnDropdown = document.createElement('div');
          spawnDropdown.className = 'note-dropdown';
          spawnDropdown.innerHTML = `
            <button class="dropdown-item spawn-color-btn">
              <span class="color-icon" style="background:${colorIconColors[color]};"></span>
              <span>Change Color</span>
            </button>
            <div class="color-submenu">
              <div class="color-swatch" data-color="blue" style="background: #B4DCE8;"></div>
              <div class="color-swatch" data-color="yellow" style="background: #EAD264;"></div>
              <div class="color-swatch" data-color="pink" style="background: #ECBDC5;"></div>
            </div>
            <button class="dropdown-item" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="10" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
              <span>Add Stamp</span> <span class="coming-soon-tag">Coming soon</span>
            </button>
            <button class="dropdown-item" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 14s1.5 2 4 2 4-2 4-2"/><line x1="9" y1="9" x2="9.01" y2="9"/><line x1="15" y1="9" x2="15.01" y2="9"/></svg>
              <span>Stickers</span> <span class="coming-soon-tag">Coming soon</span>
            </button>
            <button class="dropdown-item spawn-draw-btn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/></svg>
              <span>Draw on Note</span>
            </button>
          `;
          noteDiv.appendChild(spawnMenuBtn);
          noteDiv.appendChild(spawnDropdown);

          // Init drawing canvas for this note
          let spawnDrawingCtx = null;
          function initSpawnCanvas() {
            spawnCanvas.width = noteDiv.offsetWidth * 2;
            spawnCanvas.height = noteDiv.offsetHeight * 2;
            spawnDrawingCtx = spawnCanvas.getContext('2d');
            spawnDrawingCtx.scale(2, 2);
            spawnDrawingCtx.lineCap = 'round';
            spawnDrawingCtx.lineJoin = 'round';
            spawnDrawingCtx.strokeStyle = currentPenColor;
            spawnDrawingCtx.lineWidth = currentPenSize;
          }
          // Delay init until note is in DOM and has dimensions
          requestAnimationFrame(() => { initSpawnCanvas(); });

          // Wire up spawned menu
          const spawnColorBtn = spawnDropdown.querySelector('.spawn-color-btn');
          const spawnColorSub = spawnDropdown.querySelector('.color-submenu');
          const spawnSwatches = spawnDropdown.querySelectorAll('.color-swatch');
          const spawnColorIcon = spawnDropdown.querySelector('.color-icon');
          const spawnDrawBtn = spawnDropdown.querySelector('.spawn-draw-btn');

          spawnMenuBtn.addEventListener('mousedown', (e) => e.preventDefault());
          spawnDropdown.addEventListener('mousedown', (e) => e.preventDefault());
          spawnMenuBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            spawnMenuBtn.classList.toggle('active');
            spawnDropdown.classList.toggle('open');
          });
          document.addEventListener('click', (e) => {
            if (!spawnDropdown.contains(e.target) && !spawnMenuBtn.contains(e.target)) {
              spawnDropdown.classList.remove('open');
              spawnMenuBtn.classList.remove('active');
              spawnColorSub.classList.remove('open');
            }
          });
          spawnColorBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            spawnColorSub.classList.toggle('open');
          });
          spawnSwatches.forEach(sw => {
            sw.addEventListener('click', (e) => {
              e.stopPropagation();
              const ck = sw.dataset.color;
              const theme = colorThemes[ck];
              if (!theme) return;
              const stops = svgNode.querySelectorAll('stop');
              theme.gradient.forEach((c, i) => { if (stops[i]) stops[i].setAttribute('stop-color', c); });
              spawnColorIcon.style.background = colorIconColors[ck];
              // Update registry color
              spawnColor = ck;
              var reg = window.noteRegistry.get(spawnNoteId);
              if (reg) reg.color = ck;
              // Update animation color so lift/stick uses new color
              if (newWrapper._setNoteColor) newWrapper._setNoteColor(ck);
              // Update shadow color to match new theme
              if (theme.shadow2) {
                const [r, g, b] = theme.shadow2;
                const cr = Math.round(r * 255), cg = Math.round(g * 255), cb = Math.round(b * 255);
                shadowDiv.style.background = `linear-gradient(to bottom, rgba(${cr},${cg},${cb},0) 0%, rgba(${cr},${cg},${cb},0.18) 100%)`;
              }
              // Clear drawing when color changes
              if (spawnDrawingCtx) {
                spawnDrawingCtx.clearRect(0, 0, spawnCanvas.width, spawnCanvas.height);
              }
              spawnSwatches.forEach(s => s.classList.remove('active'));
              sw.classList.add('active');
              spawnDropdown.classList.remove('open');
              spawnMenuBtn.classList.remove('active');
              spawnColorSub.classList.remove('open');
            });
          });

          // Wire up Draw button for spawned note
          spawnDrawBtn.addEventListener('click', () => {
            spawnDropdown.classList.remove('open');
            spawnMenuBtn.classList.remove('active');
            setActiveNote(spawnNoteId);

            // Close any other note's drawing mode
            if (activeDrawingNote && activeDrawingNote !== newWrapper) {
              closeActiveDrawingMode();
            }

            // Init canvas if needed
            if (!spawnDrawingCtx) initSpawnCanvas();

            // Save state for cancel
            const savedData = spawnDrawingCtx.getImageData(0, 0, spawnCanvas.width, spawnCanvas.height);

            // Set as active drawing note
            activeDrawingNote = newWrapper;
            activeDrawingCanvas = spawnCanvas;
            activeDrawingCtx = spawnDrawingCtx;
            activeSavedImageData = savedData;

            // Lift note flat
            newWrapper.dispatchEvent(new Event('note:lift'));
            ta.blur();
            newWrapper.classList.add('flat');

            // Enable drawing mode
            isDrawingMode = true;
            document.body.classList.add('drawing-mode-active');
            newWrapper.classList.add('drawing-mode');

            // Apply clip-path to spawned canvas
            syncDrawingClip(statePoints.flat, spawnCanvas);

            // Show toolbar positioned near this note
            positionToolbar(newWrapper);
            const toolbar = document.getElementById('drawing-toolbar');
            if (toolbar) toolbar.classList.add('visible');
            const focusOverlay = document.querySelector('.focus-overlay');
            if (focusOverlay) focusOverlay.classList.add('active');

            // Hide placeholder text if textarea is empty
            if (ta && !ta.value.trim()) {
              ta.classList.add('hide-for-drawing');
            }

            // Sync toolbar pen settings to this canvas
            spawnDrawingCtx.strokeStyle = currentPenColor;
            spawnDrawingCtx.lineWidth = currentPenSize;
          });

          // Add shadow layer with theme-matched color
          const shadowDiv = document.createElement('div');
          shadowDiv.className = 'note-shadow';
          const spawnTheme = colorThemes[color];
          if (spawnTheme && spawnTheme.shadow2) {
            const [r, g, b] = spawnTheme.shadow2;
            const cr = Math.round(r * 255), cg = Math.round(g * 255), cb = Math.round(b * 255);
            shadowDiv.style.background = `linear-gradient(to bottom, rgba(${cr},${cg},${cb},0) 0%, rgba(${cr},${cg},${cb},0.18) 100%)`;
          }
          newWrapper.appendChild(shadowDiv);
          newWrapper.appendChild(svgNode);
          newWrapper.appendChild(noteDiv);

          // Assign note ID
          const spawnNoteId = 'note-' + noteCounter;
          newWrapper.dataset.noteId = spawnNoteId;

          // Track color in closure for registry updates
          let spawnColor = color;

          // Register in noteRegistry
          window.noteRegistry.set(spawnNoteId, {
            wrapper: newWrapper,
            color: spawnColor,
            getText: function() { return ta.value; },
            getDrawing: function() { return spawnCanvas.toDataURL('image/png'); },
            getDrawingCanvas: function() { return spawnCanvas; }
          });

          // Track active note on spawned textarea focus/blur
          ta.addEventListener('focus', function() { setActiveNote(spawnNoteId); });
          ta.addEventListener('blur', function() { deactivateNote(); });

          wrapper.parentElement.insertBefore(newWrapper, addBtn);
          // Set random placeholder
          if (ta) ta.placeholder = placeholders[Math.floor(Math.random() * placeholders.length)];
          makeDraggable(newWrapper);
          // Get stops from the properly-namespaced SVG
          const noteStops = svgNode.querySelectorAll('stop');
          initNoteAnimations(newWrapper, color, noteCounter, noteStops);

          // Peel-in animation for spawned note (faster than intro)
          if (!window._restoringNotes) {
            const spawnShape = svgNode.querySelector('path');
            const tightCurl = [
              [34.6016, 19.2695], [250.102, 18.5996], [250.102, 18.5996],
              [249.602, 49.0996], [255.0, 210.0],
              [28.6016, 231.1], [36.6029, 66.5996], [34.6016, 19.2695], [34.6016, 19.2695]
            ];
            const curled = [
              [34.6016, 19.2695], [250.102, 18.5996], [250.102, 18.5996],
              [249.602, 49.0996], [257.602, 228.6],
              [28.6016, 231.1], [36.6029, 66.5996], [34.6016, 19.2695], [34.6016, 19.2695]
            ];
            function spawnPtsToPath(pts) {
              return `M${pts[0][0]} ${pts[0][1]} L${pts[1][0]} ${pts[1][1]} C${pts[2][0]} ${pts[2][1]} ${pts[3][0]} ${pts[3][1]} ${pts[4][0]} ${pts[4][1]} L${pts[5][0]} ${pts[5][1]} C${pts[6][0]} ${pts[6][1]} ${pts[7][0]} ${pts[7][1]} ${pts[8][0]} ${pts[8][1]} Z`;
            }
            // Start tight
            spawnShape.setAttribute('d', spawnPtsToPath(tightCurl));
            newWrapper.style.opacity = '0';
            newWrapper.style.transition = 'opacity 0.3s ease';
            requestAnimationFrame(() => {
              newWrapper.style.opacity = '1';
              // Animate path from tight to curled
              const dur = 600;
              const start = performance.now();
              function peelAnim(t) {
                const elapsed = t - start;
                const p = Math.min(elapsed / dur, 1);
                const ep = 1 - Math.pow(1 - p, 3); // easeOutCubic
                const pts = tightCurl.map((pt, i) => [
                  pt[0] + (curled[i][0] - pt[0]) * ep,
                  pt[1] + (curled[i][1] - pt[1]) * ep
                ]);
                spawnShape.setAttribute('d', spawnPtsToPath(pts));
                if (p < 1) requestAnimationFrame(peelAnim);
              }
              requestAnimationFrame(peelAnim);
            });
          }

          // Hide add button until this new one is dragged
          hasMoved = false;
          addBtn.style.display = 'none';
          } catch(err) { console.error('ADD BTN ERROR:', err); }
        });
      })();

    // ==========================================
    // Peel-to-reveal intro animation (standalone â€” works on mobile + desktop)
    // ==========================================
    (function() {
      // Skip intro if we're restoring notes from a changelog round-trip
      if (sessionStorage.getItem('wm-note-state')) return;
      if (true || !sessionStorage.getItem('wm-intro-seen')) {
        const introNoteShape = document.getElementById('note-shape');
        const introWrapper = document.getElementById('note-wrapper');
        const introTightCurl = [
          [34.6016, 19.2695], [250.102, 18.5996], [250.102, 18.5996],
          [249.602, 49.0996], [255.0, 210.0],
          [28.6016, 231.1], [36.6029, 66.5996], [34.6016, 19.2695], [34.6016, 19.2695]
        ];
        const introCurled = [
          [34.6016, 19.2695], [250.102, 18.5996], [250.102, 18.5996],
          [249.602, 49.0996], [257.602, 228.6],
          [28.6016, 231.1], [36.6029, 66.5996], [34.6016, 19.2695], [34.6016, 19.2695]
        ];
        function introPointsToPath(pts) {
          return `M${pts[0][0]} ${pts[0][1]} L${pts[1][0]} ${pts[1][1]} C${pts[2][0]} ${pts[2][1]} ${pts[3][0]} ${pts[3][1]} ${pts[4][0]} ${pts[4][1]} L${pts[5][0]} ${pts[5][1]} C${pts[6][0]} ${pts[6][1]} ${pts[7][0]} ${pts[7][1]} ${pts[8][0]} ${pts[8][1]} Z`;
        }
        function introLerp(from, to, t) {
          return from.map((p, i) => [p[0] + (to[i][0] - p[0]) * t, p[1] + (to[i][1] - p[1]) * t]);
        }
        introNoteShape.setAttribute('d', introPointsToPath(introTightCurl));

        const introShadow = introWrapper.querySelector('.note-shadow');
        if (introShadow) introShadow.style.opacity = '0.3';

        setTimeout(() => {
          const introStart = performance.now();
          const introDuration = 1200;
          let introAnimId = null;
          function introPeelEase(t) {
            return t < 0.4 ? 0.15 * Math.pow(t / 0.4, 2) : 0.15 + 0.85 * Math.pow((t - 0.4) / 0.6, 0.5);
          }
          const stop0 = document.getElementById('grad-stop-0');
          const stop1 = document.getElementById('grad-stop-1');
          function parseHex(hex) { return [parseInt(hex.slice(1,3),16), parseInt(hex.slice(3,5),16), parseInt(hex.slice(5,7),16)]; }
          const lightColors = [parseHex(window._introLightStop0 || '#DFF0FA'), parseHex(window._introLightStop1 || '#D0E8F4')];
          const origColors  = [parseHex(window._introOrigStop0 || '#89C5E0'), parseHex(window._introOrigStop1 || '#98C4DA')];
          function lerpColor(from, to, t) {
            return '#' + [0,1,2].map(i => Math.round(from[i] + (to[i]-from[i])*t).toString(16).padStart(2,'0')).join('');
          }
          function introAnimate(currentTime) {
            const elapsed = currentTime - introStart;
            const progress = Math.min(elapsed / introDuration, 1);
            const ep = introPeelEase(progress);
            const pts = introLerp(introTightCurl, introCurled, ep);
            introNoteShape.setAttribute('d', introPointsToPath(pts));
            stop0.setAttribute('stop-color', lerpColor(lightColors[0], origColors[0], ep));
            stop1.setAttribute('stop-color', lerpColor(lightColors[1], origColors[1], ep));
            if (progress < 1) introAnimId = requestAnimationFrame(introAnimate);
          }
          introAnimId = requestAnimationFrame(introAnimate);

          introWrapper.style.transition = 'transform 1.2s cubic-bezier(0.4, 0, 0.2, 1)';
          introWrapper.style.transform = '';
          setTimeout(() => { introWrapper.style.transition = ''; }, 1300);

          if (introShadow) {
            introShadow.style.transition = 'opacity 0.9s ease-out';
            introShadow.style.opacity = '1';
            setTimeout(() => { introShadow.style.transition = ''; }, 1000);
          }
          sessionStorage.setItem('wm-intro-seen', '1');
        }, 200);
      }
    })();

    // Show test version on test site
    if (location.hostname.includes('clawdbrit')) {
      const tv = document.getElementById('test-version');
      if (tv) tv.textContent = ' \u00b7 test v170';
      // Make footer always visible on test site
      const footer = document.querySelector('.build-hover-area');
      if (footer) { footer.style.visibility = 'visible'; }

      // Add changelog link to footer (test â†’ test changelog)
      const footerArea = document.querySelector('.build-hover-area');
      if (footerArea) {
        const clLink = document.createElement('a');
        clLink.href = 'changelog-test.html';
        clLink.className = 'footer-link changelog-footer-link';
        clLink.setAttribute('data-i18n', 'changelog');
        clLink.textContent = 'Changelog';
        const dot = document.createTextNode(' \u00b7 ');
        footerArea.insertBefore(dot, footerArea.firstChild);
        footerArea.insertBefore(clLink, footerArea.firstChild);
      }
      // Re-apply i18n so the dynamically added link gets translated
      const savedLang = localStorage.getItem('walletmemo-lang');
      if (savedLang) applyLanguage(savedLang);
    }

    // Production changelog link (always visible)
    if (!location.hostname.includes('clawdbrit')) {
      const footerArea = document.querySelector('.build-hover-area');
      if (footerArea) {
        const clLink = document.createElement('a');
        clLink.href = 'changelog.html';
        clLink.className = 'footer-link changelog-footer-link';
        clLink.setAttribute('data-i18n', 'changelog');
        clLink.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-right:4px;position:relative;top:1.5px;"><path d="M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2"/><rect x="9" y="2" width="6" height="4" rx="1"/></svg>Changelog';
        const dot = document.createTextNode(' \u00b7 ');
        footerArea.insertBefore(dot, footerArea.firstChild);
        footerArea.insertBefore(clLink, footerArea.firstChild);
      }
      // Re-apply i18n so the dynamically added link gets translated
      const savedLang2 = localStorage.getItem('walletmemo-lang');
      if (savedLang2) applyLanguage(savedLang2);
    }

    // Save ALL notes state before navigating away
    // Debug logging (console only)
    window._debugRestore = [];
    function debugLog(msg) {
      window._debugRestore.push(msg);
      console.debug('[walletmemo]', msg);
    }

    function saveNoteState() {
      const state = [];
      window.noteRegistry.forEach((reg, id) => {
        const wrapper = reg.wrapper;
        const canvas = wrapper.querySelector('.note-drawing-layer');
        const textarea = wrapper.querySelector('.textarea');
        // Strip flat-mode transforms from saved state
        var savedTransform = wrapper.style.transform || '';
        if (wrapper.classList.contains('flat')) {
          savedTransform = savedTransform
            .replace(/scale\([^)]*\)/g, '')
            .replace(/translateY\([^)]*\)/g, '')
            .trim();
        }
        state.push({
          id: id,
          color: reg.color,
          drawing: canvas ? canvas.toDataURL('image/png') : null,
          text: textarea ? textarea.value : '',
          transform: savedTransform,
        });
      });
      // Save add-button visibility
      const _addBtn = document.querySelector('.add-note-btn');
      const saveData = { notes: state, addBtnVisible: _addBtn && _addBtn.style.display !== 'none' };
      sessionStorage.setItem('wm-note-state', JSON.stringify(saveData));
      debugLog('saved:' + state.length + 'notes,' + state.map(s => s.id + ':' + (s.text ? s.text.substring(0,10) : 'empty') + ',draw:' + (s.drawing ? s.drawing.length : 0)).join(';'));
    }

    // Restore ALL notes state on load
    (function restoreNoteState() {
      const saved = sessionStorage.getItem('wm-note-state');
      if (!saved) { debugLog('no-saved-state'); return; }
      sessionStorage.removeItem('wm-note-state');
      try {
        const raw = JSON.parse(saved);
        // Support both old array format and new object format
        const state = Array.isArray(raw) ? raw : raw.notes;
        const addBtnVisible = Array.isArray(raw) ? false : raw.addBtnVisible;
        debugLog('restore:' + state.length + ' notes');
        // Mark that we're restoring so spawned notes skip peel animation
        window._restoringNotes = true;

        // Spawn extra notes if needed (note-0 already exists)
        const extraNotes = state.filter(s => s.id !== 'note-0');
        const addBtn = document.querySelector('.add-note-btn');
        extraNotes.forEach(() => { if (addBtn) addBtn.click(); });

        // Wait for spawned notes to initialize, then restore everything
        setTimeout(() => {
          debugLog('reg:' + [...window.noteRegistry.keys()].join(','));
          state.forEach(s => {
            const reg = window.noteRegistry.get(s.id);
            if (!reg) { debugLog('MISS:' + s.id); return; }
            const wrapper = reg.wrapper;
            const canvas = wrapper.querySelector('.note-drawing-layer');
            const textarea = wrapper.querySelector('.textarea');

            // Restore color FIRST (before drawing, so gradient is correct)
            if (s.color && reg.color !== s.color) {
              const dropdown = wrapper.querySelector('.note-dropdown');
              const swatch = dropdown ? dropdown.querySelector(`[data-color="${s.color}"]`) : null;
              if (swatch) {
                wrapper.style.transition = 'none';
                swatch.click();
              }
            }

            // Restore position â€” kill all transitions/animations first
            wrapper.style.transition = 'none';
            wrapper.style.animation = 'none';
            if (s.transform) {
              // Strip flat-mode transforms (scale/translateY from focus state)
              var cleanTransform = s.transform
                .replace(/scale\([^)]*\)/g, '')
                .replace(/translateY\([^)]*\)/g, '')
                .trim();
              wrapper.style.transform = cleanTransform || '';
              debugLog(s.id + ':t="' + cleanTransform.substring(0,40) + '"');
            } else {
              debugLog(s.id + ':t=none');
            }
            wrapper.offsetHeight; // force reflow

            // Restore text
            if (textarea && s.text) textarea.value = s.text;

            // Restore drawing (slight delay to ensure canvas is sized)
            if (s.drawing && canvas) {
              setTimeout(() => {
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.onload = function() {
                  ctx.save();
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.clearRect(0, 0, canvas.width, canvas.height);
                  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                  ctx.restore();
                  // Hide placeholder if drawing exists and no typed text
                  if (textarea && !textarea.value.trim()) {
                    textarea.placeholder = '';
                  }
                };
                img.src = s.drawing;
              }, 50);
            }

            // Re-enable transitions after restore
            setTimeout(() => {
              wrapper.style.transition = '';
              wrapper.style.animation = '';
            }, 100);
          });
          // Reset note-0 to curled state (may have been flat when saved)
          const note0Wrapper = document.getElementById('note-wrapper');
          debugLog('n0flat:' + (note0Wrapper ? note0Wrapper.classList.contains('flat') : 'null'));
          // Log shadow and wrapper computed styles
          var ns = document.getElementById('note-shadow');
          if (ns) debugLog('shadow:' + ns.style.cssText.substring(0,60));
          if (note0Wrapper) debugLog('wt:' + getComputedStyle(note0Wrapper).transform.substring(0,40));
          if (note0Wrapper) {
            note0Wrapper.classList.remove('flat');
            window.isFlat = false;
            const noteShape = document.getElementById('note-shape');
            if (noteShape && window.statePoints) {
              const c = window.statePoints.curled;
              noteShape.setAttribute('d',
                'M' + c[0][0] + ' ' + c[0][1] +
                ' L' + c[1][0] + ' ' + c[1][1] +
                ' C' + c[2][0] + ' ' + c[2][1] + ' ' + c[3][0] + ' ' + c[3][1] + ' ' + c[4][0] + ' ' + c[4][1] +
                ' L' + c[5][0] + ' ' + c[5][1] +
                ' C' + c[6][0] + ' ' + c[6][1] + ' ' + c[7][0] + ' ' + c[7][1] + ' ' + c[8][0] + ' ' + c[8][1] + ' Z'
              );
            }
            // Reset gradient to non-flat colors
            if (window.noteRegistry) {
              const reg0 = window.noteRegistry.get('note-0');
              if (reg0 && window.colorThemes && window.colorThemes[reg0.color]) {
                const theme = window.colorThemes[reg0.color];
                theme.gradient.forEach((color, i) => {
                  const stop = document.getElementById('grad-stop-' + i);
                  if (stop) stop.setAttribute('stop-color', color);
                });
              }
            }
          }

          // Restore add button visibility
          if (addBtnVisible && addBtn) addBtn.style.display = 'flex';

          // Blur any accidentally focused textareas, then clear restore flag
          document.querySelectorAll('.textarea').forEach(t => t.blur());
          // After drawings load, hide placeholder on notes with significant drawing content
          setTimeout(() => {
            document.querySelectorAll('.note-drawing-layer').forEach(c => {
              const ctx = c.getContext('2d');
              const px = ctx.getImageData(0, 0, c.width, c.height).data;
              let drawPixels = 0;
              for (let i = 3; i < px.length; i += 4) { if (px[i] > 0) drawPixels++; }
              // Need at least 50 non-transparent pixels to count as a real drawing
              if (drawPixels >= 50) {
                const wrapper = c.closest('.note-wrapper, .dragged-note');
                const ta = wrapper ? wrapper.querySelector('.textarea') : null;
                if (ta && !ta.value.trim()) ta.placeholder = '';
              }
            });
            window._restoringNotes = false;
          }, 500);
        }, 200);
      } catch(e) { console.warn('Note restore failed:', e); }
    })();

    // Handle bfcache restore (mobile Safari back button)
    window.addEventListener('pageshow', (e) => {
      if (!e.persisted) { debugLog('pageshow:fresh'); return; }
      // Page was restored from bfcache â€” reset all notes to curled state
      // Remove slide-out animation class
      document.documentElement.classList.remove('page-slide-out-left');
      document.documentElement.classList.add('page-slide-in-left');

      // Reset note-0
      const nw = document.getElementById('note-wrapper');
      if (nw) {
        nw.classList.remove('flat');
        nw.style.transition = 'none';
        // Reset transform to default (strip scale/translateY from flat mode)
        const cur = nw.style.transform || '';
        nw.style.transform = cur.replace(/scale\([^)]*\)/g, '').replace(/translateY\([^)]*\)/g, '').trim();
        nw.offsetHeight;
        nw.style.transition = '';
      }

      // Reset note-0 SVG path to curled
      const noteShape = document.getElementById('note-shape');
      if (noteShape && window.statePoints) {
        const c = window.statePoints.curled;
        noteShape.setAttribute('d',
          'M' + c[0][0] + ' ' + c[0][1] +
          ' L' + c[1][0] + ' ' + c[1][1] +
          ' C' + c[2][0] + ' ' + c[2][1] + ' ' + c[3][0] + ' ' + c[3][1] + ' ' + c[4][0] + ' ' + c[4][1] +
          ' L' + c[5][0] + ' ' + c[5][1] +
          ' C' + c[6][0] + ' ' + c[6][1] + ' ' + c[7][0] + ' ' + c[7][1] + ' ' + c[8][0] + ' ' + c[8][1] + ' Z'
        );
      }

      // Reset gradient to curled (non-flat) colors
      if (window.noteRegistry && window.colorThemes) {
        const reg0 = window.noteRegistry.get('note-0');
        if (reg0 && window.colorThemes[reg0.color]) {
          window.colorThemes[reg0.color].gradient.forEach((color, i) => {
            const stop = document.getElementById('grad-stop-' + i);
            if (stop) stop.setAttribute('stop-color', color);
          });
        }
      }

      // Dismiss focus overlay & blur textareas
      const overlay = document.getElementById('focus-overlay');
      if (overlay) overlay.classList.remove('active');
      document.querySelectorAll('.textarea').forEach(t => t.blur());

      // Reset spawned notes too
      document.querySelectorAll('.dragged-note').forEach(dn => {
        dn.classList.remove('flat');
        const cur2 = dn.style.transform || '';
        dn.style.transform = cur2.replace(/scale\([^)]*\)/g, '').replace(/translateY\([^)]*\)/g, '').trim();
      });

    });

    // Page transition: slide out left when clicking changelog
    document.addEventListener('click', (e) => {
      const link = e.target.closest('.changelog-footer-link');
      if (!link) return;
      e.preventDefault();
      const href = link.href;
      saveNoteState();
      sessionStorage.setItem('page-transition', 'forward');
      document.documentElement.classList.remove('page-slide-in-left');
      document.documentElement.classList.add('page-slide-out-left');
      setTimeout(() => { window.location.href = href; }, 300);
    });
    </script>
    </div><!-- /page-content -->
  </body>
</html>
