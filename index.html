<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Wallet Memo</title>
    <meta name="description" content="A sticky note for your Apple Wallet. Write a memo, save it to your wallet, and never forget.">
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Wallet Memo">
    <meta property="og:description" content="A sticky note for your Apple Wallet.">
    <meta property="og:image" content="https://clawdbrit.github.io/playground/assets/og/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:url" content="https://clawdbrit.github.io/playground/">
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Wallet Memo">
    <meta name="twitter:description" content="A sticky note for your Apple Wallet.">
    <meta name="twitter:image" content="https://clawdbrit.github.io/playground/assets/og/og-image.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&family=Inter:wght@300&family=Fraunces:wght@300&family=Cormorant+Garamond:wght@300&family=Noto+Serif+JP:wght@900&family=Noto+Serif+KR:wght@900&family=Noto+Serif+SC:wght@900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.hugeicons.com/font/hgi-stroke-rounded.css">
    <script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>
    <link rel="stylesheet" href="lang-picker.css?v=2">
    <link rel="stylesheet" href="./style.css?v=16" />
    <!-- Hreflang alternate links for SEO -->
    <link rel="alternate" hreflang="en" href="https://walletmemo.com/" />
    <link rel="alternate" hreflang="es" href="https://walletmemo.com/?lang=es" />
    <link rel="alternate" hreflang="fr" href="https://walletmemo.com/?lang=fr" />
    <link rel="alternate" hreflang="de" href="https://walletmemo.com/?lang=de" />
    <link rel="alternate" hreflang="ja" href="https://walletmemo.com/?lang=ja" />
    <link rel="alternate" hreflang="zh" href="https://walletmemo.com/?lang=zh" />
    <link rel="alternate" hreflang="ko" href="https://walletmemo.com/?lang=ko" />
    <link rel="alternate" hreflang="pt" href="https://walletmemo.com/?lang=pt" />
    <link rel="alternate" hreflang="x-default" href="https://walletmemo.com/" />
          <!-- GoatCounter analytics -->
    <script data-goatcounter="https://walletmemo.goatcounter.com/count"
            async src="//gc.zgo.at/count.js"></script>
  </head>
  <body>
    <style>
      html { background: linear-gradient(to bottom, #fafafa, #e5e5e5); background-attachment: fixed; min-height: 100vh; scrollbar-gutter: stable; }
      html, body { overflow-x: hidden; }
      html::-webkit-scrollbar { width: 8px; }
      html::-webkit-scrollbar-track { background: transparent; }
      html::-webkit-scrollbar-thumb { background: rgba(0,0,0,.15); border-radius: 4px; }
      html::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,.3); }
      @supports (scrollbar-width: thin) { html { scrollbar-width: thin; scrollbar-color: rgba(0,0,0,.15) transparent; } }
      html.page-slide-out-left .page-content { animation: slideOutLeft 0.35s ease-in forwards; }
      html.page-slide-in-left .page-content { animation: slideInFromLeft 0.4s ease-out forwards; }
      @keyframes slideOutLeft {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(-100vw); opacity: 0; }
      }
      @keyframes slideInFromLeft {
        from { transform: translateX(-100vw); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
    </style>
    <script>
      // If returning from changelog, slide in from left
      if (sessionStorage.getItem('page-transition') === 'back') {
        document.documentElement.classList.add('page-slide-in-left');
        sessionStorage.removeItem('page-transition');
      }
    </script>
    <!-- Language picker (outside page-content so it doesn't slide) -->
    <div class="lang-picker" id="lang-picker">
      <button class="lang-btn" id="lang-btn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <circle cx="12" cy="12" r="10"/>
          <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
        </svg>
        <span id="current-lang">EN</span>
        <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M6 9l6 6 6-6"/>
        </svg>
      </button>
      <div class="lang-dropdown" id="lang-dropdown">
        <button class="lang-option" data-lang="en">English</button>
        <button class="lang-option" data-lang="es">Español</button>
        <button class="lang-option" data-lang="fr">Français</button>
        <button class="lang-option" data-lang="de">Deutsch</button>
        <button class="lang-option" data-lang="ja">日本語</button>
        <button class="lang-option" data-lang="zh">中文</button>
        <button class="lang-option" data-lang="ko">한국어</button>
        <button class="lang-option" data-lang="pt">Português</button>
      </div>
    </div>

    <div class="page-content">
    <div class="focus-overlay" id="focus-overlay"></div>
    <div class="content-group">
      <div class="hero-text">
        <div class="hero-title" data-i18n="heroTitle">Wallet Memo</div>
        <div class="hero-tagline" id="hero-tagline">A sticky note for your Apple Wallet</div>
      </div>

      <main class="container">
      <div class="note-wrapper" id="note-wrapper">
        <!-- Shadow layer (behind note) -->
        <div class="note-shadow" id="note-shadow"></div>
        <!-- Sticky note SVG - inlined for dynamic color updates -->
        <svg class="note-paper" id="note-paper" data-state="one" width="287" height="270" viewBox="0 0 287 270" fill="none" xmlns="http://www.w3.org/2000/svg">
          <g filter="url(#noteFilter)">
            <path id="note-shape" d="M34.6016 19.2695L250.102 18.5996C250.102 18.5996 249.602 49.0996 257.602 228.6L28.6016 231.1C36.6029 66.5996 34.6016 19.2695 34.6016 19.2695Z" fill="url(#noteGradient)"/>
          </g>
          <!-- Bottom edge darkening handled by gradient stop-0 -->
          <defs>
            <filter id="noteFilter" x="0.00156212" y="-0.000391006" width="286.2" height="269.7" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
              <feFlood flood-opacity="0" result="BackgroundImageFix"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset/>
              <feGaussianBlur stdDeviation="5.14583"/>
              <feColorMatrix id="shadowColor1" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"/>
              <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset dy="10"/>
              <feGaussianBlur stdDeviation="14.3"/>
              <feColorMatrix id="shadowColor2" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"/>
              <feBlend mode="normal" in2="effect1_dropShadow" result="effect2_dropShadow"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset dy="0.2"/>
              <feComposite in2="hardAlpha" operator="out"/>
              <feColorMatrix id="shadowColor3" type="matrix" values="0 0 0 0 0.425615 0 0 0 0 0.695906 0 0 0 0 0.842314 0 0 0 1 0"/>
              <feBlend mode="normal" in2="effect2_dropShadow" result="effect3_dropShadow"/>
              <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
              <feTurbulence type="fractalNoise" baseFrequency="1.6666666269302368 1.6666666269302368" stitchTiles="stitch" numOctaves="3" result="noise" seed="6167"/>
              <feComponentTransfer in="noise" result="coloredNoise1">
                <feFuncR type="linear" slope="2" intercept="-0.5"/>
                <feFuncG type="linear" slope="2" intercept="-0.5"/>
                <feFuncB type="linear" slope="2" intercept="-0.5"/>
                <feFuncA type="discrete" tableValues="1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"/>
              </feComponentTransfer>
              <feComposite operator="in" in2="shape" in="coloredNoise1" result="noise1Clipped"/>
              <feComponentTransfer in="noise1Clipped" result="color1">
                <feFuncA type="table" tableValues="0 0.06"/>
              </feComponentTransfer>
              <feMerge result="effect4_noise">
                <feMergeNode in="shape"/>
                <feMergeNode in="color1"/>
              </feMerge>
              <feBlend mode="normal" in="effect4_noise" in2="effect3_dropShadow" result="effect4_noise"/>
            </filter>
            <linearGradient id="noteGradient" x1="153.102" y1="231.1" x2="143.601" y2="18.5996" gradientUnits="userSpaceOnUse">
              <stop id="grad-stop-0" stop-color="#89C5E0"/>
              <stop id="grad-stop-1" offset="0.255906" stop-color="#98C4DA"/>
              <stop id="grad-stop-2" offset="0.812358" stop-color="#9BC8E7"/>
              <stop id="grad-stop-3" offset="0.864881" stop-color="#ACD7E9"/>
              <stop id="grad-stop-4" offset="0.954264" stop-color="#B8E3F3"/>
              <stop id="grad-stop-5" offset="1" stop-color="#C4E9F5"/>
            </linearGradient>
          </defs>
        </svg>
        <script>
          // Peel-to-reveal: immediately set tight curl + visual state before first paint
          if (true || !sessionStorage.getItem('wm-intro-seen')) {
            console.log('[intro] Setting tight curl');
            document.getElementById('note-shape').setAttribute('d',
              'M34.6016 19.2695 L250.102 18.5996 C250.102 18.5996 249.602 49.0996 255 210 L28.6016 231.1 C36.6029 66.5996 34.6016 19.2695 34.6016 19.2695 Z'
            );
            // Mark that intro needs gradient lightening (applied after color theme loads)
            window._introNeedsGradient = true;
            var nw = document.getElementById('note-wrapper');
            nw.style.transition = 'none';
          }
        </script>
        <div class="note" id="sticky-note">
          <!-- Ellipsis menu button -->
          <button class="note-menu-btn" id="menu-btn">
            <svg viewBox="0 0 24 24">
              <circle cx="12" cy="5" r="2"/>
              <circle cx="12" cy="12" r="2"/>
              <circle cx="12" cy="19" r="2"/>
            </svg>
          </button>

          <!-- Dropdown menu -->
          <div class="note-dropdown" id="note-dropdown">
            <button class="dropdown-item" id="change-color-btn">
              <span class="color-icon" id="color-icon"></span>
              <span data-i18n="changeColor">Change Color</span>
            </button>
            <div class="color-submenu" id="color-submenu">
              <div class="color-swatch" data-color="blue" style="background: #B4DCE8;"></div>
              <div class="color-swatch" data-color="yellow" style="background: #EAD264;"></div>
              <div class="color-swatch" data-color="pink" style="background: #ECBDC5;"></div>
            </div>
            <button class="dropdown-item" id="add-stamp-btn" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="11" width="18" height="10" rx="2"/>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
              </svg>
              <span data-i18n="addStamp">Add Stamp</span> <span class="coming-soon-tag" data-i18n="comingSoon">Coming soon</span>
            </button>
            <button class="dropdown-item" id="add-sticker-btn" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                <line x1="9" y1="9" x2="9.01" y2="9"/>
                <line x1="15" y1="9" x2="15.01" y2="9"/>
              </svg>
              <span data-i18n="stickers">Stickers</span> <span class="coming-soon-tag" data-i18n="comingSoon">Coming soon</span>
            </button>
            <button class="dropdown-item" id="draw-btn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                <path d="M2 2l7.586 7.586"/>
              </svg>
              <span data-i18n="drawOnNote">Draw on Note</span>
            </button>
          </div>

          <!-- Drawing layer for finished drawings -->
          <canvas class="note-drawing-layer" id="note-drawing-layer"></canvas>

          <textarea
            id="memo"
            class="textarea"
            placeholder=""
            maxlength="140"
          ></textarea>
        </div>
        <!-- Drawing toolbar -->
      </div>

      <!-- Drawing toolbar: shared across all notes, positioned via JS -->
      <div class="drawing-toolbar" id="drawing-toolbar">
        <button class="toolbar-btn cancel" id="cancel-drawing"><i class="hgi-stroke hgi-cancel-01"></i></button>
        <div class="toolbar-divider"></div>
        <button class="toolbar-btn clear" id="clear-drawing"><i class="hgi-stroke hgi-delete-02"></i></button>
        <div class="toolbar-divider"></div>
        <div class="pen-color-picker">
          <button class="pen-color-current" id="pen-color-current" style="background:#1a1a1a"></button>
          <div class="pen-color-popup" id="pen-color-popup">
            <button class="pen-color active" data-color="26,26,26" style="background:#1a1a1a"></button>
            <button class="pen-color" data-color="229,57,53" style="background:#e53935"></button>
            <button class="pen-color" data-color="30,136,229" style="background:#1e88e5"></button>
            <button class="pen-color" data-color="67,160,71" style="background:#43a047"></button>
            <button class="pen-color" data-color="142,36,170" style="background:#8e24aa"></button>
          </div>
        </div>
        <div class="toolbar-divider"></div>
        <button class="toolbar-btn done" id="done-drawing"><i class="hgi-stroke hgi-tick-02"></i></button>
      </div>

      <div class="wallet-wrapper">
        <div class="wallet-buttons">
          <a href="#" class="wallet-btn-link" id="apple-wallet-btn">
            <img id="apple-wallet-img" src="./assets/wallet-buttons/apple-wallet-buttons/Locale=EN.svg" alt="Add to Apple Wallet">
            <div class="wallet-qr" id="wallet-qr"></div>
          </a>
          <a href="#" class="wallet-btn-link" id="google-wallet-btn" style="display: none;">
            <img id="google-wallet-img" src="./assets/wallet-buttons/google-wallet-buttons/Locale=EN, Type=Primary.svg" alt="Add to Google Wallet">
          </a>
        </div>
        <div class="wallet-message" id="wallet-message" data-i18n="comingSoonExcl">Coming soon!</div>
        <div class="build-hover-area"><a href="mailto:ram@agentmail.to" class="footer-link"><svg class="mail-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-right:4px;position:relative;top:1.5px;"><rect x="2" y="4" width="20" height="16" rx="3"/><path d="M2 7l10 7 10-7"/></svg><span data-i18n="emailUs">Email Us</span></a> · <span class="copyright">© 2026 Wallet Memo</span><span class="test-version" id="test-version"></span><!-- Build 196 --></div>
      </div>
    </main>
    
<!-- build number moved to end of body -->
    </div>

    <script>
      // Prevent pinch-to-zoom on iOS Safari
      document.addEventListener('gesturestart', function(e) { e.preventDefault(); });
      document.addEventListener('gesturechange', function(e) { e.preventDefault(); });
      document.addEventListener('gestureend', function(e) { e.preventDefault(); });


      // ==========================================
      // Note Registry & Active Note Tracking
      // ==========================================
      window.noteRegistry = new Map();
      window.activeNoteId = null;
      window.lastActiveNoteId = null;

      window.setActiveNote = function(noteId) {
        window.activeNoteId = noteId;
      };
      window.deactivateNote = function() {
        if (window.activeNoteId) {
          window.lastActiveNoteId = window.activeNoteId;
          window.activeNoteId = null;
        }
      };
      window.getTargetNote = function() {
        var id = window.activeNoteId || window.lastActiveNoteId;
        if (id && window.noteRegistry.has(id)) return window.noteRegistry.get(id);
        // fallback to note-0
        if (window.noteRegistry.has('note-0')) return window.noteRegistry.get('note-0');
        return null;
      };

      // ==========================================
      // i18n Translations
      // ==========================================
      const i18n = {
        en: {
          heroTitle: "Wallet Memo",
          heroTagline: "A sticky note for your Apple Wallet",
          changeColor: "Change Color",
          addStamp: "Add Stamp",
          comingSoon: "Coming soon",
          stickers: "Stickers",
          drawOnNote: "Draw on Note",
          emailUs: "Email Us",
          changelog: "Changelog",
          comingSoonExcl: "Coming soon!",
          placeholders: [
            "Buy oat milk\nText mom\nDon't forget…",
            "Pick up groceries\nCall dentist\nStretch!",
            "Idea: build an app\nResearch competitors\nSketch wireframes",
            "Monday meeting\nBring snacks\nAsk about timeline",
            "Gift ideas:\nNew headphones?\nBook about space",
            "Workout plan\nRun 2 miles\nDrink more water",
            "Movie night picks:\nInterstellar\nEverything Everywhere",
            "Pack for trip\nCharger\nPassport\nSnacks",
            "Learn something new\nWatch a tutorial\nTake notes",
            "Groceries:\nAvocados\nSourdough\nCoffee beans",
            "Weekend plans\nFarmers market\nCook dinner\nRead",
            "Buy it.\nUse it.\nBreak it.\nFix it.",
            "It doesn't have to\nbe done. It just has\nto be perfect.",
            "Drink water.",
            "Send the email.",
            "Stretch for\n30 seconds.\nCount it.",
            "Call dentist.",
            "Don't turn\nOff.",
          ]
        },
        es: {
          heroTitle: "Nota de Cartera",
          heroTagline: "Una nota adhesiva para tu Apple Wallet",
          changeColor: "Cambiar Color",
          addStamp: "Añadir Sello",
          comingSoon: "Próximamente",
          stickers: "Stickers",
          drawOnNote: "Dibujar en Nota",
          emailUs: "Escríbenos",
          changelog: "Registro de cambios",
          comingSoonExcl: "¡Próximamente!",
          placeholders: [
            "Comprar leche\nLlamar a mamá\nNo olvidar…",
            "Ir al súper\nLlamar al dentista\n¡Estirar!",
            "Idea: crear una app\nInvestigar competencia\nHacer bocetos",
            "Reunión del lunes\nLlevar snacks\nPreguntar por plazos",
            "Ideas de regalo:\n¿Audífonos nuevos?\nLibro de espacio",
            "Plan de ejercicio\nCorrer 3 km\nBeber más agua",
            "Noche de pelis:\nInterestelar\nEverything Everywhere",
            "Hacer maleta\nCargador\nPasaporte\nSnacks",
            "Aprender algo nuevo\nVer un tutorial\nTomar notas",
            "Compras:\nAguacates\nPan\nCafé",
            "Planes del finde\nMercado\nCocinar\nLeer",
            "Cómpralo.\nÚsalo.\nRómpelo.\nArréglalo.",
            "No tiene que estar\nterminado. Solo tiene\nque ser perfecto.",
            "Bebe agua.",
            "Envía el correo.",
            "Estira por\n30 segundos.\nCuéntalos.",
            "Llama al dentista.",
            "No te\napagues.",
          ]
        },
        fr: {
          heroTitle: "Mémo Portefeuille",
          heroTagline: "Un pense-bête pour votre Apple Wallet",
          changeColor: "Changer la Couleur",
          addStamp: "Ajouter un Tampon",
          comingSoon: "Bientôt",
          stickers: "Autocollants",
          drawOnNote: "Dessiner sur la Note",
          emailUs: "Nous Écrire",
          changelog: "Journal des modifications",
          comingSoonExcl: "Bientôt disponible !",
          placeholders: [
            "Acheter du lait\nAppeler maman\nNe pas oublier…",
            "Courses à faire\nAppeler le dentiste\nÉtirements !",
            "Idée : créer une app\nÉtudier la concurrence\nFaire des croquis",
            "Réunion lundi\nApporter des gâteaux\nDemander le planning",
            "Idées cadeaux :\nNouveaux écouteurs ?\nLivre sur l'espace",
            "Programme sport\nCourir 3 km\nBoire plus d'eau",
            "Soirée ciné :\nInterstellar\nEverything Everywhere",
            "Préparer la valise\nChargeur\nPasseport\nSnacks",
            "Apprendre quelque chose\nRegarder un tuto\nPrendre des notes",
            "Courses :\nAvocats\nPain\nGrains de café",
            "Plans du week-end\nMarché\nCuisiner\nLire",
            "Achète-le.\nUtilise-le.\nCasse-le.\nRépare-le.",
            "Ça n'a pas besoin\nd'être fini. Juste\nparfait.",
            "Bois de l'eau.",
            "Envoie le mail.",
            "Étire-toi\n30 secondes.\nCompte-les.",
            "Appelle le dentiste.",
            "Ne t'éteins\npas.",
          ]
        },
        de: {
          heroTitle: "Wallet-Notiz",
          heroTagline: "Ein Klebezettel für dein Apple Wallet",
          changeColor: "Farbe Ändern",
          addStamp: "Stempel Hinzufügen",
          comingSoon: "Demnächst",
          stickers: "Sticker",
          drawOnNote: "Auf Notiz Zeichnen",
          emailUs: "Schreib Uns",
          changelog: "Änderungsprotokoll",
          comingSoonExcl: "Demnächst verfügbar!",
          placeholders: [
            "Milch kaufen\nMama anrufen\nNicht vergessen…",
            "Einkaufen gehen\nZahnarzt anrufen\nDehnen!",
            "Idee: App bauen\nWettbewerb analysieren\nSkizzen machen",
            "Meeting am Montag\nSnacks mitbringen\nNach Zeitplan fragen",
            "Geschenkideen:\nNeue Kopfhörer?\nBuch über Weltraum",
            "Trainingsplan\n3 km laufen\nMehr Wasser trinken",
            "Filmabend:\nInterstellar\nEverything Everywhere",
            "Koffer packen\nLadegerät\nReisepass\nSnacks",
            "Etwas Neues lernen\nTutorial schauen\nNotizen machen",
            "Einkaufsliste:\nAvocados\nBrot\nKaffeebohnen",
            "Wochenendpläne\nMarkt\nKochen\nLesen",
            "Kauf es.\nNutz es.\nBrich es.\nFix es.",
            "Es muss nicht\nfertig sein. Nur\nperfekt.",
            "Trink Wasser.",
            "Schick die E-Mail.",
            "Dehne dich\n30 Sekunden.\nZähle mit.",
            "Ruf den Zahnarzt an.",
            "Schalte nicht\nab.",
          ]
        },
        ja: {
          heroTitle: "ウォレットメモ",
          heroTagline: "Apple Walletの付箋メモ",
          changeColor: "色を変更",
          addStamp: "スタンプを追加",
          comingSoon: "近日公開",
          stickers: "ステッカー",
          drawOnNote: "メモに描く",
          emailUs: "メールする",
          changelog: "変更履歴",
          comingSoonExcl: "近日公開！",
          placeholders: [
            "牛乳を買う\nお母さんに電話\n忘れないで…",
            "買い物に行く\n歯医者に電話\nストレッチ！",
            "アイデア：アプリを作る\n競合を調査\nワイヤーフレームを描く",
            "月曜の会議\nお菓子を持参\nスケジュールを確認",
            "プレゼントのアイデア：\n新しいヘッドホン？\n宇宙の本",
            "運動計画\n3km走る\nもっと水を飲む",
            "映画ナイト：\nインターステラー\nエブエブ",
            "旅行の準備\n充電器\nパスポート\nお菓子",
            "新しいことを学ぶ\nチュートリアルを見る\nメモを取る",
            "買い物リスト：\nアボカド\nパン\nコーヒー豆",
            "週末の予定\n市場\n料理する\n読書",
            "買う。\n使う。\n壊す。\n直す。",
            "完成しなくていい。\nただ完璧で\nあればいい。",
            "水を飲む。",
            "メールを送る。",
            "30秒\nストレッチ。\n数えて。",
            "歯医者に電話。",
            "消えないで。",
          ]
        },
        zh: {
          heroTitle: "钱包备忘录",
          heroTagline: "Apple Wallet 的便利贴",
          changeColor: "更换颜色",
          addStamp: "添加印章",
          comingSoon: "即将推出",
          stickers: "贴纸",
          drawOnNote: "在便签上画画",
          emailUs: "发邮件给我们",
          changelog: "更新日志",
          comingSoonExcl: "即将推出！",
          placeholders: [
            "买牛奶\n给妈妈打电话\n别忘了…",
            "去超市\n预约牙医\n做拉伸！",
            "想法：做个App\n研究竞品\n画线框图",
            "周一开会\n带零食\n问进度",
            "礼物清单：\n新耳机？\n太空书籍",
            "健身计划\n跑步3公里\n多喝水",
            "电影之夜：\n星际穿越\n瞬息全宇宙",
            "收拾行李\n充电器\n护照\n零食",
            "学点新东西\n看教程\n做笔记",
            "购物清单：\n牛油果\n面包\n咖啡豆",
            "周末计划\n逛市场\n做饭\n看书",
            "买。\n用。\n坏。\n修。",
            "不需要完成。\n只需要\n完美。",
            "喝水。",
            "发邮件。",
            "拉伸\n30秒。\n数一数。",
            "打电话给牙医。",
            "别关机。",
          ]
        },
        ko: {
          heroTitle: "지갑 메모",
          heroTagline: "Apple Wallet을 위한 메모 스티커",
          changeColor: "색상 변경",
          addStamp: "스탬프 추가",
          comingSoon: "곧 출시",
          stickers: "스티커",
          drawOnNote: "메모에 그리기",
          emailUs: "이메일 보내기",
          changelog: "변경 이력",
          comingSoonExcl: "곧 출시됩니다!",
          placeholders: [
            "우유 사기\n엄마한테 전화\n잊지 말기…",
            "장보기\n치과 예약\n스트레칭!",
            "아이디어: 앱 만들기\n경쟁사 조사\n와이어프레임 그리기",
            "월요일 회의\n간식 가져가기\n일정 확인",
            "선물 아이디어:\n새 헤드폰?\n우주 관련 책",
            "운동 계획\n3km 달리기\n물 더 마시기",
            "영화 밤:\n인터스텔라\n에브리씽 에브리웨어",
            "여행 짐 싸기\n충전기\n여권\n간식",
            "새로운 것 배우기\n튜토리얼 보기\n메모하기",
            "장보기:\n아보카도\n빵\n커피 원두",
            "주말 계획\n시장 가기\n요리하기\n독서",
            "사라.\n써라.\n부숴라.\n고쳐라.",
            "완성할 필요 없어.\n그냥 완벽하면\n돼.",
            "물 마시기.",
            "이메일 보내기.",
            "30초\n스트레칭.\n세어봐.",
            "치과에 전화.",
            "꺼지지 마.",
          ]
        },
        pt: {
          heroTitle: "Memo Carteira",
          heroTagline: "Um lembrete para o seu Apple Wallet",
          changeColor: "Mudar Cor",
          addStamp: "Adicionar Carimbo",
          comingSoon: "Em breve",
          stickers: "Adesivos",
          drawOnNote: "Desenhar na Nota",
          emailUs: "Envie um Email",
          changelog: "Registro de alterações",
          comingSoonExcl: "Em breve!",
          placeholders: [
            "Comprar leite\nLigar pra mãe\nNão esquecer…",
            "Ir ao mercado\nLigar pro dentista\nAlongar!",
            "Ideia: criar um app\nPesquisar concorrência\nFazer esboços",
            "Reunião segunda\nLevar lanches\nPerguntar sobre prazos",
            "Ideias de presente:\nFones novos?\nLivro sobre espaço",
            "Plano de treino\nCorrer 3 km\nBeber mais água",
            "Noite de filme:\nInterestelar\nEverything Everywhere",
            "Fazer mala\nCarregador\nPassaporte\nLanches",
            "Aprender algo novo\nVer tutorial\nFazer anotações",
            "Compras:\nAbacates\nPão\nGrãos de café",
            "Planos de fim de semana\nFeira\nCozinhar\nLer",
            "Compre.\nUse.\nQuebre.\nConserte.",
            "Não precisa estar\npronto. Só precisa\nser perfeito.",
            "Beba água.",
            "Envie o email.",
            "Alongue por\n30 segundos.\nConte.",
            "Ligue pro dentista.",
            "Não se\napague.",
          ]
        }
      };

      // Apply language to all translatable elements
      function applyLanguage(lang) {
        const t = i18n[lang] || i18n.en;
        // Set document lang attribute
        document.documentElement.lang = lang;
        // Page title
        if (t.heroTitle) document.title = t.heroTitle;
        // Hero tagline
        const tagline = document.getElementById('hero-tagline');
        if (tagline) tagline.textContent = t.heroTagline;
        // All data-i18n elements
        document.querySelectorAll('[data-i18n]').forEach(el => {
          const key = el.getAttribute('data-i18n');
          if (t[key]) el.textContent = t[key];
        });
        // Textarea placeholder (random from current language)
        const memo = document.getElementById('memo');
        if (memo) memo.placeholder = t.placeholders[Math.floor(Math.random() * t.placeholders.length)];
        // Store globally for new note placeholders
        window._currentI18nLang = lang;
      }

      // Randomize default note placeholder on load
      (function() {
        const ph = [
          "Buy oat milk\nText mom\nDon't forget…",
          "Pick up groceries\nCall dentist\nStretch!",
          "Idea: build an app\nResearch competitors\nSketch wireframes",
          "Monday meeting\nBring snacks\nAsk about timeline",
          "Gift ideas:\nNew headphones?\nBook about space",
          "Workout plan\nRun 2 miles\nDrink more water",
          "Movie night picks:\nInterstellar\nEverything Everywhere",
          "Pack for trip\nCharger\nPassport\nSnacks",
          "Learn something new\nWatch a tutorial\nTake notes",
          "Groceries:\nAvocados\nSourdough\nCoffee beans",
          "Weekend plans\nFarmers market\nCook dinner\nRead",
          "Buy it.\nUse it.\nBreak it.\nFix it.",
          "It doesn't have to\nbe done. It just has\nto be perfect.",
          "Drink water.",
          "Send the email.",
          "Stretch for\n30 seconds.\nCount it.",
          "Call dentist.",
          "Don't turn\nOff.",
        ];
        const memo = document.getElementById('memo');
        if (memo) memo.placeholder = ph[Math.floor(Math.random() * ph.length)];
      })();

      // Language picker and wallet buttons
      (function() {
        const appleImg = document.getElementById('apple-wallet-img');
        const googleImg = document.getElementById('google-wallet-img');
        const langPicker = document.getElementById('lang-picker');
        const langBtn = document.getElementById('lang-btn');
        const langDropdown = document.getElementById('lang-dropdown');
        const langOptions = document.querySelectorAll('.lang-option');
        const currentLangSpan = document.getElementById('current-lang');

        // Map language codes to button locale codes
        const appleLocaleMap = {
          'en': 'EN', 'es': 'ES', 'fr': 'FR', 'de': 'DE', 'ja': 'JP',
          'zh': 'CN', 'ko': 'KR', 'pt': 'PT'
        };

        const googleLocaleMap = {
          'en': 'EN', 'es': 'esES', 'fr': 'FR', 'de': 'DE', 'ja': 'JP',
          'zh': 'zhHK', 'ko': 'KO', 'pt': 'PT'
        };

        const langDisplayMap = {
          'en': 'EN', 'es': 'ES', 'fr': 'FR', 'de': 'DE',
          'ja': 'JA', 'zh': 'ZH', 'ko': 'KO', 'pt': 'PT'
        };

        // Get initial language from browser or localStorage
        let currentLang = localStorage.getItem('walletmemo-lang');
        if (!currentLang) {
          const browserLang = (navigator.language || navigator.userLanguage).split('-')[0];
          currentLang = appleLocaleMap[browserLang] ? browserLang : 'en';
        }

        function updateWalletButtons(lang) {
          const appleLocale = appleLocaleMap[lang] || 'EN';
          const googleLocale = googleLocaleMap[lang] || 'EN';

          appleImg.src = `./assets/wallet-buttons/apple-wallet-buttons/Locale=${appleLocale}.svg`;
          googleImg.src = `./assets/wallet-buttons/google-wallet-buttons/Locale=${googleLocale}, Type=Primary.svg`;

          // Update display
          currentLangSpan.textContent = langDisplayMap[lang] || 'EN';

          // Update active state
          langOptions.forEach(opt => {
            opt.classList.toggle('active', opt.dataset.lang === lang);
          });
        }

        // Fallback to English if locale file doesn't exist
        appleImg.onerror = () => {
          appleImg.src = './assets/wallet-buttons/apple-wallet-buttons/Locale=EN.svg';
        };
        googleImg.onerror = () => {
          googleImg.src = './assets/wallet-buttons/google-wallet-buttons/Locale=EN, Type=Primary.svg';
        };

        // Initialize
        updateWalletButtons(currentLang);
        applyLanguage(currentLang);

        // Toggle dropdown
        langBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          langPicker.classList.toggle('open');
        });

        // Close on outside click
        document.addEventListener('click', () => {
          langPicker.classList.remove('open');
        });

        // Language selection
        langOptions.forEach(opt => {
          opt.addEventListener('click', (e) => {
            e.stopPropagation();
            const lang = opt.dataset.lang;
            currentLang = lang;
            localStorage.setItem('walletmemo-lang', lang);
            updateWalletButtons(lang);
            applyLanguage(lang);
            langPicker.classList.remove('open');
          });
        });

        // Google Wallet - coming soon
        const walletMessage = document.getElementById('wallet-message');
        document.getElementById('google-wallet-btn').addEventListener('click', (e) => {
          e.preventDefault();
          walletMessage.classList.add('visible');
        });
      })();

      // ==========================================
      // Sticky Note Menu & Drawing System
      // ==========================================
      (function() {
        // Elements
        const stickyNote = document.getElementById('sticky-note');
        const menuBtn = document.getElementById('menu-btn');
        const dropdown = document.getElementById('note-dropdown');
        const changeColorBtn = document.getElementById('change-color-btn');
        const colorSubmenu = document.getElementById('color-submenu');
        const colorSwatches = document.querySelectorAll('.color-swatch');
        const addStampBtn = document.getElementById('add-stamp-btn');
        const drawBtn = document.getElementById('draw-btn');
        const colorIcon = document.getElementById('color-icon');
        const noteDrawingLayer = document.getElementById('note-drawing-layer');
        const drawingToolbar = document.getElementById('drawing-toolbar');
        const clearBtn = document.getElementById('clear-drawing');
        const cancelBtn = document.getElementById('cancel-drawing');
        const doneBtn = document.getElementById('done-drawing');

        // Color theme definitions (exposed for spawned notes)
        window.colorThemes = {
          blue: {
            gradient: ['#89C5E0', '#98C4DA', '#9BC8E7', '#ACD7E9', '#B8E3F3', '#C4E9F5'],
            shadow1: [0.101961, 0.55098, 1],      // Blue tint
            shadow2: [0, 0.334596, 0.608357],     // Blue tint
            shadow3: [0.425615, 0.695906, 0.842314] // Blue edge
          },
          yellow: {
            gradient: ['#C8B440', '#D4B94C', '#DEC75E', '#E8D46E', '#F0DF85', '#F7EA9C'],
            shadow1: [0.92, 0.65, 0.15],          // Orange-yellow tint
            shadow2: [0.7, 0.45, 0.1],            // Orange-yellow tint
            shadow3: [0.9, 0.7, 0.3]              // Orange-yellow edge
          },
          pink: {
            gradient: ['#CC9BA5', '#D7A0AA', '#E2B4BD', '#ECC4CC', '#F2D1D8', '#F8DEE3'],
            shadow1: [0.9, 0.55, 0.65],           // Pink tint
            shadow2: [0.6, 0.35, 0.45],           // Pink tint
            shadow3: [0.88, 0.72, 0.78]           // Pink edge
          }
        };

        // Weighted random color selection
        function getRandomColor() {
          const rand = Math.random();
          if (rand < 0.6) return 'blue';      // 60% chance
          if (rand < 0.9) return 'yellow';    // 30% chance
          return 'pink';                       // 10% chance
        }

        let currentColor = getRandomColor();

        // Color icon colors (mid-tone for each theme)
        window.colorIconColors = {
          blue: '#B4DCE8',
          yellow: '#E2D060',
          pink: '#E4B8C0'
        };

        // Update note colors dynamically
        function updateNoteColors(colorKey) {
          const theme = colorThemes[colorKey];
          if (!theme) return;

          // Update color icon
          if (colorIcon) {
            colorIcon.style.background = colorIconColors[colorKey];
          }

          // Update gradient stops
          theme.gradient.forEach((color, i) => {
            const stop = document.getElementById(`grad-stop-${i}`);
            if (stop) stop.setAttribute('stop-color', color);
          });

          // Update shadow colors
          const shadow1 = document.getElementById('shadowColor1');
          const shadow2 = document.getElementById('shadowColor2');
          const shadow3 = document.getElementById('shadowColor3');

          if (shadow1) {
            // SVG drop shadows disabled — using CSS .note-shadow rectangle instead
            shadow1.setAttribute('values', `0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0`);
          }
          if (shadow2) {
            shadow2.setAttribute('values', `0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0`);
          }

          // Update CSS shadow rectangle color to match theme
          const shadowEl = document.getElementById('note-shadow');
          if (shadowEl && theme.shadow2) {
            const [r, g, b] = theme.shadow2;
            const cr = Math.round(r * 255), cg = Math.round(g * 255), cb = Math.round(b * 255);
            shadowEl.style.background = `linear-gradient(to bottom, rgba(${cr},${cg},${cb},0) 0%, rgba(${cr},${cg},${cb},0.4) 100%)`;
          }
          if (shadow3) {
            const [r, g, b] = theme.shadow3;
            shadow3.setAttribute('values', `0 0 0 0 ${r} 0 0 0 0 ${g} 0 0 0 0 ${b} 0 0 0 1 0`);
          }
        }

        // Note state toggle (click to switch between curled and flat)
        const noteWrapper = document.getElementById('note-wrapper');
        const notePaper = document.getElementById('note-paper');
        const noteShape = document.getElementById('note-shape');
        const noteShadow = document.getElementById('note-shadow');
        let isFlat = false;

        // SVG path points for the two states (matching structure for smooth morphing)
        // Structure: [M, L, C1, C2, C3, L, C1, C2, C3]
        const statePoints = {
          // Slightly tighter curl for intro — bottom-right corner lifted
          tightCurl: [
            [34.6016, 19.2695],    // M - start (same)
            [250.102, 18.5996],    // L - top right (same)
            [250.102, 18.5996],    // C1 (same)
            [249.602, 42.0],       // C2 - slightly tighter curve
            [262.0, 195.0],        // C3 - bottom right lifted up ~35px
            [28.6016, 231.1],      // L - bottom left (same)
            [36.6029, 66.5996],    // C1 (same)
            [34.6016, 19.2695],    // C2 (same)
            [34.6016, 19.2695]     // C3 (same)
          ],
          curled: [
            [34.6016, 19.2695],    // M - start
            [250.102, 18.5996],    // L - top right
            [250.102, 18.5996],    // C1 - control 1
            [249.602, 49.0996],    // C2 - control 2
            [257.602, 228.6],      // C3 - end (bottom right)
            [28.6016, 231.1],      // L - bottom left
            [36.6029, 66.5996],    // C1 - control 1
            [34.6016, 19.2695],    // C2 - control 2
            [34.6016, 19.2695]     // C3 - end (back to start)
          ],
          flat: [
            [29, 18],              // M - start
            [258, 18],             // L - top right
            [258, 18],             // C1 - control 1 (on line)
            [258, 125],            // C2 - control 2 (midpoint)
            [258, 232],            // C3 - end (bottom right)
            [29, 232],             // L - bottom left
            [29, 125],             // C1 - control 1 (midpoint)
            [29, 18],              // C2 - control 2 (on line)
            [29, 18]               // C3 - end (back to start)
          ]
        };

        // Convert points array to SVG path string
        function pointsToPath(points) {
          return `M${points[0][0]} ${points[0][1]} L${points[1][0]} ${points[1][1]} C${points[2][0]} ${points[2][1]} ${points[3][0]} ${points[3][1]} ${points[4][0]} ${points[4][1]} L${points[5][0]} ${points[5][1]} C${points[6][0]} ${points[6][1]} ${points[7][0]} ${points[7][1]} ${points[8][0]} ${points[8][1]} Z`;
        }

        // Interpolate between two point arrays
        function lerpPoints(from, to, t) {
          return from.map((point, i) => [
            point[0] + (to[i][0] - point[0]) * t,
            point[1] + (to[i][1] - point[1]) * t
          ]);
        }

        // Easing function (ease-out cubic)
        function easeOutCubic(t) {
          return 1 - Math.pow(1 - t, 3);
        }

        // Sync drawing layer clip-path to current note shape
        function syncDrawingClip(points) {
          const dl = document.getElementById('note-drawing-layer');
          if (!dl) return;
          // SVG viewBox is 287x270, map to percentages
          const vw = 287, vh = 270;
          // Points: [M, L, C1, C2, C3(bottom-right), L(bottom-left), C1, C2, C3]
          // Sample key corners for polygon
          const tl = points[0], tr = points[1], br = points[4], bl = points[5];
          // Inset by ~2px (as % of viewBox) to avoid bleeding past note edge
          const inX = 2/vw*100, inY = 2/vh*100;
          const poly = [tl, tr, br, bl].map((p, i) => {
            const px = p[0]/vw*100, py = p[1]/vh*100;
            // Nudge each corner inward
            const dx = (i === 0 || i === 3) ? inX : -inX; // left corners right, right corners left
            const dy = (i === 0 || i === 1) ? inY : -inY; // top corners down, bottom corners up
            return `${(px + dx).toFixed(1)}% ${(py + dy).toFixed(1)}%`;
          }).join(', ');
          dl.style.clipPath = `polygon(${poly})`;
        }

        // Update shadow position based on note's screen position
        // Light source is at viewport center — shadow shifts away from center
        window.updateShadowPosition = function(wrapper) {
          const shadow = wrapper.querySelector('.note-shadow');
          if (!shadow) return;
          const rect = wrapper.getBoundingClientRect();
          const cx = rect.left + rect.width / 2;
          const cy = rect.top + rect.height / 2;
          const vw = window.innerWidth / 2;
          const vh = window.innerHeight / 2;
          // -1 to 1 range, how far from center
          const dx = (cx - vw) / vw;
          const dy = (cy - vh) / vh;
          // Max shift: 20px horizontal, 14px vertical
          const shiftX = dx * 20;
          const shiftY = dy * 14;
          // Top-right = sharper + darker, bottom-left = softer + lighter
          // Combine dx and dy: top-right is dx>0, dy<0 → factor goes negative
          const cornerFactor = (dx - dy) / 2; // -1 (bottom-left) to +1 (top-right)
          const isLifted = wrapper.classList.contains('flat') || wrapper.classList.contains('drawing-mode');
          const baseBlur = isLifted ? 52 : 30;
          const blurAdjust = cornerFactor * -10; // top-right: less blur (-10), bottom-left: more (+10)
          const opacityAdjust = cornerFactor * 0.22; // top-right: darker (+0.22)
          const blur = Math.max(10, baseBlur + blurAdjust);
          shadow.style.transform = `translate(${shiftX}px, ${shiftY}px)`;
          shadow.style.filter = `blur(${blur}px)`;
          shadow.style.opacity = Math.min(1, Math.max(0.2, 1 + opacityAdjust));
        }

        // "Peel off" easing — resists at first then pops free
        function easePeelOff(t) {
          return t < 0.4
            ? 0.15 * Math.pow(t / 0.4, 2)                    // slow resist
            : 0.15 + 0.85 * Math.pow((t - 0.4) / 0.6, 0.5);  // quick release
        }

        // Animate path morphing
        let animationId = null;
        function animatePath(from, to, duration = 400) {
          if (animationId) cancelAnimationFrame(animationId);

          const startTime = performance.now();

          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutCubic(progress);

            const currentPoints = lerpPoints(from, to, easedProgress);
            noteShape.setAttribute('d', pointsToPath(currentPoints));
            // Sync drawing layer clip to note shape
            syncDrawingClip(currentPoints);

            if (progress < 1) {
              animationId = requestAnimationFrame(animate);
            }
          }

          animationId = requestAnimationFrame(animate);
        }

        // Flat gradient colors (more uniform, less dynamic)
        const flatGradients = {
          blue: ['#B3DDEE', '#B3DDEE', '#B3DDEE', '#B8E0F0', '#BDE3F2', '#C2E6F4'],
          yellow: ['#E8D66C', '#E8D66C', '#E8D66C', '#ECDA74', '#EEDC78', '#F2E082'],
          pink: ['#EACAD2', '#EACAD2', '#EACAD2', '#EDCED6', '#F0D0D8', '#F2D4DB']
        };

        // Parse hex color to RGB array
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
          ] : [0, 0, 0];
        }

        // Convert RGB array to hex
        function rgbToHex(r, g, b) {
          return '#' + [r, g, b].map(x => {
            const hex = Math.round(x).toString(16);
            return hex.length === 1 ? '0' + hex : hex;
          }).join('');
        }

        // Animate gradient transition
        let gradientAnimationId = null;
        function animateGradient(toFlat, duration = 400) {
          if (gradientAnimationId) cancelAnimationFrame(gradientAnimationId);

          const theme = colorThemes[currentColor];
          const fromColors = toFlat ? theme.gradient : flatGradients[currentColor];
          const toColors = toFlat ? flatGradients[currentColor] : theme.gradient;

          const fromRgb = fromColors.map(hexToRgb);
          const toRgb = toColors.map(hexToRgb);

          const startTime = performance.now();

          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutCubic(progress);

            fromRgb.forEach((from, i) => {
              const r = from[0] + (toRgb[i][0] - from[0]) * easedProgress;
              const g = from[1] + (toRgb[i][1] - from[1]) * easedProgress;
              const b = from[2] + (toRgb[i][2] - from[2]) * easedProgress;
              const stop = document.getElementById(`grad-stop-${i}`);
              if (stop) stop.setAttribute('stop-color', rgbToHex(r, g, b));
            });

            if (progress < 1) {
              gradientAnimationId = requestAnimationFrame(animate);
            }
          }

          gradientAnimationId = requestAnimationFrame(animate);
        }

        // Initialize lift/stick animations on any note wrapper
        window.initNoteAnimations = function(wrapper, colorKey, noteId, stopElements) {
          const shape = wrapper.querySelector('.note-paper path');
          // Use passed-in stops or query from wrapper
          const stops = stopElements || wrapper.querySelectorAll('svg stop') || [];
          let noteIsFlat = false;
          let noteAnimId = null;
          let noteGradAnimId = null;

          const theme = colorThemes[colorKey];
          const flatGrads = flatGradients[colorKey];

          function animateNotePath(from, to, duration = 400, easeFn = easeOutCubic) {
            if (noteAnimId) cancelAnimationFrame(noteAnimId);
            const startTime = performance.now();
            function anim(t) {
              const elapsed = t - startTime;
              const progress = Math.min(elapsed / duration, 1);
              const ep = easeFn(progress);
              const pts = lerpPoints(from, to, ep);
              shape.setAttribute('d', pointsToPath(pts));
              if (progress < 1) noteAnimId = requestAnimationFrame(anim);
            }
            noteAnimId = requestAnimationFrame(anim);
          }

          function animateNoteGradient(toFlat, duration = 400, easeFn = easeOutCubic) {
            if (noteGradAnimId) cancelAnimationFrame(noteGradAnimId);
            const fromColors = (toFlat ? theme.gradient : flatGrads).map(hexToRgb);
            const toColors = (toFlat ? flatGrads : theme.gradient).map(hexToRgb);
            const startTime = performance.now();
            function anim(t) {
              const elapsed = t - startTime;
              const progress = Math.min(elapsed / duration, 1);
              const ep = easeFn(progress);
              fromColors.forEach((from, i) => {
                const r = from[0] + (toColors[i][0] - from[0]) * ep;
                const g = from[1] + (toColors[i][1] - from[1]) * ep;
                const b = from[2] + (toColors[i][2] - from[2]) * ep;
                if (stops[i]) stops[i].setAttribute('stop-color', rgbToHex(r, g, b));
              });
              if (progress < 1) noteGradAnimId = requestAnimationFrame(anim);
            }
            noteGradAnimId = requestAnimationFrame(anim);
          }

          wrapper.addEventListener('note:lift', () => {
            if (!noteIsFlat) {
              noteIsFlat = true;
              wrapper.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
              animateNotePath(statePoints.curled, statePoints.flat, 400, easeOutCubic);
              animateNoteGradient(true, 400, easeOutCubic);
              wrapper.classList.add('flat');
            }
          });

          wrapper.addEventListener('note:stick', () => {
            if (noteIsFlat) {
              noteIsFlat = false;
              wrapper.style.transition = 'transform 0.18s ease-out';
              animateNotePath(statePoints.flat, statePoints.curled, 180, easeOutCubic);
              animateNoteGradient(false, 180, easeOutCubic);
              wrapper.classList.remove('flat');
              setTimeout(() => { wrapper.style.transition = ''; }, 200);
            }
          });

          // Click anywhere on note to focus textarea
          const noteTextarea = wrapper.querySelector('textarea');
          if (noteTextarea) {
            wrapper.addEventListener('click', (e) => {
              if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown')) return;
              noteTextarea.focus();
            });

            noteTextarea.addEventListener('focus', () => {
              if (!noteIsFlat) {
                noteIsFlat = true;
                wrapper.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                animateNotePath(statePoints.curled, statePoints.flat, 400, easeOutCubic);
                animateNoteGradient(true, 400, easeOutCubic);
                wrapper.classList.add('flat');
                const current = wrapper.style.transform || '';
                const base = current.replace(/scale\([^)]*\)/g, '').trim();
                wrapper.style.transform = (base ? base + ' ' : '') + 'scale(1.1)';
              }
            });

            noteTextarea.addEventListener('blur', () => {
              if (noteIsFlat) {
                noteIsFlat = false;
                wrapper.style.transition = 'transform 0.18s ease-out';
                animateNotePath(statePoints.flat, statePoints.curled, 180, easeOutCubic);
                animateNoteGradient(false, 180, easeOutCubic);
                wrapper.classList.remove('flat');
                const current = wrapper.style.transform || '';
                wrapper.style.transform = current.replace(/scale\([^)]*\)/g, '').trim();
                setTimeout(() => { wrapper.style.transition = ''; }, 200);
              }
            });
          }
        };

        // Get textarea element
        const textarea = document.getElementById('memo');

        // Tap anywhere on the note to focus textarea (fixes mobile double-tap)
        noteWrapper.addEventListener('click', (e) => {
          // Don't steal clicks from menu, dropdown, or drawing layer
          if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown') || e.target.closest('.drawing-toolbar')) return;
          textarea.focus();
        });

        // Calculate mobile scale so note fills width
        function updateMobileLayout() {
          if (window.innerWidth > 600) return; // Desktop doesn't need this
          const noteWidth = noteWrapper.offsetWidth || 320;
          const baseScale = (window.innerWidth - 16) / noteWidth;
          document.documentElement.style.setProperty('--mobile-note-scale', baseScale.toFixed(3));
          // Focused state is bigger than base
          document.documentElement.style.setProperty('--mobile-note-focus-scale', (baseScale * 1.08).toFixed(3));
        }
        updateMobileLayout();
        window.addEventListener('resize', updateMobileLayout);

        // Mobile: touchend for immediate focus without double-tap
        noteWrapper.addEventListener('touchend', (e) => {
          if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown') || e.target.closest('.drawing-toolbar')) return;
          if (noteWrapper.classList.contains('drawing-mode')) return;
          e.preventDefault();
          textarea.focus({ preventScroll: true });
        });

        // Focus/blur on textarea triggers the flat/curled animation
        const focusOverlay = document.getElementById('focus-overlay');
        const langPicker2 = document.getElementById('lang-picker');
        // Custom events for external code (e.g., drag) to trigger flat/curl
        noteWrapper.addEventListener('note:lift', () => {
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            noteWrapper.classList.add('flat');
          }
        });

        noteWrapper.addEventListener('note:stick', () => {
          if (isFlat) {
            isFlat = false;
            animatePath(statePoints.flat, statePoints.curled);
            animateGradient(false);
            noteWrapper.classList.remove('flat');
          }
        });

        textarea.addEventListener('focus', () => {
          setActiveNote('note-0');
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            // noteShadow.src removed - now CSS div
            noteWrapper.classList.add('flat');
            noteWrapper.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
            const current = noteWrapper.style.transform || '';
            const base = current.replace(/scale\([^)]*\)/g, '').replace(/translateY\([^)]*\)/g, '').trim();
            const isMobileView = window.innerWidth <= 600;
            const mobileScale = getComputedStyle(document.documentElement).getPropertyValue('--mobile-note-focus-scale') || '1.15';
            if (isMobileView) {
              noteWrapper.style.transform = (base ? base + ' ' : '') + 'scale(' + mobileScale + ') translateY(-100px)';
            } else {
              noteWrapper.style.transform = (base ? base + ' ' : '') + 'scale(1.1)';
            }
            focusOverlay.classList.add('active');
            langPicker2.classList.add('hidden');
          }
        });

        textarea.addEventListener('blur', () => {
          deactivateNote();
          // Don't close note when entering drawing mode
          if (isDrawingMode) return;
          if (isFlat) {
            isFlat = false;
            animatePath(statePoints.flat, statePoints.curled);
            animateGradient(false);
            // noteShadow.src removed - now CSS div
            noteWrapper.classList.remove('flat');
            const current = noteWrapper.style.transform || '';
            noteWrapper.style.transform = current.replace(/scale\([^)]*\)/g, '').replace(/translateY\([^)]*\)/g, '').trim();
            focusOverlay.classList.remove('active');
            langPicker2.classList.remove('hidden');
          }
        });

        // Menu toggle
        // Prevent menu/dropdown from stealing focus from textarea
        menuBtn.addEventListener('mousedown', (e) => e.preventDefault());
        dropdown.addEventListener('mousedown', (e) => e.preventDefault());
        menuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          menuBtn.classList.toggle('active');
          dropdown.classList.toggle('open');
          // Re-focus textarea so note stays in focused state
          if (isFlat) textarea.focus({ preventScroll: true });
          // Clamp dropdown to viewport
          if (dropdown.classList.contains('open')) {
            requestAnimationFrame(() => {
              const rect = dropdown.getBoundingClientRect();
              if (rect.right > window.innerWidth) {
                const overflow = rect.right - window.innerWidth + 8;
                dropdown.style.right = (8 + overflow) + 'px';
              } else {
                dropdown.style.right = '';
              }
            });
          } else {
            dropdown.style.right = '';
          }
        });

        // Close menu when clicking/tapping outside
        function closeMenuOutside(e) {
          if (!dropdown.contains(e.target) && !menuBtn.contains(e.target)) {
            dropdown.classList.remove('open');
            menuBtn.classList.remove('active');
            colorSubmenu.classList.remove('open');
          }
        }
        document.addEventListener('click', closeMenuOutside);
        document.addEventListener('touchstart', closeMenuOutside);

        // Color change functionality
        changeColorBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          colorSubmenu.classList.toggle('open');
        });

        colorSwatches.forEach(swatch => {
          swatch.addEventListener('click', (e) => {
            e.stopPropagation();
            const colorKey = swatch.dataset.color;
            currentColor = colorKey;
            updateNoteColors(colorKey);
            // Update registry
            var reg = window.noteRegistry.get('note-0');
            if (reg) reg.color = colorKey;

            // Clear drawing when color changes (drawing is tied to note color)
            if (drawingCtx) {
              drawingCtx.clearRect(0, 0, noteDrawingLayer.width, noteDrawingLayer.height);
            }

            // Update active state
            colorSwatches.forEach(s => s.classList.remove('active'));
            swatch.classList.add('active');

            // Close menu
            dropdown.classList.remove('open');
            menuBtn.classList.remove('active');
            colorSubmenu.classList.remove('open');
          });
        });

        // Add stamp (placeholder)
        addStampBtn.addEventListener('click', () => {
          alert('Stamp feature coming soon!');
          dropdown.classList.remove('open');
          menuBtn.classList.remove('active');
        });

        // ==========================================
        // Drawing Mode (draws directly on note)
        // ==========================================
        window.isDrawingMode = false;
        let drawingCtx = null;
        let isDrawing = false;
        let savedImageData = null;

        // Shared drawing state for multi-note support
        window.activeDrawingNote = null;    // which wrapper is in drawing mode
        window.activeDrawingCanvas = null;
        window.activeDrawingCtx = null;
        window.activeSavedImageData = null;

        // Initialize note drawing layer
        function initNoteDrawingLayer() {
          noteDrawingLayer.width = stickyNote.offsetWidth * 2;
          noteDrawingLayer.height = stickyNote.offsetHeight * 2;
          drawingCtx = noteDrawingLayer.getContext('2d');
          drawingCtx.scale(2, 2);
          drawingCtx.lineCap = 'round';
          drawingCtx.lineJoin = 'round';
          drawingCtx.strokeStyle = 'rgba(26, 26, 26, 0.7)';
          drawingCtx.lineWidth = 1.5;
        }
        
        // Pen settings — ballpoint pen: slightly thinner + semi-transparent
        window.currentPenColor = 'rgba(26, 26, 26, 0.7)';
        window.currentPenSize = 1.5;

        initNoteDrawingLayer();

        // Register original note as note-0
        noteWrapper.dataset.noteId = 'note-0';
        window.noteRegistry.set('note-0', {
          wrapper: noteWrapper,
          color: currentColor,
          getText: function() { return textarea.value; },
          getDrawing: function() { return noteDrawingLayer.toDataURL('image/png'); }
        });
        window.lastActiveNoteId = 'note-0';

        // Close any active drawing mode (used when switching notes)
        window.closeActiveDrawingMode = function() {
          if (activeDrawingNote) {
            if (activeSavedImageData && activeDrawingCtx) {
              activeDrawingCtx.putImageData(activeSavedImageData, 0, 0);
            }
            document.body.classList.remove('drawing-mode-active');
            activeDrawingNote.classList.remove('drawing-mode');
            activeDrawingNote.dispatchEvent(new Event('note:stick'));
            activeDrawingNote = null;
            activeDrawingCanvas = null;
            activeDrawingCtx = null;
            activeSavedImageData = null;
          }
          isDrawingMode = false;
          isDrawing = false;
          const toolbar = document.getElementById('drawing-toolbar');
          if (toolbar) toolbar.classList.remove('visible');
          const focusOverlay = document.querySelector('.focus-overlay');
          if (focusOverlay) focusOverlay.classList.remove('active');
        };

        // Open drawing mode
        drawBtn.addEventListener('click', () => {
          dropdown.classList.remove('open');
          menuBtn.classList.remove('active');
          setActiveNote('note-0');

          // Close any other note's drawing mode
          if (activeDrawingNote && activeDrawingNote !== noteWrapper) {
            closeActiveDrawingMode();
          }

          isDrawingMode = true;

          // Save current drawing state for cancel
          savedImageData = drawingCtx.getImageData(0, 0, noteDrawingLayer.width, noteDrawingLayer.height);

          // Set shared active state
          activeDrawingNote = noteWrapper;
          activeDrawingCanvas = noteDrawingLayer;
          activeDrawingCtx = drawingCtx;
          activeSavedImageData = savedImageData;

          // Put note in flat state
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            // noteShadow.src removed - now CSS div
            noteWrapper.classList.add('flat');
          }

          // Hide keyboard but keep note open
          isDrawingMode = true;
          textarea.blur();
          // Re-assert flat state since blur removes it
          isFlat = true;
          noteWrapper.classList.add('flat');
          focusOverlay.classList.add('active');
          langPicker2.classList.add('hidden');

          // Enable drawing mode
          document.body.classList.add('drawing-mode-active');
          noteWrapper.classList.add('drawing-mode');
          drawingToolbar.classList.add('visible');

          // Position toolbar just below the note
          const noteRect = noteWrapper.getBoundingClientRect();
          drawingToolbar.style.bottom = 'auto';
          drawingToolbar.style.top = (noteRect.bottom + 12) + 'px';
          drawingToolbar.style.left = (noteRect.left + noteRect.width / 2) + 'px';

          // Hide placeholder text if textarea is empty
          const memo = document.getElementById('memo');
          if (memo && !memo.value.trim()) {
            memo.classList.add('hide-for-drawing');
          }

          // Sync pen settings
          drawingCtx.strokeStyle = currentPenColor;
          drawingCtx.lineWidth = currentPenSize;
        });

        // Drawing on canvas - use event delegation via document for any active canvas
        function handleDrawPointerDown(e) {
          const canvas = e.target.closest('.note-drawing-layer');
          if (!canvas || !isDrawingMode) return;
          // Only draw on the active note's canvas
          if (activeDrawingCanvas && canvas !== activeDrawingCanvas) return;
          isDrawing = true;
          const ctx = activeDrawingCtx || drawingCtx;
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width / 2;
          const scaleY = canvas.height / rect.height / 2;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;
          ctx.beginPath();
          ctx.moveTo(x, y);
        }

        function handleDrawPointerMove(e) {
          if (!isDrawingMode || !isDrawing) return;
          const canvas = activeDrawingCanvas || noteDrawingLayer;
          const ctx = activeDrawingCtx || drawingCtx;
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width / 2;
          const scaleY = canvas.height / rect.height / 2;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;
          ctx.lineTo(x, y);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x, y);
        }

        function handleDrawPointerUp() {
          isDrawing = false;
        }

        document.addEventListener('pointerdown', handleDrawPointerDown);
        document.addEventListener('pointermove', handleDrawPointerMove);
        document.addEventListener('pointerup', handleDrawPointerUp);

        // Clear drawing
        clearBtn.addEventListener('click', () => {
          const ctx = activeDrawingCtx || drawingCtx;
          const canvas = activeDrawingCanvas || noteDrawingLayer;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        // Cancel drawing - restore previous state
        cancelBtn.addEventListener('click', () => {
          const ctx = activeDrawingCtx || drawingCtx;
          const sd = activeSavedImageData || savedImageData;
          if (sd) {
            ctx.putImageData(sd, 0, 0);
          }
          closeDrawingMode();
        });

        // Done drawing
        doneBtn.addEventListener('click', () => {
          closeDrawingMode();
        });

        function closeDrawingMode() {
          const targetWrapper = activeDrawingNote || noteWrapper;
          const isOriginalNote = (targetWrapper === noteWrapper);

          deactivateNote();
          isDrawingMode = false;
          isDrawing = false;
          savedImageData = null;
          document.body.classList.remove('drawing-mode-active');
          targetWrapper.classList.remove('drawing-mode');
          drawingToolbar.classList.remove('visible');
          const memo2 = document.getElementById('memo');
          if (memo2) memo2.classList.remove('hide-for-drawing');

          if (isOriginalNote) {
            // Original note: full close with animations
            if (isFlat) {
              isFlat = false;
              animatePath(statePoints.flat, statePoints.curled);
              animateGradient(false);
              // noteShadow.src removed - now CSS div
              noteWrapper.classList.remove('flat');
              const current = noteWrapper.style.transform || '';
              noteWrapper.style.transform = current.replace(/scale\([^)]*\)/g, '').replace(/translateY\([^)]*\)/g, '').trim();
              focusOverlay.classList.remove('active');
              langPicker2.classList.remove('hidden');
            }
            textarea.blur();
          } else {
            // Spawned note: dispatch stick event
            targetWrapper.dispatchEvent(new Event('note:stick'));
            targetWrapper.classList.remove('flat');
            const ta = targetWrapper.querySelector('textarea');
            if (ta) ta.blur();
          }

          // Clear active state
          activeDrawingNote = null;
          activeDrawingCanvas = null;
          activeDrawingCtx = null;
          activeSavedImageData = null;

          // Force Safari to re-render the SVG filter/shadow
          requestAnimationFrame(() => {
            const notePaperEl = targetWrapper.querySelector('.note-paper');
            if (notePaperEl) {
              notePaperEl.style.willChange = 'transform';
              requestAnimationFrame(() => {
                notePaperEl.style.willChange = '';
              });
            }
            targetWrapper.style.willChange = 'transform';
            requestAnimationFrame(() => {
              targetWrapper.style.willChange = '';
            });
          });
        }

        // Pen color picker
        // Color picker popup
        const penColorCurrent = document.getElementById('pen-color-current');
        const penColorPopup = document.getElementById('pen-color-popup');

        penColorCurrent.addEventListener('click', (e) => {
          e.stopPropagation();
          penColorPopup.classList.toggle('visible');
        });

        document.querySelectorAll('.pen-color').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.pen-color').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const rgb = btn.dataset.color;
            currentPenColor = `rgba(${rgb}, 0.7)`;
            const ctx = activeDrawingCtx || drawingCtx;
            if (ctx) ctx.strokeStyle = currentPenColor;
            // Update current swatch color
            penColorCurrent.style.background = btn.style.background;
            penColorPopup.classList.remove('visible');
          });
        });

        // Close color popup on outside click
        document.addEventListener('click', () => {
          penColorPopup.classList.remove('visible');
        });

        // Pen size picker
        document.querySelectorAll('.pen-size').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.pen-size').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentPenSize = parseInt(btn.dataset.size);
            const ctx = activeDrawingCtx || drawingCtx;
            if (ctx) ctx.lineWidth = currentPenSize;
          });
        });

        // Handle window resize — preserve drawing data
        window.addEventListener('resize', () => {
          const canvas = noteDrawingLayer;
          const oldData = drawingCtx ? canvas.toDataURL() : null;
          initNoteDrawingLayer();
          if (oldData) {
            const img = new Image();
            img.onload = () => {
              drawingCtx.save();
              drawingCtx.setTransform(1, 0, 0, 1, 0, 0);
              drawingCtx.drawImage(img, 0, 0, canvas.width, canvas.height);
              drawingCtx.restore();
            };
            img.src = oldData;
          }
        });

        // Apply random color on load and update active swatch
        updateNoteColors(currentColor);
        // Set initial drawing clip from curled state
        syncDrawingClip(statePoints.curled);
        colorSwatches.forEach(s => {
          s.classList.toggle('active', s.dataset.color === currentColor);
        });

        // Apply intro gradient lightening AFTER color theme is set
        if (window._introNeedsGradient) {
          const s0 = document.getElementById('grad-stop-0');
          const s1 = document.getElementById('grad-stop-1');
          window._introOrigStop0 = s0.getAttribute('stop-color');
          window._introOrigStop1 = s1.getAttribute('stop-color');
          function lightenWarm(hex) {
            const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
            return '#' + [
              Math.min(255, Math.round(r + (255-r)*0.4 + 15)),
              Math.min(255, Math.round(g + (255-g)*0.4 + 8)),
              Math.min(255, Math.round(b + (255-b)*0.3))
            ].map(c => c.toString(16).padStart(2,'0')).join('');
          }
          window._introLightStop0 = lightenWarm(window._introOrigStop0);
          window._introLightStop1 = lightenWarm(window._introOrigStop1);
          s0.setAttribute('stop-color', window._introLightStop0);
          s1.setAttribute('stop-color', window._introLightStop1);
        }

        // ==========================================
        // Apple Wallet Pass Generation
        // ==========================================
        const appleWalletBtn = document.getElementById('apple-wallet-btn');
        const walletMsg = document.getElementById('wallet-message');
        const walletQr = document.getElementById('wallet-qr');
        let qrVisible = false;

        // Detect if user is on mobile (iOS/Android)
        function isMobile() {
          return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        }

        appleWalletBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          // Get note content from active/last active note via registry
          const targetNote = window.getTargetNote();
          const text = targetNote ? targetNote.getText() : document.getElementById('memo').value;
          const drawingDataUrl = targetNote ? targetNote.getDrawing() : noteDrawingLayer.toDataURL('image/png');
          const noteColor = targetNote ? targetNote.color : currentColor;

          const BACKEND_URL = 'https://sandbox-staging.up.railway.app';

          if (!isMobile()) {
            // Desktop: toggle QR code inside the button
            if (qrVisible) {
              appleWalletBtn.classList.remove('qr-open');
              setTimeout(() => { walletQr.innerHTML = ''; }, 400);
              qrVisible = false;
              return;
            }

            // Prepare pass on server (includes drawing), get token for QR
            try {
              // Show cycling placeholder QR codes while loading
              const placeholderTexts = ['walletmemo.com/loading', 'walletmemo.com/memo', 'walletmemo.com/pass'];
              let placeholderIdx = 0;
              function showPlaceholderQR() {
                const pqr = qrcode(0, 'M');
                pqr.addData(placeholderTexts[placeholderIdx % placeholderTexts.length]);
                pqr.make();
                const pImg = document.createElement('img');
                pImg.src = pqr.createDataURL(4, 4);
                pImg.style.cssText = 'width:100%;height:auto;display:block;opacity:0.35;transition:opacity 0.25s;';
                const pInner = document.createElement('div');
                pInner.style.cssText = 'background:#fff;border-radius:6px;padding:8px;width:100%;box-sizing:border-box;';
                pInner.appendChild(pImg);
                walletQr.innerHTML = '';
                walletQr.appendChild(pInner);
                placeholderIdx++;
              }
              showPlaceholderQR();
              const placeholderInterval = setInterval(showPlaceholderQR, 400);
              appleWalletBtn.classList.add('qr-open');
              
              const prepRes = await fetch(`${BACKEND_URL}/api/prepare-pass`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text, color: noteColor, drawingDataUrl })
              });
              const { token } = await prepRes.json();
              const passUrl = `${BACKEND_URL}/api/download-pass/${token}`;
              
              const qr = qrcode(0, 'M');
              qr.addData(passUrl);
              qr.make();
              const btnImg = document.getElementById('apple-wallet-img');
              const btnWidth = btnImg ? btnImg.offsetWidth : 120;
              const img = document.createElement('img');
              img.src = qr.createDataURL(4, 4);
              img.style.width = '100%';
              img.style.height = 'auto';
              img.style.display = 'block';
              const qrInner = document.createElement('div');
              qrInner.style.cssText = 'background:#fff;border-radius:6px;padding:8px;width:100%;box-sizing:border-box;';
              qrInner.appendChild(img);
              clearInterval(placeholderInterval);
              walletQr.innerHTML = '';
              walletQr.appendChild(qrInner);
              qrVisible = true;
            } catch (err) {
              clearInterval(placeholderInterval);
              console.error('QR generation failed:', err);
              walletQr.innerHTML = '';
              appleWalletBtn.classList.remove('qr-open');
              alert('QR Error: ' + err.message);
            }
            return;
          }
          
          // Mobile: download pass directly
          const originalContent = appleWalletBtn.innerHTML;
          appleWalletBtn.style.opacity = '0.6';
          appleWalletBtn.style.pointerEvents = 'none';
          
          try {
            const response = await fetch(`${BACKEND_URL}/api/generate-pass`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                text: text,
                color: noteColor,
                drawingDataUrl: drawingDataUrl
              })
            });
            
            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.error || 'Failed to generate pass');
            }
            
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            window.location.href = url;
            
          } catch (error) {
            console.error('Error:', error);
            walletMsg.textContent = error.message.includes('fetch') 
              ? 'Backend not running. Start the server first!'
              : error.message;
            walletMsg.classList.add('visible');
            setTimeout(() => walletMsg.classList.remove('visible'), 3000);
          } finally {
            appleWalletBtn.style.opacity = '1';
            appleWalletBtn.style.pointerEvents = 'auto';
          }
        });
      })();

      // Desktop drag-to-move sticky note + "add new" pad
      (function() {
        if ('ontouchstart' in window) return; // Skip on mobile

        const mainArea = document.querySelector('main') || document.querySelector('.content-wrapper');
        const wrapper = document.getElementById('note-wrapper');
        const dragZoneHeight = 80;
        let noteCounter = 0;
        let hasMoved = false;

        // Create the "add new note" button that sits behind the note
        const addBtn = document.createElement('div');
        addBtn.className = 'add-note-btn';
        addBtn.innerHTML = '<i class="hgi-stroke hgi-add-01"></i>';
        addBtn.style.display = 'none';
        wrapper.parentElement.insertBefore(addBtn, wrapper);

        function makeDraggable(el) {
          let isDragging = false;
          let startX, startY, origX = 0, origY = 0;
          let offsetX = 0, offsetY = 0;
          let tiltDeg = 3;

          el.addEventListener('mousemove', (e) => {
            if (isDragging) return;
            const rect = el.getBoundingClientRect();
            const relY = e.clientY - rect.top;
            if (relY < dragZoneHeight && !e.target.closest('.note-menu-btn') && !e.target.closest('.note-dropdown')) {
              el.classList.add('can-grab');
            } else {
              el.classList.remove('can-grab');
            }
          });

          el.addEventListener('mousedown', (e) => {
            const rect = el.getBoundingClientRect();
            const relY = e.clientY - rect.top;
            if (relY >= dragZoneHeight) return;
            if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown')) return;
            if (isDrawingMode) return;

            e.preventDefault();
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            origX = offsetX;
            origY = offsetY;
            el.classList.remove('can-grab');
            el.classList.add('is-grabbing');
            // Track active note
            if (el.dataset.noteId) setActiveNote(el.dataset.noteId);
            el.style.transition = 'none';
            // Lower all other notes, raise this one highest
            document.querySelectorAll('.note-wrapper').forEach(n => {
              if (n !== el) {
                n.style.zIndex = '1';
                n.style.transition = 'transform 0.3s ease';
              }
            });
            el.style.zIndex = '100';
            // Lift off the wall - go flat
            el.classList.add('flat');
            el.dispatchEvent(new Event('note:lift'));
            const elRect = el.getBoundingClientRect();
            tiltDeg = (e.clientX < elRect.left + elRect.width / 2) ? 3 : -3;
            el.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(1.03) rotate(${tiltDeg}deg)`;
            // Show add button immediately on grab
            if (!hasMoved) {
              hasMoved = true;
              addBtn.style.display = 'flex';
            }
          });

          document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            offsetX = origX + dx;
            offsetY = origY + dy;
            el.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(1.03) rotate(${tiltDeg}deg)`;
            updateShadowPosition(el);
          });

          document.addEventListener('mouseup', () => {
            if (!isDragging) return;
            isDragging = false;
            el.classList.remove('is-grabbing');
            el.classList.add('can-grab');
            deactivateNote();
            el.style.transition = '';
            // Stick back to wall - remove flat, go back to curled
            el.classList.remove('flat');
            el.dispatchEvent(new Event('note:stick'));
            el.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            updateShadowPosition(el);
            const ta = el.querySelector('textarea');
            if (ta) ta.blur();
            // Suppress the click event that fires after mouseup
            // so it doesn't re-focus the textarea and flatten the note
            el.addEventListener('click', function suppressClick(evt) {
              evt.stopPropagation();
              evt.preventDefault();
              el.removeEventListener('click', suppressClick, true);
            }, true);
          });
        }

        makeDraggable(wrapper);
        updateShadowPosition(wrapper);

        // (intro animation moved to standalone script block below)

        // Add new note button
        const placeholders = [
          "Pick up groceries\nCall dentist\nStretch!",
          "Idea: build an app\nResearch competitors\nSketch wireframes",
          "Monday meeting\nBring snacks\nAsk about timeline",
          "Gift ideas:\nNew headphones?\nBook about space",
          "Workout plan\nRun 2 miles\nDrink more water",
          "Movie night picks:\nInterstellar\nEverything Everywhere",
          "Pack for trip\nCharger\nPassport\nSnacks",
          "Learn something new\nWatch a tutorial\nTake notes",
          "Groceries:\nAvocados\nSourdough\nCoffee beans",
          "Weekend plans\nFarmers market\nCook dinner\nRead",
          "Buy it.\nUse it.\nBreak it.\nFix it.",
          "It doesn't have to\nbe done. It just has\nto be perfect.",
          "Drink water.",
          "Send the email.",
          "Stretch for\n30 seconds.\nCount it.",
          "Call dentist.",
          "Don't turn\nOff.",
        ];

        addBtn.addEventListener('click', () => {
          noteCounter++;
          const colors = ['blue', 'yellow', 'pink'];
          const color = colors[noteCounter % 3];

          // Color configs (gradient + shadow colors per theme)
          const colorMap = {
            blue: ['#89C5E0', '#98C4DA', '#9BC8E7', '#ACD7E9', '#B8E3F3', '#C4E9F5'],
            yellow: ['#C8B440', '#D4B94C', '#DEC75E', '#E8D46E', '#F0DF85', '#F7EA9C'],
            pink: ['#CC9BA5', '#D7A0AA', '#E2B4BD', '#ECC4CC', '#F2D1D8', '#F8DEE3']
          };
          // SVG drop shadows disabled — using CSS .note-shadow rectangle instead
          const shadowMap = {
            blue: {
              s1: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
              s2: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
              s3: '0 0 0 0 0.425615 0 0 0 0 0.695906 0 0 0 0 0.842314 0 0 0 1 0'
            },
            yellow: {
              s1: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
              s2: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
              s3: '0 0 0 0 0.9 0 0 0 0 0.7 0 0 0 0 0.3 0 0 0 1 0'
            },
            pink: {
              s1: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
              s2: '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
              s3: '0 0 0 0 0.88 0 0 0 0 0.72 0 0 0 0 0.78 0 0 0 1 0'
            }
          };
          const g = colorMap[color];
          const s = shadowMap[color];

          const newWrapper = document.createElement('div');
          newWrapper.className = 'note-wrapper dragged-note';
          newWrapper.style.position = 'absolute';
          newWrapper.style.top = wrapper.offsetTop + 'px';
          newWrapper.style.left = wrapper.offsetLeft + 'px';
          newWrapper.style.width = '360px';
          newWrapper.style.height = '340px';
          newWrapper.style.zIndex = String(10 + noteCounter);

          // Use DOMParser to create proper SVG namespace elements
          const svgMarkup = `<svg class="note-paper" width="287" height="270" viewBox="0 0 287 270" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g filter="url(#nf${noteCounter})">
                <path d="M34.6016 19.2695L250.102 18.5996C250.102 18.5996 249.602 49.0996 257.602 228.6L28.6016 231.1C36.6029 66.5996 34.6016 19.2695 34.6016 19.2695Z" fill="url(#ng${noteCounter})"/>
              </g>
              <defs>
                <linearGradient id="ng${noteCounter}" x1="153.102" y1="231.1" x2="143.601" y2="18.5996" gradientUnits="userSpaceOnUse">
                  <stop stop-color="${g[0]}"/>
                  <stop offset="0.255906" stop-color="${g[1]}"/>
                  <stop offset="0.812358" stop-color="${g[2]}"/>
                  <stop offset="0.864881" stop-color="${g[3]}"/>
                  <stop offset="0.954264" stop-color="${g[4]}"/>
                  <stop offset="1" stop-color="${g[5]}"/>
                </linearGradient>
                <filter id="nf${noteCounter}" x="0.00156212" y="-0.000391006" width="286.2" height="269.7" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
                  <feFlood flood-opacity="0" result="BackgroundImageFix"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
                  <feOffset/>
                  <feGaussianBlur stdDeviation="5.14583"/>
                  <feColorMatrix type="matrix" values="${s.s1}"/>
                  <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
                  <feOffset dy="10"/>
                  <feGaussianBlur stdDeviation="14.3"/>
                  <feColorMatrix type="matrix" values="${s.s2}"/>
                  <feBlend mode="normal" in2="effect1_dropShadow" result="effect2_dropShadow"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
                  <feOffset dy="0.2"/>
                  <feComposite in2="hardAlpha" operator="out"/>
                  <feColorMatrix type="matrix" values="${s.s3}"/>
                  <feBlend mode="normal" in2="effect2_dropShadow" result="effect3_dropShadow"/>
                  <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
                  <feTurbulence type="fractalNoise" baseFrequency="1.6666666269302368 1.6666666269302368" stitchTiles="stitch" numOctaves="3" result="noise" seed="${6167 + noteCounter}"/>
                  <feComponentTransfer in="noise" result="coloredNoise1">
                    <feFuncR type="linear" slope="2" intercept="-0.5"/>
                    <feFuncG type="linear" slope="2" intercept="-0.5"/>
                    <feFuncB type="linear" slope="2" intercept="-0.5"/>
                    <feFuncA type="discrete" tableValues="1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"/>
                  </feComponentTransfer>
                  <feComposite operator="in" in2="shape" in="coloredNoise1" result="noise1Clipped"/>
                  <feComponentTransfer in="noise1Clipped" result="color1">
                    <feFuncA type="table" tableValues="0 0.06"/>
                  </feComponentTransfer>
                  <feMerge result="effect4_noise">
                    <feMergeNode in="shape"/>
                    <feMergeNode in="color1"/>
                  </feMerge>
                  <feBlend mode="normal" in="effect4_noise" in2="effect3_dropShadow" result="effect4_noise"/>
                </filter>
              </defs>
            </svg>`;
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(svgMarkup, 'image/svg+xml');
          const svgNode = document.adoptNode(svgDoc.documentElement);
          
          const noteDiv = document.createElement('div');
          noteDiv.className = 'note';
          noteDiv.style.cssText = 'width:360px;height:340px;padding:48px 57px;position:absolute;top:0;left:0;z-index:2;display:flex;flex-direction:column;justify-content:center;';
          const ta = document.createElement('textarea');
          ta.className = 'textarea';
          ta.maxLength = 140;
          ta.style.cssText = "font-family:'Patrick Hand',cursive;font-size:20px;line-height:1.5;color:#1a1a1a;border:none;background:transparent;resize:none;outline:none;text-align:center;width:100%;overflow:hidden;";
          noteDiv.appendChild(ta);

          // Add drawing canvas to spawned note
          const spawnCanvas = document.createElement('canvas');
          spawnCanvas.className = 'note-drawing-layer';
          noteDiv.appendChild(spawnCanvas);

          // Add menu button to spawned note
          const spawnMenuBtn = document.createElement('button');
          spawnMenuBtn.className = 'note-menu-btn';
          spawnMenuBtn.innerHTML = '<svg viewBox="0 0 24 24"><circle cx="12" cy="5" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="12" cy="19" r="2"/></svg>';

          const spawnDropdown = document.createElement('div');
          spawnDropdown.className = 'note-dropdown';
          spawnDropdown.innerHTML = `
            <button class="dropdown-item spawn-color-btn">
              <span class="color-icon" style="background:${colorIconColors[color]};"></span>
              <span>Change Color</span>
            </button>
            <div class="color-submenu">
              <div class="color-swatch" data-color="blue" style="background: #B4DCE8;"></div>
              <div class="color-swatch" data-color="yellow" style="background: #EAD264;"></div>
              <div class="color-swatch" data-color="pink" style="background: #ECBDC5;"></div>
            </div>
            <button class="dropdown-item" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="10" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
              <span>Add Stamp</span> <span class="coming-soon-tag">Coming soon</span>
            </button>
            <button class="dropdown-item" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 14s1.5 2 4 2 4-2 4-2"/><line x1="9" y1="9" x2="9.01" y2="9"/><line x1="15" y1="9" x2="15.01" y2="9"/></svg>
              <span>Stickers</span> <span class="coming-soon-tag">Coming soon</span>
            </button>
            <button class="dropdown-item spawn-draw-btn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/></svg>
              <span>Draw on Note</span>
            </button>
          `;
          noteDiv.appendChild(spawnMenuBtn);
          noteDiv.appendChild(spawnDropdown);

          // Init drawing canvas for this note
          let spawnDrawingCtx = null;
          function initSpawnCanvas() {
            spawnCanvas.width = noteDiv.offsetWidth * 2;
            spawnCanvas.height = noteDiv.offsetHeight * 2;
            spawnDrawingCtx = spawnCanvas.getContext('2d');
            spawnDrawingCtx.scale(2, 2);
            spawnDrawingCtx.lineCap = 'round';
            spawnDrawingCtx.lineJoin = 'round';
            spawnDrawingCtx.strokeStyle = currentPenColor;
            spawnDrawingCtx.lineWidth = currentPenSize;
          }
          // Delay init until note is in DOM and has dimensions
          requestAnimationFrame(() => { initSpawnCanvas(); });

          // Wire up spawned menu
          const spawnColorBtn = spawnDropdown.querySelector('.spawn-color-btn');
          const spawnColorSub = spawnDropdown.querySelector('.color-submenu');
          const spawnSwatches = spawnDropdown.querySelectorAll('.color-swatch');
          const spawnColorIcon = spawnDropdown.querySelector('.color-icon');
          const spawnDrawBtn = spawnDropdown.querySelector('.spawn-draw-btn');

          spawnMenuBtn.addEventListener('mousedown', (e) => e.preventDefault());
          spawnDropdown.addEventListener('mousedown', (e) => e.preventDefault());
          spawnMenuBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            spawnMenuBtn.classList.toggle('active');
            spawnDropdown.classList.toggle('open');
          });
          document.addEventListener('click', (e) => {
            if (!spawnDropdown.contains(e.target) && !spawnMenuBtn.contains(e.target)) {
              spawnDropdown.classList.remove('open');
              spawnMenuBtn.classList.remove('active');
              spawnColorSub.classList.remove('open');
            }
          });
          spawnColorBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            spawnColorSub.classList.toggle('open');
          });
          spawnSwatches.forEach(sw => {
            sw.addEventListener('click', (e) => {
              e.stopPropagation();
              const ck = sw.dataset.color;
              const theme = colorThemes[ck];
              if (!theme) return;
              const stops = svgNode.querySelectorAll('stop');
              theme.gradient.forEach((c, i) => { if (stops[i]) stops[i].setAttribute('stop-color', c); });
              spawnColorIcon.style.background = colorIconColors[ck];
              // Update registry color
              spawnColor = ck;
              var reg = window.noteRegistry.get(spawnNoteId);
              if (reg) reg.color = ck;
              // Clear drawing when color changes
              if (spawnDrawingCtx) {
                spawnDrawingCtx.clearRect(0, 0, spawnCanvas.width, spawnCanvas.height);
              }
              spawnSwatches.forEach(s => s.classList.remove('active'));
              sw.classList.add('active');
              spawnDropdown.classList.remove('open');
              spawnMenuBtn.classList.remove('active');
              spawnColorSub.classList.remove('open');
            });
          });

          // Wire up Draw button for spawned note
          spawnDrawBtn.addEventListener('click', () => {
            spawnDropdown.classList.remove('open');
            spawnMenuBtn.classList.remove('active');
            setActiveNote(spawnNoteId);

            // Close any other note's drawing mode
            if (activeDrawingNote && activeDrawingNote !== newWrapper) {
              closeActiveDrawingMode();
            }

            // Init canvas if needed
            if (!spawnDrawingCtx) initSpawnCanvas();

            // Save state for cancel
            const savedData = spawnDrawingCtx.getImageData(0, 0, spawnCanvas.width, spawnCanvas.height);

            // Set as active drawing note
            activeDrawingNote = newWrapper;
            activeDrawingCanvas = spawnCanvas;
            activeDrawingCtx = spawnDrawingCtx;
            activeSavedImageData = savedData;

            // Lift note flat
            newWrapper.dispatchEvent(new Event('note:lift'));
            ta.blur();
            newWrapper.classList.add('flat');

            // Enable drawing mode
            isDrawingMode = true;
            document.body.classList.add('drawing-mode-active');
            newWrapper.classList.add('drawing-mode');

            // Show toolbar
            const toolbar = document.getElementById('drawing-toolbar');
            if (toolbar) toolbar.classList.add('visible');
            const focusOverlay = document.querySelector('.focus-overlay');
            if (focusOverlay) focusOverlay.classList.add('active');

            // Sync toolbar pen settings to this canvas
            spawnDrawingCtx.strokeStyle = currentPenColor;
            spawnDrawingCtx.lineWidth = currentPenSize;
          });

          // Add shadow layer with theme-matched color
          const shadowDiv = document.createElement('div');
          shadowDiv.className = 'note-shadow';
          const spawnTheme = colorThemes[color];
          if (spawnTheme && spawnTheme.shadow2) {
            const [r, g, b] = spawnTheme.shadow2;
            const cr = Math.round(r * 255), cg = Math.round(g * 255), cb = Math.round(b * 255);
            shadowDiv.style.background = `linear-gradient(to bottom, rgba(${cr},${cg},${cb},0) 0%, rgba(${cr},${cg},${cb},0.4) 100%)`;
          }
          newWrapper.appendChild(shadowDiv);
          newWrapper.appendChild(svgNode);
          newWrapper.appendChild(noteDiv);

          // Assign note ID
          const spawnNoteId = 'note-' + noteCounter;
          newWrapper.dataset.noteId = spawnNoteId;

          // Track color in closure for registry updates
          let spawnColor = color;

          // Register in noteRegistry
          window.noteRegistry.set(spawnNoteId, {
            wrapper: newWrapper,
            color: spawnColor,
            getText: function() { return ta.value; },
            getDrawing: function() { return spawnCanvas.toDataURL('image/png'); }
          });

          // Track active note on spawned textarea focus/blur
          ta.addEventListener('focus', function() { setActiveNote(spawnNoteId); });
          ta.addEventListener('blur', function() { deactivateNote(); });

          wrapper.parentElement.insertBefore(newWrapper, addBtn);
          // Set random placeholder
          if (ta) ta.placeholder = placeholders[Math.floor(Math.random() * placeholders.length)];
          makeDraggable(newWrapper);
          // Get stops from the properly-namespaced SVG
          const noteStops = svgNode.querySelectorAll('stop');
          initNoteAnimations(newWrapper, color, noteCounter, noteStops);

          // Hide add button until this new one is dragged
          hasMoved = false;
          addBtn.style.display = 'none';
        });
      })();

    // ==========================================
    // Peel-to-reveal intro animation (standalone — works on mobile + desktop)
    // ==========================================
    (function() {
      if (true || !sessionStorage.getItem('wm-intro-seen')) {
        const introNoteShape = document.getElementById('note-shape');
        const introWrapper = document.getElementById('note-wrapper');
        const introTightCurl = [
          [34.6016, 19.2695], [250.102, 18.5996], [250.102, 18.5996],
          [249.602, 49.0996], [255.0, 210.0],
          [28.6016, 231.1], [36.6029, 66.5996], [34.6016, 19.2695], [34.6016, 19.2695]
        ];
        const introCurled = [
          [34.6016, 19.2695], [250.102, 18.5996], [250.102, 18.5996],
          [249.602, 49.0996], [257.602, 228.6],
          [28.6016, 231.1], [36.6029, 66.5996], [34.6016, 19.2695], [34.6016, 19.2695]
        ];
        function introPointsToPath(pts) {
          return `M${pts[0][0]} ${pts[0][1]} L${pts[1][0]} ${pts[1][1]} C${pts[2][0]} ${pts[2][1]} ${pts[3][0]} ${pts[3][1]} ${pts[4][0]} ${pts[4][1]} L${pts[5][0]} ${pts[5][1]} C${pts[6][0]} ${pts[6][1]} ${pts[7][0]} ${pts[7][1]} ${pts[8][0]} ${pts[8][1]} Z`;
        }
        function introLerp(from, to, t) {
          return from.map((p, i) => [p[0] + (to[i][0] - p[0]) * t, p[1] + (to[i][1] - p[1]) * t]);
        }
        introNoteShape.setAttribute('d', introPointsToPath(introTightCurl));

        const introShadow = introWrapper.querySelector('.note-shadow');
        if (introShadow) introShadow.style.opacity = '0.3';

        setTimeout(() => {
          const introStart = performance.now();
          const introDuration = 1200;
          let introAnimId = null;
          function introPeelEase(t) {
            return t < 0.4 ? 0.15 * Math.pow(t / 0.4, 2) : 0.15 + 0.85 * Math.pow((t - 0.4) / 0.6, 0.5);
          }
          const stop0 = document.getElementById('grad-stop-0');
          const stop1 = document.getElementById('grad-stop-1');
          function parseHex(hex) { return [parseInt(hex.slice(1,3),16), parseInt(hex.slice(3,5),16), parseInt(hex.slice(5,7),16)]; }
          const lightColors = [parseHex(window._introLightStop0 || '#DFF0FA'), parseHex(window._introLightStop1 || '#D0E8F4')];
          const origColors  = [parseHex(window._introOrigStop0 || '#89C5E0'), parseHex(window._introOrigStop1 || '#98C4DA')];
          function lerpColor(from, to, t) {
            return '#' + [0,1,2].map(i => Math.round(from[i] + (to[i]-from[i])*t).toString(16).padStart(2,'0')).join('');
          }
          function introAnimate(currentTime) {
            const elapsed = currentTime - introStart;
            const progress = Math.min(elapsed / introDuration, 1);
            const ep = introPeelEase(progress);
            const pts = introLerp(introTightCurl, introCurled, ep);
            introNoteShape.setAttribute('d', introPointsToPath(pts));
            stop0.setAttribute('stop-color', lerpColor(lightColors[0], origColors[0], ep));
            stop1.setAttribute('stop-color', lerpColor(lightColors[1], origColors[1], ep));
            if (progress < 1) introAnimId = requestAnimationFrame(introAnimate);
          }
          introAnimId = requestAnimationFrame(introAnimate);

          introWrapper.style.transition = 'transform 1.2s cubic-bezier(0.4, 0, 0.2, 1)';
          introWrapper.style.transform = '';
          setTimeout(() => { introWrapper.style.transition = ''; }, 1300);

          if (introShadow) {
            introShadow.style.transition = 'opacity 0.9s ease-out';
            introShadow.style.opacity = '1';
            setTimeout(() => { introShadow.style.transition = ''; }, 1000);
          }
          sessionStorage.setItem('wm-intro-seen', '1');
        }, 200);
      }
    })();

    // Show test version on test site
    if (location.hostname.includes('clawdbrit')) {
      const tv = document.getElementById('test-version');
      if (tv) tv.textContent = ' · test v95';
      // Make footer always visible on test site
      const footer = document.querySelector('.build-hover-area');
      if (footer) { footer.style.opacity = '1'; footer.style.visibility = 'visible'; }

      // Add changelog link to footer (test → test changelog)
      const footerArea = document.querySelector('.build-hover-area');
      if (footerArea) {
        const clLink = document.createElement('a');
        clLink.href = 'changelog-test.html';
        clLink.className = 'footer-link changelog-footer-link';
        clLink.setAttribute('data-i18n', 'changelog');
        clLink.textContent = 'Changelog';
        const dot = document.createTextNode(' · ');
        footerArea.insertBefore(dot, footerArea.firstChild);
        footerArea.insertBefore(clLink, footerArea.firstChild);
      }
      // Re-apply i18n so the dynamically added link gets translated
      const savedLang = localStorage.getItem('walletmemo-lang');
      if (savedLang) applyLanguage(savedLang);
    }

    // Production changelog link (always visible)
    if (!location.hostname.includes('clawdbrit')) {
      const footerArea = document.querySelector('.build-hover-area');
      if (footerArea) {
        const clLink = document.createElement('a');
        clLink.href = 'changelog.html';
        clLink.className = 'footer-link changelog-footer-link';
        clLink.setAttribute('data-i18n', 'changelog');
        clLink.textContent = 'Changelog';
        const dot = document.createTextNode(' · ');
        footerArea.insertBefore(dot, footerArea.firstChild);
        footerArea.insertBefore(clLink, footerArea.firstChild);
      }
      // Re-apply i18n so the dynamically added link gets translated
      const savedLang2 = localStorage.getItem('walletmemo-lang');
      if (savedLang2) applyLanguage(savedLang2);
    }

    // Page transition: slide out left when clicking changelog
    document.addEventListener('click', (e) => {
      const link = e.target.closest('.changelog-footer-link');
      if (!link) return;
      e.preventDefault();
      const href = link.href;
      sessionStorage.setItem('page-transition', 'forward');
      document.documentElement.classList.remove('page-slide-in-left');
      document.documentElement.classList.add('page-slide-out-left');
      setTimeout(() => { window.location.href = href; }, 300);
    });
    </script>
    </div><!-- /page-content -->
  </body>
</html>
