<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Wallet Memo</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&family=Playfair+Display:wght@900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.hugeicons.com/font/hgi-stroke-rounded.css">
    <script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>
    <link rel="stylesheet" href="./style.css" />
    <!-- Hreflang alternate links for SEO -->
    <link rel="alternate" hreflang="en" href="https://walletmemo.com/" />
    <link rel="alternate" hreflang="es" href="https://walletmemo.com/?lang=es" />
    <link rel="alternate" hreflang="fr" href="https://walletmemo.com/?lang=fr" />
    <link rel="alternate" hreflang="de" href="https://walletmemo.com/?lang=de" />
    <link rel="alternate" hreflang="ja" href="https://walletmemo.com/?lang=ja" />
    <link rel="alternate" hreflang="zh" href="https://walletmemo.com/?lang=zh" />
    <link rel="alternate" hreflang="ko" href="https://walletmemo.com/?lang=ko" />
    <link rel="alternate" hreflang="pt" href="https://walletmemo.com/?lang=pt" />
    <link rel="alternate" hreflang="x-default" href="https://walletmemo.com/" />
          <!-- GoatCounter analytics -->
    <script data-goatcounter="https://walletmemo.goatcounter.com/count"
            async src="//gc.zgo.at/count.js"></script>
  </head>
  <body>
    <div class="focus-overlay" id="focus-overlay"></div>
    <!-- Language picker -->
    <div class="lang-picker" id="lang-picker">
      <button class="lang-btn" id="lang-btn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <circle cx="12" cy="12" r="10"/>
          <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
        </svg>
        <span id="current-lang">EN</span>
        <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M6 9l6 6 6-6"/>
        </svg>
      </button>
      <div class="lang-dropdown" id="lang-dropdown">
        <button class="lang-option" data-lang="en">English</button>
        <button class="lang-option" data-lang="es">Español</button>
        <button class="lang-option" data-lang="fr">Français</button>
        <button class="lang-option" data-lang="de">Deutsch</button>
        <button class="lang-option" data-lang="ja">日本語</button>
        <button class="lang-option" data-lang="zh">中文</button>
        <button class="lang-option" data-lang="ko">한국어</button>
        <button class="lang-option" data-lang="pt">Português</button>
      </div>
    </div>

    <div class="content-group">
      <div class="hero-text">
        <div class="hero-title">Wallet Memo</div>
        <div class="hero-tagline" id="hero-tagline">A sticky note for your Apple Wallet</div>
      </div>

      <main class="container">
      <div class="note-wrapper" id="note-wrapper">
        <!-- Shadow layer (behind note) -->
        <img src="./assets/paper-stuff/shadow-layer.svg" class="note-shadow" id="note-shadow" alt="">
        <!-- Sticky note SVG - inlined for dynamic color updates -->
        <svg class="note-paper" id="note-paper" data-state="one" width="287" height="270" viewBox="0 0 287 270" fill="none" xmlns="http://www.w3.org/2000/svg">
          <g filter="url(#noteFilter)">
            <path id="note-shape" d="M34.6016 19.2695L250.102 18.5996C250.102 18.5996 249.602 49.0996 257.602 228.6L28.6016 231.1C36.6029 66.5996 34.6016 19.2695 34.6016 19.2695Z" fill="url(#noteGradient)"/>
          </g>
          <defs>
            <filter id="noteFilter" x="0.00156212" y="-0.000391006" width="286.2" height="269.7" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
              <feFlood flood-opacity="0" result="BackgroundImageFix"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset/>
              <feGaussianBlur stdDeviation="5.14583"/>
              <feColorMatrix id="shadowColor1" type="matrix" values="0 0 0 0 0.101961 0 0 0 0 0.55098 0 0 0 0 1 0 0 0 0 0"/>
              <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset dy="10"/>
              <feGaussianBlur stdDeviation="14.3"/>
              <feColorMatrix id="shadowColor2" type="matrix" values="0 0 0 0 0 0 0 0 0 0.334596 0 0 0 0 0.608357 0 0 0 0 0"/>
              <feBlend mode="normal" in2="effect1_dropShadow" result="effect2_dropShadow"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset dy="0.2"/>
              <feComposite in2="hardAlpha" operator="out"/>
              <feColorMatrix id="shadowColor3" type="matrix" values="0 0 0 0 0.425615 0 0 0 0 0.695906 0 0 0 0 0.842314 0 0 0 1 0"/>
              <feBlend mode="normal" in2="effect2_dropShadow" result="effect3_dropShadow"/>
              <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
              <feTurbulence type="fractalNoise" baseFrequency="1.6666666269302368 1.6666666269302368" stitchTiles="stitch" numOctaves="3" result="noise" seed="6167"/>
              <feComponentTransfer in="noise" result="coloredNoise1">
                <feFuncR type="linear" slope="2" intercept="-0.5"/>
                <feFuncG type="linear" slope="2" intercept="-0.5"/>
                <feFuncB type="linear" slope="2" intercept="-0.5"/>
                <feFuncA type="discrete" tableValues="1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"/>
              </feComponentTransfer>
              <feComposite operator="in" in2="shape" in="coloredNoise1" result="noise1Clipped"/>
              <feComponentTransfer in="noise1Clipped" result="color1">
                <feFuncA type="table" tableValues="0 0.06"/>
              </feComponentTransfer>
              <feMerge result="effect4_noise">
                <feMergeNode in="shape"/>
                <feMergeNode in="color1"/>
              </feMerge>
              <feBlend mode="normal" in="effect4_noise" in2="effect3_dropShadow" result="effect4_noise"/>
            </filter>
            <linearGradient id="noteGradient" x1="153.102" y1="231.1" x2="143.601" y2="18.5996" gradientUnits="userSpaceOnUse">
              <stop id="grad-stop-0" stop-color="#9DD5EE"/>
              <stop id="grad-stop-1" offset="0.255906" stop-color="#98C4DA"/>
              <stop id="grad-stop-2" offset="0.812358" stop-color="#9BC8E7"/>
              <stop id="grad-stop-3" offset="0.864881" stop-color="#ACD7E9"/>
              <stop id="grad-stop-4" offset="0.954264" stop-color="#B8E3F3"/>
              <stop id="grad-stop-5" offset="1" stop-color="#C4E9F5"/>
            </linearGradient>
          </defs>
        </svg>
        <div class="note" id="sticky-note">
          <!-- Ellipsis menu button -->
          <button class="note-menu-btn" id="menu-btn">
            <svg viewBox="0 0 24 24">
              <circle cx="12" cy="5" r="2"/>
              <circle cx="12" cy="12" r="2"/>
              <circle cx="12" cy="19" r="2"/>
            </svg>
          </button>

          <!-- Dropdown menu -->
          <div class="note-dropdown" id="note-dropdown">
            <button class="dropdown-item" id="change-color-btn">
              <span class="color-icon" id="color-icon"></span>
              <span data-i18n="changeColor">Change Color</span>
            </button>
            <div class="color-submenu" id="color-submenu">
              <div class="color-swatch" data-color="blue" style="background: #B4DCE8;"></div>
              <div class="color-swatch" data-color="yellow" style="background: #EAD264;"></div>
              <div class="color-swatch" data-color="pink" style="background: #ECBDC5;"></div>
            </div>
            <button class="dropdown-item" id="add-stamp-btn" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="11" width="18" height="10" rx="2"/>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
              </svg>
              <span data-i18n="addStamp">Add Stamp</span> <span class="coming-soon-tag" data-i18n="comingSoon">Coming soon</span>
            </button>
            <button class="dropdown-item" id="add-sticker-btn" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                <line x1="9" y1="9" x2="9.01" y2="9"/>
                <line x1="15" y1="9" x2="15.01" y2="9"/>
              </svg>
              <span data-i18n="stickers">Stickers</span> <span class="coming-soon-tag" data-i18n="comingSoon">Coming soon</span>
            </button>
            <button class="dropdown-item" id="draw-btn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                <path d="M2 2l7.586 7.586"/>
              </svg>
              <span data-i18n="drawOnNote">Draw on Note</span>
            </button>
          </div>

          <!-- Drawing layer for finished drawings -->
          <canvas class="note-drawing-layer" id="note-drawing-layer"></canvas>

          <textarea
            id="memo"
            class="textarea"
            placeholder=""
            maxlength="140"
          ></textarea>
        </div>
        <!-- Drawing toolbar -->
        <div class="drawing-toolbar" id="drawing-toolbar">
          <div class="pen-colors">
            <button class="pen-color active" data-color="26,26,26" style="background:#1a1a1a"></button>
            <button class="pen-color" data-color="229,57,53" style="background:#e53935"></button>
            <button class="pen-color" data-color="30,136,229" style="background:#1e88e5"></button>
            <button class="pen-color" data-color="67,160,71" style="background:#43a047"></button>
            <button class="pen-color" data-color="142,36,170" style="background:#8e24aa"></button>
          </div>
          <div class="pen-sizes">
            <button class="pen-size" data-size="1"><span style="width:4px;height:4px"></span></button>
            <button class="pen-size active" data-size="2"><span style="width:6px;height:6px"></span></button>
            <button class="pen-size" data-size="4"><span style="width:10px;height:10px"></span></button>
            <button class="pen-size" data-size="6"><span style="width:14px;height:14px"></span></button>
          </div>
          <div class="pen-actions">
            <button class="toolbar-btn clear" id="clear-drawing"><i class="hgi-stroke hgi-delete-02"></i></button>
            <button class="toolbar-btn cancel" id="cancel-drawing">Cancel</button>
            <button class="toolbar-btn done" id="done-drawing">Done</button>
          </div>
        </div>
      </div>

      <div class="wallet-wrapper">
        <div class="wallet-buttons">
          <a href="#" class="wallet-btn-link" id="apple-wallet-btn">
            <img id="apple-wallet-img" src="./assets/wallet-buttons/apple-wallet-buttons/Locale=EN.svg" alt="Add to Apple Wallet">
            <div class="wallet-qr" id="wallet-qr"></div>
          </a>
          <a href="#" class="wallet-btn-link" id="google-wallet-btn" style="display: none;">
            <img id="google-wallet-img" src="./assets/wallet-buttons/google-wallet-buttons/Locale=EN, Type=Primary.svg" alt="Add to Google Wallet">
          </a>
        </div>
        <div class="wallet-message" id="wallet-message" data-i18n="comingSoonExcl">Coming soon!</div>
        <div class="build-hover-area"><a href="mailto:ram@agentmail.to" class="footer-link"><svg class="mail-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-right:4px;position:relative;top:1.5px;"><rect x="2" y="4" width="20" height="16" rx="3"/><path d="M2 7l10 7 10-7"/></svg><span data-i18n="emailUs">Email Us</span></a> · © 2026 Wallet Memo<!-- Build 195 --></div>
      </div>
    </main>
    
<!-- build number moved to end of body -->
    </div>

    <script>
      // Prevent pinch-to-zoom on iOS Safari
      document.addEventListener('gesturestart', function(e) { e.preventDefault(); });
      document.addEventListener('gesturechange', function(e) { e.preventDefault(); });
      document.addEventListener('gestureend', function(e) { e.preventDefault(); });

      // ==========================================
      // i18n Translations
      // ==========================================
      const i18n = {
        en: {
          heroTagline: "A sticky note for your Apple Wallet",
          changeColor: "Change Color",
          addStamp: "Add Stamp",
          comingSoon: "Coming soon",
          stickers: "Stickers",
          drawOnNote: "Draw on Note",
          emailUs: "Email Us",
          comingSoonExcl: "Coming soon!",
          placeholders: [
            "Buy oat milk\nText mom\nDon't forget…",
            "Pick up groceries\nCall dentist\nStretch!",
            "Idea: build an app\nResearch competitors\nSketch wireframes",
            "Monday meeting\nBring snacks\nAsk about timeline",
            "Gift ideas:\nNew headphones?\nBook about space",
            "Workout plan\nRun 2 miles\nDrink more water",
            "Movie night picks:\nInterstellar\nEverything Everywhere",
            "Pack for trip\nCharger\nPassport\nSnacks",
            "Learn something new\nWatch a tutorial\nTake notes",
            "Groceries:\nAvocados\nSourdough\nCoffee beans",
            "Weekend plans\nFarmers market\nCook dinner\nRead",
            "Buy it.\nUse it.\nBreak it.\nFix it.",
            "It doesn't have to\nbe done. It just has\nto be perfect.",
            "Drink water.",
            "Send the email.",
            "Stretch for\n30 seconds.\nCount it.",
            "Call dentist.",
            "Don't turn\nOff.",
          ]
        },
        es: {
          heroTagline: "Una nota adhesiva para tu Apple Wallet",
          changeColor: "Cambiar Color",
          addStamp: "Añadir Sello",
          comingSoon: "Próximamente",
          stickers: "Stickers",
          drawOnNote: "Dibujar en Nota",
          emailUs: "Escríbenos",
          comingSoonExcl: "¡Próximamente!",
          placeholders: [
            "Comprar leche\nLlamar a mamá\nNo olvidar…",
            "Ir al súper\nLlamar al dentista\n¡Estirar!",
            "Idea: crear una app\nInvestigar competencia\nHacer bocetos",
            "Reunión del lunes\nLlevar snacks\nPreguntar por plazos",
            "Ideas de regalo:\n¿Audífonos nuevos?\nLibro de espacio",
            "Plan de ejercicio\nCorrer 3 km\nBeber más agua",
            "Noche de pelis:\nInterestelar\nEverything Everywhere",
            "Hacer maleta\nCargador\nPasaporte\nSnacks",
            "Aprender algo nuevo\nVer un tutorial\nTomar notas",
            "Compras:\nAguacates\nPan\nCafé",
            "Planes del finde\nMercado\nCocinar\nLeer",
            "Cómpralo.\nÚsalo.\nRómpelo.\nArréglalo.",
            "No tiene que estar\nterminado. Solo tiene\nque ser perfecto.",
            "Bebe agua.",
            "Envía el correo.",
            "Estira por\n30 segundos.\nCuéntalos.",
            "Llama al dentista.",
            "No te\napagues.",
          ]
        },
        fr: {
          heroTagline: "Un pense-bête pour votre Apple Wallet",
          changeColor: "Changer la Couleur",
          addStamp: "Ajouter un Tampon",
          comingSoon: "Bientôt",
          stickers: "Autocollants",
          drawOnNote: "Dessiner sur la Note",
          emailUs: "Nous Écrire",
          comingSoonExcl: "Bientôt disponible !",
          placeholders: [
            "Acheter du lait\nAppeler maman\nNe pas oublier…",
            "Courses à faire\nAppeler le dentiste\nÉtirements !",
            "Idée : créer une app\nÉtudier la concurrence\nFaire des croquis",
            "Réunion lundi\nApporter des gâteaux\nDemander le planning",
            "Idées cadeaux :\nNouveaux écouteurs ?\nLivre sur l'espace",
            "Programme sport\nCourir 3 km\nBoire plus d'eau",
            "Soirée ciné :\nInterstellar\nEverything Everywhere",
            "Préparer la valise\nChargeur\nPasseport\nSnacks",
            "Apprendre quelque chose\nRegarder un tuto\nPrendre des notes",
            "Courses :\nAvocats\nPain\nGrains de café",
            "Plans du week-end\nMarché\nCuisiner\nLire",
            "Achète-le.\nUtilise-le.\nCasse-le.\nRépare-le.",
            "Ça n'a pas besoin\nd'être fini. Juste\nparfait.",
            "Bois de l'eau.",
            "Envoie le mail.",
            "Étire-toi\n30 secondes.\nCompte-les.",
            "Appelle le dentiste.",
            "Ne t'éteins\npas.",
          ]
        },
        de: {
          heroTagline: "Ein Klebezettel für dein Apple Wallet",
          changeColor: "Farbe Ändern",
          addStamp: "Stempel Hinzufügen",
          comingSoon: "Demnächst",
          stickers: "Sticker",
          drawOnNote: "Auf Notiz Zeichnen",
          emailUs: "Schreib Uns",
          comingSoonExcl: "Demnächst verfügbar!",
          placeholders: [
            "Milch kaufen\nMama anrufen\nNicht vergessen…",
            "Einkaufen gehen\nZahnarzt anrufen\nDehnen!",
            "Idee: App bauen\nWettbewerb analysieren\nSkizzen machen",
            "Meeting am Montag\nSnacks mitbringen\nNach Zeitplan fragen",
            "Geschenkideen:\nNeue Kopfhörer?\nBuch über Weltraum",
            "Trainingsplan\n3 km laufen\nMehr Wasser trinken",
            "Filmabend:\nInterstellar\nEverything Everywhere",
            "Koffer packen\nLadegerät\nReisepass\nSnacks",
            "Etwas Neues lernen\nTutorial schauen\nNotizen machen",
            "Einkaufsliste:\nAvocados\nBrot\nKaffeebohnen",
            "Wochenendpläne\nMarkt\nKochen\nLesen",
            "Kauf es.\nNutz es.\nBrich es.\nFix es.",
            "Es muss nicht\nfertig sein. Nur\nperfekt.",
            "Trink Wasser.",
            "Schick die E-Mail.",
            "Dehne dich\n30 Sekunden.\nZähle mit.",
            "Ruf den Zahnarzt an.",
            "Schalte nicht\nab.",
          ]
        },
        ja: {
          heroTagline: "Apple Walletの付箋メモ",
          changeColor: "色を変更",
          addStamp: "スタンプを追加",
          comingSoon: "近日公開",
          stickers: "ステッカー",
          drawOnNote: "メモに描く",
          emailUs: "メールする",
          comingSoonExcl: "近日公開！",
          placeholders: [
            "牛乳を買う\nお母さんに電話\n忘れないで…",
            "買い物に行く\n歯医者に電話\nストレッチ！",
            "アイデア：アプリを作る\n競合を調査\nワイヤーフレームを描く",
            "月曜の会議\nお菓子を持参\nスケジュールを確認",
            "プレゼントのアイデア：\n新しいヘッドホン？\n宇宙の本",
            "運動計画\n3km走る\nもっと水を飲む",
            "映画ナイト：\nインターステラー\nエブエブ",
            "旅行の準備\n充電器\nパスポート\nお菓子",
            "新しいことを学ぶ\nチュートリアルを見る\nメモを取る",
            "買い物リスト：\nアボカド\nパン\nコーヒー豆",
            "週末の予定\n市場\n料理する\n読書",
            "買う。\n使う。\n壊す。\n直す。",
            "完成しなくていい。\nただ完璧で\nあればいい。",
            "水を飲む。",
            "メールを送る。",
            "30秒\nストレッチ。\n数えて。",
            "歯医者に電話。",
            "消えないで。",
          ]
        },
        zh: {
          heroTagline: "Apple Wallet 的便利贴",
          changeColor: "更换颜色",
          addStamp: "添加印章",
          comingSoon: "即将推出",
          stickers: "贴纸",
          drawOnNote: "在便签上画画",
          emailUs: "发邮件给我们",
          comingSoonExcl: "即将推出！",
          placeholders: [
            "买牛奶\n给妈妈打电话\n别忘了…",
            "去超市\n预约牙医\n做拉伸！",
            "想法：做个App\n研究竞品\n画线框图",
            "周一开会\n带零食\n问进度",
            "礼物清单：\n新耳机？\n太空书籍",
            "健身计划\n跑步3公里\n多喝水",
            "电影之夜：\n星际穿越\n瞬息全宇宙",
            "收拾行李\n充电器\n护照\n零食",
            "学点新东西\n看教程\n做笔记",
            "购物清单：\n牛油果\n面包\n咖啡豆",
            "周末计划\n逛市场\n做饭\n看书",
            "买。\n用。\n坏。\n修。",
            "不需要完成。\n只需要\n完美。",
            "喝水。",
            "发邮件。",
            "拉伸\n30秒。\n数一数。",
            "打电话给牙医。",
            "别关机。",
          ]
        },
        ko: {
          heroTagline: "Apple Wallet을 위한 메모 스티커",
          changeColor: "색상 변경",
          addStamp: "스탬프 추가",
          comingSoon: "곧 출시",
          stickers: "스티커",
          drawOnNote: "메모에 그리기",
          emailUs: "이메일 보내기",
          comingSoonExcl: "곧 출시됩니다!",
          placeholders: [
            "우유 사기\n엄마한테 전화\n잊지 말기…",
            "장보기\n치과 예약\n스트레칭!",
            "아이디어: 앱 만들기\n경쟁사 조사\n와이어프레임 그리기",
            "월요일 회의\n간식 가져가기\n일정 확인",
            "선물 아이디어:\n새 헤드폰?\n우주 관련 책",
            "운동 계획\n3km 달리기\n물 더 마시기",
            "영화 밤:\n인터스텔라\n에브리씽 에브리웨어",
            "여행 짐 싸기\n충전기\n여권\n간식",
            "새로운 것 배우기\n튜토리얼 보기\n메모하기",
            "장보기:\n아보카도\n빵\n커피 원두",
            "주말 계획\n시장 가기\n요리하기\n독서",
            "사라.\n써라.\n부숴라.\n고쳐라.",
            "완성할 필요 없어.\n그냥 완벽하면\n돼.",
            "물 마시기.",
            "이메일 보내기.",
            "30초\n스트레칭.\n세어봐.",
            "치과에 전화.",
            "꺼지지 마.",
          ]
        },
        pt: {
          heroTagline: "Um lembrete para o seu Apple Wallet",
          changeColor: "Mudar Cor",
          addStamp: "Adicionar Carimbo",
          comingSoon: "Em breve",
          stickers: "Adesivos",
          drawOnNote: "Desenhar na Nota",
          emailUs: "Envie um Email",
          comingSoonExcl: "Em breve!",
          placeholders: [
            "Comprar leite\nLigar pra mãe\nNão esquecer…",
            "Ir ao mercado\nLigar pro dentista\nAlongar!",
            "Ideia: criar um app\nPesquisar concorrência\nFazer esboços",
            "Reunião segunda\nLevar lanches\nPerguntar sobre prazos",
            "Ideias de presente:\nFones novos?\nLivro sobre espaço",
            "Plano de treino\nCorrer 3 km\nBeber mais água",
            "Noite de filme:\nInterestelar\nEverything Everywhere",
            "Fazer mala\nCarregador\nPassaporte\nLanches",
            "Aprender algo novo\nVer tutorial\nFazer anotações",
            "Compras:\nAbacates\nPão\nGrãos de café",
            "Planos de fim de semana\nFeira\nCozinhar\nLer",
            "Compre.\nUse.\nQuebre.\nConserte.",
            "Não precisa estar\npronto. Só precisa\nser perfeito.",
            "Beba água.",
            "Envie o email.",
            "Alongue por\n30 segundos.\nConte.",
            "Ligue pro dentista.",
            "Não se\napague.",
          ]
        }
      };

      // Apply language to all translatable elements
      function applyLanguage(lang) {
        const t = i18n[lang] || i18n.en;
        // Set document lang attribute
        document.documentElement.lang = lang;
        // Hero tagline
        const tagline = document.getElementById('hero-tagline');
        if (tagline) tagline.textContent = t.heroTagline;
        // All data-i18n elements
        document.querySelectorAll('[data-i18n]').forEach(el => {
          const key = el.getAttribute('data-i18n');
          if (t[key]) el.textContent = t[key];
        });
        // Textarea placeholder (random from current language)
        const memo = document.getElementById('memo');
        if (memo) memo.placeholder = t.placeholders[Math.floor(Math.random() * t.placeholders.length)];
        // Store globally for new note placeholders
        window._currentI18nLang = lang;
      }

      // Randomize default note placeholder on load
      (function() {
        const ph = [
          "Buy oat milk\nText mom\nDon't forget…",
          "Pick up groceries\nCall dentist\nStretch!",
          "Idea: build an app\nResearch competitors\nSketch wireframes",
          "Monday meeting\nBring snacks\nAsk about timeline",
          "Gift ideas:\nNew headphones?\nBook about space",
          "Workout plan\nRun 2 miles\nDrink more water",
          "Movie night picks:\nInterstellar\nEverything Everywhere",
          "Pack for trip\nCharger\nPassport\nSnacks",
          "Learn something new\nWatch a tutorial\nTake notes",
          "Groceries:\nAvocados\nSourdough\nCoffee beans",
          "Weekend plans\nFarmers market\nCook dinner\nRead",
          "Buy it.\nUse it.\nBreak it.\nFix it.",
          "It doesn't have to\nbe done. It just has\nto be perfect.",
          "Drink water.",
          "Send the email.",
          "Stretch for\n30 seconds.\nCount it.",
          "Call dentist.",
          "Don't turn\nOff.",
        ];
        const memo = document.getElementById('memo');
        if (memo) memo.placeholder = ph[Math.floor(Math.random() * ph.length)];
      })();

      // Language picker and wallet buttons
      (function() {
        const appleImg = document.getElementById('apple-wallet-img');
        const googleImg = document.getElementById('google-wallet-img');
        const langPicker = document.getElementById('lang-picker');
        const langBtn = document.getElementById('lang-btn');
        const langDropdown = document.getElementById('lang-dropdown');
        const langOptions = document.querySelectorAll('.lang-option');
        const currentLangSpan = document.getElementById('current-lang');

        // Map language codes to button locale codes
        const appleLocaleMap = {
          'en': 'EN', 'es': 'ES', 'fr': 'FR', 'de': 'DE', 'ja': 'JP',
          'zh': 'CN', 'ko': 'KR', 'pt': 'PT'
        };

        const googleLocaleMap = {
          'en': 'EN', 'es': 'esES', 'fr': 'FR', 'de': 'DE', 'ja': 'JP',
          'zh': 'zhHK', 'ko': 'KO', 'pt': 'PT'
        };

        const langDisplayMap = {
          'en': 'EN', 'es': 'ES', 'fr': 'FR', 'de': 'DE',
          'ja': 'JA', 'zh': 'ZH', 'ko': 'KO', 'pt': 'PT'
        };

        // Get initial language from browser or localStorage
        let currentLang = localStorage.getItem('walletmemo-lang');
        if (!currentLang) {
          const browserLang = (navigator.language || navigator.userLanguage).split('-')[0];
          currentLang = appleLocaleMap[browserLang] ? browserLang : 'en';
        }

        function updateWalletButtons(lang) {
          const appleLocale = appleLocaleMap[lang] || 'EN';
          const googleLocale = googleLocaleMap[lang] || 'EN';

          appleImg.src = `./assets/wallet-buttons/apple-wallet-buttons/Locale=${appleLocale}.svg`;
          googleImg.src = `./assets/wallet-buttons/google-wallet-buttons/Locale=${googleLocale}, Type=Primary.svg`;

          // Update display
          currentLangSpan.textContent = langDisplayMap[lang] || 'EN';

          // Update active state
          langOptions.forEach(opt => {
            opt.classList.toggle('active', opt.dataset.lang === lang);
          });
        }

        // Fallback to English if locale file doesn't exist
        appleImg.onerror = () => {
          appleImg.src = './assets/wallet-buttons/apple-wallet-buttons/Locale=EN.svg';
        };
        googleImg.onerror = () => {
          googleImg.src = './assets/wallet-buttons/google-wallet-buttons/Locale=EN, Type=Primary.svg';
        };

        // Initialize
        updateWalletButtons(currentLang);
        applyLanguage(currentLang);

        // Toggle dropdown
        langBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          langPicker.classList.toggle('open');
        });

        // Close on outside click
        document.addEventListener('click', () => {
          langPicker.classList.remove('open');
        });

        // Language selection
        langOptions.forEach(opt => {
          opt.addEventListener('click', (e) => {
            e.stopPropagation();
            const lang = opt.dataset.lang;
            currentLang = lang;
            localStorage.setItem('walletmemo-lang', lang);
            updateWalletButtons(lang);
            applyLanguage(lang);
            langPicker.classList.remove('open');
          });
        });

        // Google Wallet - coming soon
        const walletMessage = document.getElementById('wallet-message');
        document.getElementById('google-wallet-btn').addEventListener('click', (e) => {
          e.preventDefault();
          walletMessage.classList.add('visible');
        });
      })();

      // ==========================================
      // Sticky Note Menu & Drawing System
      // ==========================================
      (function() {
        // Elements
        const stickyNote = document.getElementById('sticky-note');
        const menuBtn = document.getElementById('menu-btn');
        const dropdown = document.getElementById('note-dropdown');
        const changeColorBtn = document.getElementById('change-color-btn');
        const colorSubmenu = document.getElementById('color-submenu');
        const colorSwatches = document.querySelectorAll('.color-swatch');
        const addStampBtn = document.getElementById('add-stamp-btn');
        const drawBtn = document.getElementById('draw-btn');
        const colorIcon = document.getElementById('color-icon');
        const noteDrawingLayer = document.getElementById('note-drawing-layer');
        const drawingToolbar = document.getElementById('drawing-toolbar');
        const clearBtn = document.getElementById('clear-drawing');
        const cancelBtn = document.getElementById('cancel-drawing');
        const doneBtn = document.getElementById('done-drawing');

        // Color theme definitions
        const colorThemes = {
          blue: {
            gradient: ['#9DD5EE', '#98C4DA', '#9BC8E7', '#ACD7E9', '#B8E3F3', '#C4E9F5'],
            shadow1: [0.101961, 0.55098, 1],      // Blue tint
            shadow2: [0, 0.334596, 0.608357],     // Blue tint
            shadow3: [0.425615, 0.695906, 0.842314] // Blue edge
          },
          yellow: {
            gradient: ['#D8C453', '#D4B94C', '#DEC75E', '#E8D46E', '#F0DF85', '#F7EA9C'],
            shadow1: [0.92, 0.65, 0.15],          // Orange-yellow tint
            shadow2: [0.7, 0.45, 0.1],            // Orange-yellow tint
            shadow3: [0.9, 0.7, 0.3]              // Orange-yellow edge
          },
          pink: {
            gradient: ['#DCABB5', '#D7A0AA', '#E2B4BD', '#ECC4CC', '#F2D1D8', '#F8DEE3'],
            shadow1: [0.9, 0.55, 0.65],           // Pink tint
            shadow2: [0.6, 0.35, 0.45],           // Pink tint
            shadow3: [0.88, 0.72, 0.78]           // Pink edge
          }
        };

        // Weighted random color selection
        function getRandomColor() {
          const rand = Math.random();
          if (rand < 0.6) return 'blue';      // 60% chance
          if (rand < 0.9) return 'yellow';    // 30% chance
          return 'pink';                       // 10% chance
        }

        let currentColor = getRandomColor();

        // Color icon colors (mid-tone for each theme)
        const colorIconColors = {
          blue: '#B4DCE8',
          yellow: '#E2D060',
          pink: '#E4B8C0'
        };

        // Update note colors dynamically
        function updateNoteColors(colorKey) {
          const theme = colorThemes[colorKey];
          if (!theme) return;

          // Update color icon
          if (colorIcon) {
            colorIcon.style.background = colorIconColors[colorKey];
          }

          // Update gradient stops
          theme.gradient.forEach((color, i) => {
            const stop = document.getElementById(`grad-stop-${i}`);
            if (stop) stop.setAttribute('stop-color', color);
          });

          // Update shadow colors
          const shadow1 = document.getElementById('shadowColor1');
          const shadow2 = document.getElementById('shadowColor2');
          const shadow3 = document.getElementById('shadowColor3');

          if (shadow1) {
            const [r, g, b] = theme.shadow1;
            shadow1.setAttribute('values', `0 0 0 0 ${r} 0 0 0 0 ${g} 0 0 0 0 ${b} 0 0 0 0.15 0`);
          }
          if (shadow2) {
            const [r, g, b] = theme.shadow2;
            shadow2.setAttribute('values', `0 0 0 0 ${r} 0 0 0 0 ${g} 0 0 0 0 ${b} 0 0 0 0.14 0`);
          }
          if (shadow3) {
            const [r, g, b] = theme.shadow3;
            shadow3.setAttribute('values', `0 0 0 0 ${r} 0 0 0 0 ${g} 0 0 0 0 ${b} 0 0 0 1 0`);
          }
        }

        // Note state toggle (click to switch between curled and flat)
        const noteWrapper = document.getElementById('note-wrapper');
        const notePaper = document.getElementById('note-paper');
        const noteShape = document.getElementById('note-shape');
        const noteShadow = document.getElementById('note-shadow');
        let isFlat = false;

        // SVG path points for the two states (matching structure for smooth morphing)
        // Structure: [M, L, C1, C2, C3, L, C1, C2, C3]
        const statePoints = {
          curled: [
            [34.6016, 19.2695],    // M - start
            [250.102, 18.5996],    // L - top right
            [250.102, 18.5996],    // C1 - control 1
            [249.602, 49.0996],    // C2 - control 2
            [257.602, 228.6],      // C3 - end (bottom right)
            [28.6016, 231.1],      // L - bottom left
            [36.6029, 66.5996],    // C1 - control 1
            [34.6016, 19.2695],    // C2 - control 2
            [34.6016, 19.2695]     // C3 - end (back to start)
          ],
          flat: [
            [29, 18],              // M - start
            [258, 18],             // L - top right
            [258, 18],             // C1 - control 1 (on line)
            [258, 125],            // C2 - control 2 (midpoint)
            [258, 232],            // C3 - end (bottom right)
            [29, 232],             // L - bottom left
            [29, 125],             // C1 - control 1 (midpoint)
            [29, 18],              // C2 - control 2 (on line)
            [29, 18]               // C3 - end (back to start)
          ]
        };

        // Convert points array to SVG path string
        function pointsToPath(points) {
          return `M${points[0][0]} ${points[0][1]} L${points[1][0]} ${points[1][1]} C${points[2][0]} ${points[2][1]} ${points[3][0]} ${points[3][1]} ${points[4][0]} ${points[4][1]} L${points[5][0]} ${points[5][1]} C${points[6][0]} ${points[6][1]} ${points[7][0]} ${points[7][1]} ${points[8][0]} ${points[8][1]} Z`;
        }

        // Interpolate between two point arrays
        function lerpPoints(from, to, t) {
          return from.map((point, i) => [
            point[0] + (to[i][0] - point[0]) * t,
            point[1] + (to[i][1] - point[1]) * t
          ]);
        }

        // Easing function (ease-out cubic)
        function easeOutCubic(t) {
          return 1 - Math.pow(1 - t, 3);
        }

        // Animate path morphing
        let animationId = null;
        function animatePath(from, to, duration = 400) {
          if (animationId) cancelAnimationFrame(animationId);

          const startTime = performance.now();

          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutCubic(progress);

            const currentPoints = lerpPoints(from, to, easedProgress);
            noteShape.setAttribute('d', pointsToPath(currentPoints));

            if (progress < 1) {
              animationId = requestAnimationFrame(animate);
            }
          }

          animationId = requestAnimationFrame(animate);
        }

        // Flat gradient colors (more uniform, less dynamic)
        const flatGradients = {
          blue: ['#B3DDEE', '#B3DDEE', '#B3DDEE', '#B8E0F0', '#BDE3F2', '#C2E6F4'],
          yellow: ['#E8D66C', '#E8D66C', '#E8D66C', '#ECDA74', '#EEDC78', '#F2E082'],
          pink: ['#EACAD2', '#EACAD2', '#EACAD2', '#EDCED6', '#F0D0D8', '#F2D4DB']
        };

        // Parse hex color to RGB array
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
          ] : [0, 0, 0];
        }

        // Convert RGB array to hex
        function rgbToHex(r, g, b) {
          return '#' + [r, g, b].map(x => {
            const hex = Math.round(x).toString(16);
            return hex.length === 1 ? '0' + hex : hex;
          }).join('');
        }

        // Animate gradient transition
        let gradientAnimationId = null;
        function animateGradient(toFlat, duration = 400) {
          if (gradientAnimationId) cancelAnimationFrame(gradientAnimationId);

          const theme = colorThemes[currentColor];
          const fromColors = toFlat ? theme.gradient : flatGradients[currentColor];
          const toColors = toFlat ? flatGradients[currentColor] : theme.gradient;

          const fromRgb = fromColors.map(hexToRgb);
          const toRgb = toColors.map(hexToRgb);

          const startTime = performance.now();

          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutCubic(progress);

            fromRgb.forEach((from, i) => {
              const r = from[0] + (toRgb[i][0] - from[0]) * easedProgress;
              const g = from[1] + (toRgb[i][1] - from[1]) * easedProgress;
              const b = from[2] + (toRgb[i][2] - from[2]) * easedProgress;
              const stop = document.getElementById(`grad-stop-${i}`);
              if (stop) stop.setAttribute('stop-color', rgbToHex(r, g, b));
            });

            if (progress < 1) {
              gradientAnimationId = requestAnimationFrame(animate);
            }
          }

          gradientAnimationId = requestAnimationFrame(animate);
        }

        // Initialize lift/stick animations on any note wrapper
        window.initNoteAnimations = function(wrapper, colorKey, noteId, stopElements) {
          const shape = wrapper.querySelector('.note-paper path');
          // Use passed-in stops or query from wrapper
          const stops = stopElements || wrapper.querySelectorAll('svg stop') || [];
          let noteIsFlat = false;
          let noteAnimId = null;
          let noteGradAnimId = null;

          const theme = colorThemes[colorKey];
          const flatGrads = flatGradients[colorKey];

          function animateNotePath(from, to, duration = 400) {
            if (noteAnimId) cancelAnimationFrame(noteAnimId);
            const startTime = performance.now();
            function anim(t) {
              const elapsed = t - startTime;
              const progress = Math.min(elapsed / duration, 1);
              const ep = easeOutCubic(progress);
              const pts = lerpPoints(from, to, ep);
              shape.setAttribute('d', pointsToPath(pts));
              if (progress < 1) noteAnimId = requestAnimationFrame(anim);
            }
            noteAnimId = requestAnimationFrame(anim);
          }

          function animateNoteGradient(toFlat, duration = 400) {
            if (noteGradAnimId) cancelAnimationFrame(noteGradAnimId);
            const fromColors = (toFlat ? theme.gradient : flatGrads).map(hexToRgb);
            const toColors = (toFlat ? flatGrads : theme.gradient).map(hexToRgb);
            const startTime = performance.now();
            function anim(t) {
              const elapsed = t - startTime;
              const progress = Math.min(elapsed / duration, 1);
              const ep = easeOutCubic(progress);
              fromColors.forEach((from, i) => {
                const r = from[0] + (toColors[i][0] - from[0]) * ep;
                const g = from[1] + (toColors[i][1] - from[1]) * ep;
                const b = from[2] + (toColors[i][2] - from[2]) * ep;
                if (stops[i]) stops[i].setAttribute('stop-color', rgbToHex(r, g, b));
              });
              if (progress < 1) noteGradAnimId = requestAnimationFrame(anim);
            }
            noteGradAnimId = requestAnimationFrame(anim);
          }

          wrapper.addEventListener('note:lift', () => {
            if (!noteIsFlat) {
              noteIsFlat = true;
              animateNotePath(statePoints.curled, statePoints.flat);
              animateNoteGradient(true);
              wrapper.classList.add('flat');
            }
          });

          wrapper.addEventListener('note:stick', () => {
            if (noteIsFlat) {
              noteIsFlat = false;
              animateNotePath(statePoints.flat, statePoints.curled);
              animateNoteGradient(false);
              wrapper.classList.remove('flat');
            }
          });

          // Click anywhere on note to focus textarea
          const noteTextarea = wrapper.querySelector('textarea');
          if (noteTextarea) {
            wrapper.addEventListener('click', (e) => {
              if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown')) return;
              noteTextarea.focus();
            });

            noteTextarea.addEventListener('focus', () => {
              if (!noteIsFlat) {
                noteIsFlat = true;
                animateNotePath(statePoints.curled, statePoints.flat);
                animateNoteGradient(true);
                wrapper.classList.add('flat');
                wrapper.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                const current = wrapper.style.transform || '';
                const base = current.replace(/scale\([^)]*\)/g, '').trim();
                wrapper.style.transform = (base ? base + ' ' : '') + 'scale(1.1)';
              }
            });

            noteTextarea.addEventListener('blur', () => {
              if (noteIsFlat) {
                noteIsFlat = false;
                animateNotePath(statePoints.flat, statePoints.curled);
                animateNoteGradient(false);
                wrapper.classList.remove('flat');
                const current = wrapper.style.transform || '';
                wrapper.style.transform = current.replace(/scale\([^)]*\)/g, '').trim();
              }
            });
          }
        };

        // Get textarea element
        const textarea = document.getElementById('memo');

        // Tap anywhere on the note to focus textarea (fixes mobile double-tap)
        noteWrapper.addEventListener('click', (e) => {
          // Don't steal clicks from menu, dropdown, or drawing layer
          if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown') || e.target.closest('.drawing-toolbar')) return;
          textarea.focus();
        });

        // Calculate mobile scale so note fills width
        function updateMobileLayout() {
          if (window.innerWidth > 600) return; // Desktop doesn't need this
          const noteWidth = noteWrapper.offsetWidth || 320;
          const baseScale = (window.innerWidth - 16) / noteWidth;
          document.documentElement.style.setProperty('--mobile-note-scale', baseScale.toFixed(3));
          // Focused state is bigger than base
          document.documentElement.style.setProperty('--mobile-note-focus-scale', (baseScale * 1.08).toFixed(3));
        }
        updateMobileLayout();
        window.addEventListener('resize', updateMobileLayout);

        // Mobile: touchend for immediate focus without double-tap
        noteWrapper.addEventListener('touchend', (e) => {
          if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown') || e.target.closest('.drawing-toolbar')) return;
          if (noteWrapper.classList.contains('drawing-mode')) return;
          e.preventDefault();
          textarea.focus({ preventScroll: true });
        });

        // Focus/blur on textarea triggers the flat/curled animation
        const focusOverlay = document.getElementById('focus-overlay');
        const langPicker2 = document.getElementById('lang-picker');
        // Custom events for external code (e.g., drag) to trigger flat/curl
        noteWrapper.addEventListener('note:lift', () => {
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            noteWrapper.classList.add('flat');
          }
        });

        noteWrapper.addEventListener('note:stick', () => {
          if (isFlat) {
            isFlat = false;
            animatePath(statePoints.flat, statePoints.curled);
            animateGradient(false);
            noteWrapper.classList.remove('flat');
          }
        });

        textarea.addEventListener('focus', () => {
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            noteShadow.src = './assets/paper-stuff/shadow-layer-two.svg';
            noteWrapper.classList.add('flat');
            noteWrapper.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
            const current = noteWrapper.style.transform || '';
            const base = current.replace(/scale\([^)]*\)/g, '').replace(/translateY\([^)]*\)/g, '').trim();
            const isMobileView = window.innerWidth <= 600;
            const mobileScale = getComputedStyle(document.documentElement).getPropertyValue('--mobile-note-focus-scale') || '1.15';
            if (isMobileView) {
              noteWrapper.style.transform = (base ? base + ' ' : '') + 'scale(' + mobileScale + ') translateY(-100px)';
            } else {
              noteWrapper.style.transform = (base ? base + ' ' : '') + 'scale(1.1)';
            }
            focusOverlay.classList.add('active');
            langPicker2.classList.add('hidden');
          }
        });

        textarea.addEventListener('blur', () => {
          // Don't close note when entering drawing mode
          if (isDrawingMode) return;
          if (isFlat) {
            isFlat = false;
            animatePath(statePoints.flat, statePoints.curled);
            animateGradient(false);
            noteShadow.src = './assets/paper-stuff/shadow-layer.svg';
            noteWrapper.classList.remove('flat');
            const current = noteWrapper.style.transform || '';
            noteWrapper.style.transform = current.replace(/scale\([^)]*\)/g, '').replace(/translateY\([^)]*\)/g, '').trim();
            focusOverlay.classList.remove('active');
            langPicker2.classList.remove('hidden');
          }
        });

        // Menu toggle
        // Prevent menu/dropdown from stealing focus from textarea
        menuBtn.addEventListener('mousedown', (e) => e.preventDefault());
        dropdown.addEventListener('mousedown', (e) => e.preventDefault());
        menuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          menuBtn.classList.toggle('active');
          dropdown.classList.toggle('open');
          // Re-focus textarea so note stays in focused state
          if (isFlat) textarea.focus({ preventScroll: true });
          // Clamp dropdown to viewport
          if (dropdown.classList.contains('open')) {
            requestAnimationFrame(() => {
              const rect = dropdown.getBoundingClientRect();
              if (rect.right > window.innerWidth) {
                const overflow = rect.right - window.innerWidth + 8;
                dropdown.style.right = (8 + overflow) + 'px';
              } else {
                dropdown.style.right = '';
              }
            });
          } else {
            dropdown.style.right = '';
          }
        });

        // Close menu when clicking/tapping outside
        function closeMenuOutside(e) {
          if (!dropdown.contains(e.target) && !menuBtn.contains(e.target)) {
            dropdown.classList.remove('open');
            menuBtn.classList.remove('active');
            colorSubmenu.classList.remove('open');
          }
        }
        document.addEventListener('click', closeMenuOutside);
        document.addEventListener('touchstart', closeMenuOutside);

        // Color change functionality
        changeColorBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          colorSubmenu.classList.toggle('open');
        });

        colorSwatches.forEach(swatch => {
          swatch.addEventListener('click', (e) => {
            e.stopPropagation();
            const colorKey = swatch.dataset.color;
            currentColor = colorKey;
            updateNoteColors(colorKey);

            // Clear drawing when color changes (drawing is tied to note color)
            if (drawingCtx) {
              drawingCtx.clearRect(0, 0, noteDrawingLayer.width, noteDrawingLayer.height);
            }

            // Update active state
            colorSwatches.forEach(s => s.classList.remove('active'));
            swatch.classList.add('active');

            // Close menu
            dropdown.classList.remove('open');
            menuBtn.classList.remove('active');
            colorSubmenu.classList.remove('open');
          });
        });

        // Add stamp (placeholder)
        addStampBtn.addEventListener('click', () => {
          alert('Stamp feature coming soon!');
          dropdown.classList.remove('open');
          menuBtn.classList.remove('active');
        });

        // ==========================================
        // Drawing Mode (draws directly on note)
        // ==========================================
        let isDrawingMode = false;
        let drawingCtx = null;
        let isDrawing = false;
        let savedImageData = null;

        // Initialize note drawing layer
        function initNoteDrawingLayer() {
          noteDrawingLayer.width = stickyNote.offsetWidth * 2;
          noteDrawingLayer.height = stickyNote.offsetHeight * 2;
          drawingCtx = noteDrawingLayer.getContext('2d');
          drawingCtx.scale(2, 2);
          drawingCtx.lineCap = 'round';
          drawingCtx.lineJoin = 'round';
          drawingCtx.strokeStyle = 'rgba(26, 26, 26, 0.9)';
          drawingCtx.lineWidth = 4;
        }
        
        // Pen settings
        let currentPenColor = 'rgba(26, 26, 26, 0.9)';
        let currentPenSize = 4;

        initNoteDrawingLayer();

        // Open drawing mode
        drawBtn.addEventListener('click', () => {
          dropdown.classList.remove('open');
          menuBtn.classList.remove('active');

          isDrawingMode = true;

          // Save current drawing state for cancel
          savedImageData = drawingCtx.getImageData(0, 0, noteDrawingLayer.width, noteDrawingLayer.height);

          // Put note in flat state
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            noteShadow.src = './assets/paper-stuff/shadow-layer-two.svg';
            noteWrapper.classList.add('flat');
          }

          // Hide keyboard but keep note open
          // Temporarily prevent blur from closing the note
          isDrawingMode = true; // already set above, but ensures blur check works
          textarea.blur();
          // Re-assert flat state since blur removes it
          isFlat = true;
          noteWrapper.classList.add('flat');
          focusOverlay.classList.add('active');
          langPicker2.classList.add('hidden');

          // Enable drawing mode
          document.body.classList.add('drawing-mode-active');
          noteWrapper.classList.add('drawing-mode');
        });

        // Drawing on canvas
        noteDrawingLayer.addEventListener('pointerdown', (e) => {
          if (!isDrawingMode) return;
          isDrawing = true;
          const rect = noteDrawingLayer.getBoundingClientRect();
          const scaleX = noteDrawingLayer.width / rect.width / 2;
          const scaleY = noteDrawingLayer.height / rect.height / 2;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          drawingCtx.beginPath();
          drawingCtx.moveTo(x, y);
        });

        noteDrawingLayer.addEventListener('pointermove', (e) => {
          if (!isDrawingMode || !isDrawing) return;

          const rect = noteDrawingLayer.getBoundingClientRect();
          const scaleX = noteDrawingLayer.width / rect.width / 2;
          const scaleY = noteDrawingLayer.height / rect.height / 2;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          drawingCtx.lineTo(x, y);
          drawingCtx.stroke();
          drawingCtx.beginPath();
          drawingCtx.moveTo(x, y);
        });

        noteDrawingLayer.addEventListener('pointerup', () => {
          isDrawing = false;
        });

        noteDrawingLayer.addEventListener('pointerleave', () => {
          isDrawing = false;
        });

        // Clear drawing
        clearBtn.addEventListener('click', () => {
          drawingCtx.clearRect(0, 0, noteDrawingLayer.width, noteDrawingLayer.height);
        });

        // Cancel drawing - restore previous state
        cancelBtn.addEventListener('click', () => {
          if (savedImageData) {
            drawingCtx.putImageData(savedImageData, 0, 0);
          }
          closeDrawingMode();
        });

        // Done drawing
        doneBtn.addEventListener('click', () => {
          closeDrawingMode();
        });

        function closeDrawingMode() {
          isDrawingMode = false;
          isDrawing = false;
          savedImageData = null;
          document.body.classList.remove('drawing-mode-active');
          noteWrapper.classList.remove('drawing-mode');
          // Return to initial closed state
          if (isFlat) {
            isFlat = false;
            animatePath(statePoints.flat, statePoints.curled);
            animateGradient(false);
            noteShadow.src = './assets/paper-stuff/shadow-layer.svg';
            noteWrapper.classList.remove('flat');
            const current = noteWrapper.style.transform || '';
            noteWrapper.style.transform = current.replace(/scale\([^)]*\)/g, '').replace(/translateY\([^)]*\)/g, '').trim();
            focusOverlay.classList.remove('active');
            langPicker2.classList.remove('hidden');
          }
          textarea.blur();
          // Force Safari to re-render the SVG filter/shadow (fixes rectangular artifact)
          requestAnimationFrame(() => {
            const notePaperEl = noteWrapper.querySelector('.note-paper');
            if (notePaperEl) {
              // Toggle will-change to force compositing layer reset
              notePaperEl.style.willChange = 'transform';
              requestAnimationFrame(() => {
                notePaperEl.style.willChange = '';
              });
            }
            // Also force the note-wrapper to re-composite
            noteWrapper.style.willChange = 'transform';
            requestAnimationFrame(() => {
              noteWrapper.style.willChange = '';
            });
          });
        }

        // Pen color picker
        document.querySelectorAll('.pen-color').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.pen-color').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const rgb = btn.dataset.color;
            currentPenColor = `rgba(${rgb}, 0.9)`;
            if (drawingCtx) drawingCtx.strokeStyle = currentPenColor;
          });
        });

        // Pen size picker
        document.querySelectorAll('.pen-size').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.pen-size').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentPenSize = parseInt(btn.dataset.size);
            if (drawingCtx) drawingCtx.lineWidth = currentPenSize;
          });
        });

        // Handle window resize
        window.addEventListener('resize', () => {
          initNoteDrawingLayer();
        });

        // Apply random color on load and update active swatch
        updateNoteColors(currentColor);
        colorSwatches.forEach(s => {
          s.classList.toggle('active', s.dataset.color === currentColor);
        });

        // ==========================================
        // Apple Wallet Pass Generation
        // ==========================================
        const appleWalletBtn = document.getElementById('apple-wallet-btn');
        const walletMsg = document.getElementById('wallet-message');
        const walletQr = document.getElementById('wallet-qr');
        let qrVisible = false;

        // Detect if user is on mobile (iOS/Android)
        function isMobile() {
          return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        }

        appleWalletBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          // Get note content
          const text = document.getElementById('memo').value;
          
          // Get drawing data - always send canvas (backend handles empty gracefully)
          const drawingDataUrl = noteDrawingLayer.toDataURL('image/png');

          const BACKEND_URL = 'https://sandbox-staging.up.railway.app';

          if (!isMobile()) {
            // Desktop: toggle QR code inside the button
            if (qrVisible) {
              appleWalletBtn.classList.remove('qr-open');
              setTimeout(() => { walletQr.innerHTML = ''; }, 400);
              qrVisible = false;
              return;
            }

            // Encode memo data in URL params
            const params = new URLSearchParams({
              t: btoa(unescape(encodeURIComponent(text || ''))),
              c: currentColor,
              d: drawingDataUrl.length > 1000 ? '1' : '0'
            });
            const passUrl = `${BACKEND_URL}/api/pass-redirect?${params.toString()}`;
            
            try {
              const qr = qrcode(0, 'M');
              qr.addData(passUrl);
              qr.make();
              // Create image from data URL, match button width
              const btnImg = document.getElementById('apple-wallet-img');
              const btnWidth = btnImg ? btnImg.offsetWidth : 120;
              const img = document.createElement('img');
              img.src = qr.createDataURL(4, 4);
              img.style.width = '100%';
              img.style.height = 'auto';
              img.style.display = 'block';
              const qrInner = document.createElement('div');
              qrInner.style.cssText = 'background:#fff;border-radius:6px;padding:8px;width:100%;box-sizing:border-box;';
              qrInner.appendChild(img);
              walletQr.innerHTML = '';
              walletQr.appendChild(qrInner);
              appleWalletBtn.classList.add('qr-open');
              qrVisible = true;
            } catch (err) {
              console.error('QR generation failed:', err);
              alert('QR Error: ' + err.message);
            }
            return;
          }
          
          // Mobile: download pass directly
          const originalContent = appleWalletBtn.innerHTML;
          appleWalletBtn.style.opacity = '0.6';
          appleWalletBtn.style.pointerEvents = 'none';
          
          try {
            const response = await fetch(`${BACKEND_URL}/api/generate-pass`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                text: text,
                color: currentColor,
                drawingDataUrl: drawingDataUrl
              })
            });
            
            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.error || 'Failed to generate pass');
            }
            
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            window.location.href = url;
            
          } catch (error) {
            console.error('Error:', error);
            walletMsg.textContent = error.message.includes('fetch') 
              ? 'Backend not running. Start the server first!'
              : error.message;
            walletMsg.classList.add('visible');
            setTimeout(() => walletMsg.classList.remove('visible'), 3000);
          } finally {
            appleWalletBtn.style.opacity = '1';
            appleWalletBtn.style.pointerEvents = 'auto';
          }
        });
      })();

      // Desktop drag-to-move sticky note + "add new" pad
      (function() {
        if ('ontouchstart' in window) return; // Skip on mobile

        const mainArea = document.querySelector('main') || document.querySelector('.content-wrapper');
        const wrapper = document.getElementById('note-wrapper');
        const dragZoneHeight = 48;
        let noteCounter = 0;
        let hasMoved = false;

        // Create the "add new note" button that sits behind the note
        const addBtn = document.createElement('div');
        addBtn.className = 'add-note-btn';
        addBtn.innerHTML = '<i class="hgi-stroke hgi-add-01"></i>';
        addBtn.style.display = 'none';
        wrapper.parentElement.insertBefore(addBtn, wrapper);

        function makeDraggable(el) {
          let isDragging = false;
          let startX, startY, origX = 0, origY = 0;
          let offsetX = 0, offsetY = 0;

          el.addEventListener('mousemove', (e) => {
            if (isDragging) return;
            const rect = el.getBoundingClientRect();
            const relY = e.clientY - rect.top;
            if (relY < dragZoneHeight && !e.target.closest('.note-menu-btn') && !e.target.closest('.note-dropdown')) {
              el.style.cursor = 'grab';
            } else {
              el.style.cursor = '';
            }
          });

          el.addEventListener('mousedown', (e) => {
            const rect = el.getBoundingClientRect();
            const relY = e.clientY - rect.top;
            if (relY >= dragZoneHeight) return;
            if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown')) return;

            e.preventDefault();
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            origX = offsetX;
            origY = offsetY;
            el.style.cursor = 'grabbing';
            el.style.transition = 'none';
            el.style.zIndex = String(50 + noteCounter);
            // Lift off the wall - go flat
            el.classList.add('flat');
            el.dispatchEvent(new Event('note:lift'));
            el.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(1.03) rotate(3deg)`;
            // Show add button immediately on grab
            if (!hasMoved) {
              hasMoved = true;
              addBtn.style.display = 'flex';
            }
          });

          document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            offsetX = origX + dx;
            offsetY = origY + dy;
            el.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(1.03) rotate(3deg)`;
          });

          document.addEventListener('mouseup', () => {
            if (!isDragging) return;
            isDragging = false;
            el.style.cursor = 'grab';
            el.style.transition = '';
            // Stick back to wall - remove flat, go back to curled
            el.classList.remove('flat');
            el.dispatchEvent(new Event('note:stick'));
            el.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            const ta = el.querySelector('textarea');
            if (ta) ta.blur();
            // Suppress the click event that fires after mouseup
            // so it doesn't re-focus the textarea and flatten the note
            el.addEventListener('click', function suppressClick(evt) {
              evt.stopPropagation();
              evt.preventDefault();
              el.removeEventListener('click', suppressClick, true);
            }, true);
          });
        }

        makeDraggable(wrapper);

        // Add new note button
        const placeholders = [
          "Pick up groceries\nCall dentist\nStretch!",
          "Idea: build an app\nResearch competitors\nSketch wireframes",
          "Monday meeting\nBring snacks\nAsk about timeline",
          "Gift ideas:\nNew headphones?\nBook about space",
          "Workout plan\nRun 2 miles\nDrink more water",
          "Movie night picks:\nInterstellar\nEverything Everywhere",
          "Pack for trip\nCharger\nPassport\nSnacks",
          "Learn something new\nWatch a tutorial\nTake notes",
          "Groceries:\nAvocados\nSourdough\nCoffee beans",
          "Weekend plans\nFarmers market\nCook dinner\nRead",
          "Buy it.\nUse it.\nBreak it.\nFix it.",
          "It doesn't have to\nbe done. It just has\nto be perfect.",
          "Drink water.",
          "Send the email.",
          "Stretch for\n30 seconds.\nCount it.",
          "Call dentist.",
          "Don't turn\nOff.",
        ];

        addBtn.addEventListener('click', () => {
          noteCounter++;
          const colors = ['blue', 'yellow', 'pink'];
          const color = colors[noteCounter % 3];

          // Color configs (gradient + shadow colors per theme)
          const colorMap = {
            blue: ['#9DD5EE', '#98C4DA', '#9BC8E7', '#ACD7E9', '#B8E3F3', '#C4E9F5'],
            yellow: ['#D8C453', '#D4B94C', '#DEC75E', '#E8D46E', '#F0DF85', '#F7EA9C'],
            pink: ['#DCABB5', '#D7A0AA', '#E2B4BD', '#ECC4CC', '#F2D1D8', '#F8DEE3']
          };
          const shadowMap = {
            blue: {
              s1: '0 0 0 0 0.101961 0 0 0 0 0.55098 0 0 0 0 1 0 0 0 0.15 0',
              s2: '0 0 0 0 0 0 0 0 0 0.334596 0 0 0 0 0.608357 0 0 0 0.14 0',
              s3: '0 0 0 0 0.425615 0 0 0 0 0.695906 0 0 0 0 0.842314 0 0 0 1 0'
            },
            yellow: {
              s1: '0 0 0 0 0.92 0 0 0 0 0.65 0 0 0 0 0.15 0 0 0 0.15 0',
              s2: '0 0 0 0 0.7 0 0 0 0 0.45 0 0 0 0 0.1 0 0 0 0.14 0',
              s3: '0 0 0 0 0.9 0 0 0 0 0.7 0 0 0 0 0.3 0 0 0 1 0'
            },
            pink: {
              s1: '0 0 0 0 0.9 0 0 0 0 0.55 0 0 0 0 0.65 0 0 0 0.15 0',
              s2: '0 0 0 0 0.6 0 0 0 0 0.35 0 0 0 0 0.45 0 0 0 0.14 0',
              s3: '0 0 0 0 0.88 0 0 0 0 0.72 0 0 0 0 0.78 0 0 0 1 0'
            }
          };
          const g = colorMap[color];
          const s = shadowMap[color];

          const newWrapper = document.createElement('div');
          newWrapper.className = 'note-wrapper dragged-note';
          newWrapper.style.position = 'absolute';
          newWrapper.style.top = wrapper.offsetTop + 'px';
          newWrapper.style.left = wrapper.offsetLeft + 'px';
          newWrapper.style.width = '360px';
          newWrapper.style.height = '340px';
          newWrapper.style.zIndex = String(10 + noteCounter);

          // Use DOMParser to create proper SVG namespace elements
          const svgMarkup = `<svg class="note-paper" width="287" height="270" viewBox="0 0 287 270" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g filter="url(#nf${noteCounter})">
                <path d="M34.6016 19.2695L250.102 18.5996C250.102 18.5996 249.602 49.0996 257.602 228.6L28.6016 231.1C36.6029 66.5996 34.6016 19.2695 34.6016 19.2695Z" fill="url(#ng${noteCounter})"/>
              </g>
              <defs>
                <linearGradient id="ng${noteCounter}" x1="153.102" y1="231.1" x2="143.601" y2="18.5996" gradientUnits="userSpaceOnUse">
                  <stop stop-color="${g[0]}"/>
                  <stop offset="0.255906" stop-color="${g[1]}"/>
                  <stop offset="0.812358" stop-color="${g[2]}"/>
                  <stop offset="0.864881" stop-color="${g[3]}"/>
                  <stop offset="0.954264" stop-color="${g[4]}"/>
                  <stop offset="1" stop-color="${g[5]}"/>
                </linearGradient>
                <filter id="nf${noteCounter}" x="0.00156212" y="-0.000391006" width="286.2" height="269.7" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
                  <feFlood flood-opacity="0" result="BackgroundImageFix"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
                  <feOffset/>
                  <feGaussianBlur stdDeviation="5.14583"/>
                  <feColorMatrix type="matrix" values="${s.s1}"/>
                  <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
                  <feOffset dy="10"/>
                  <feGaussianBlur stdDeviation="14.3"/>
                  <feColorMatrix type="matrix" values="${s.s2}"/>
                  <feBlend mode="normal" in2="effect1_dropShadow" result="effect2_dropShadow"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
                  <feOffset dy="0.2"/>
                  <feComposite in2="hardAlpha" operator="out"/>
                  <feColorMatrix type="matrix" values="${s.s3}"/>
                  <feBlend mode="normal" in2="effect2_dropShadow" result="effect3_dropShadow"/>
                  <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
                  <feTurbulence type="fractalNoise" baseFrequency="1.6666666269302368 1.6666666269302368" stitchTiles="stitch" numOctaves="3" result="noise" seed="${6167 + noteCounter}"/>
                  <feComponentTransfer in="noise" result="coloredNoise1">
                    <feFuncR type="linear" slope="2" intercept="-0.5"/>
                    <feFuncG type="linear" slope="2" intercept="-0.5"/>
                    <feFuncB type="linear" slope="2" intercept="-0.5"/>
                    <feFuncA type="discrete" tableValues="1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"/>
                  </feComponentTransfer>
                  <feComposite operator="in" in2="shape" in="coloredNoise1" result="noise1Clipped"/>
                  <feComponentTransfer in="noise1Clipped" result="color1">
                    <feFuncA type="table" tableValues="0 0.06"/>
                  </feComponentTransfer>
                  <feMerge result="effect4_noise">
                    <feMergeNode in="shape"/>
                    <feMergeNode in="color1"/>
                  </feMerge>
                  <feBlend mode="normal" in="effect4_noise" in2="effect3_dropShadow" result="effect4_noise"/>
                </filter>
              </defs>
            </svg>`;
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(svgMarkup, 'image/svg+xml');
          const svgNode = document.adoptNode(svgDoc.documentElement);
          
          const noteDiv = document.createElement('div');
          noteDiv.className = 'note';
          noteDiv.style.cssText = 'width:360px;height:340px;padding:48px 57px;position:absolute;top:0;left:0;z-index:2;display:flex;flex-direction:column;justify-content:center;';
          const ta = document.createElement('textarea');
          ta.className = 'textarea';
          ta.maxLength = 140;
          ta.style.cssText = "font-family:'Patrick Hand',cursive;font-size:20px;line-height:1.5;color:#1a1a1a;border:none;background:transparent;resize:none;outline:none;text-align:center;width:100%;overflow:hidden;";
          noteDiv.appendChild(ta);
          
          // Add shadow layer (same as original note)
          const shadowImg = document.createElement('img');
          shadowImg.src = './assets/paper-stuff/shadow-layer.svg';
          shadowImg.className = 'note-shadow';
          shadowImg.alt = '';
          newWrapper.appendChild(shadowImg);
          newWrapper.appendChild(svgNode);
          newWrapper.appendChild(noteDiv);

          wrapper.parentElement.insertBefore(newWrapper, addBtn);
          // Set random placeholder
          if (ta) ta.placeholder = placeholders[Math.floor(Math.random() * placeholders.length)];
          makeDraggable(newWrapper);
          // Get stops from the properly-namespaced SVG
          const noteStops = svgNode.querySelectorAll('stop');
          initNoteAnimations(newWrapper, color, noteCounter, noteStops);

          // Hide add button until this new one is dragged
          hasMoved = false;
          addBtn.style.display = 'none';
        });
      })();
    </script>
  </body>
</html>
