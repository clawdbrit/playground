<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Wallet Memo</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.hugeicons.com/font/hgi-stroke-rounded.css">
    <link rel="stylesheet" href="./style.css" />
          <!-- GoatCounter analytics -->
    <script data-goatcounter="https://walletmemo.goatcounter.com/count"
            async src="//gc.zgo.at/count.js"></script>
  </head>
  <body>
    <div class="focus-overlay" id="focus-overlay"></div>
    <!-- Language picker -->
    <div class="lang-picker" id="lang-picker">
      <button class="lang-btn" id="lang-btn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <circle cx="12" cy="12" r="10"/>
          <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
        </svg>
        <span id="current-lang">EN</span>
        <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M6 9l6 6 6-6"/>
        </svg>
      </button>
      <div class="lang-dropdown" id="lang-dropdown">
        <button class="lang-option" data-lang="en">English</button>
        <button class="lang-option" data-lang="es">Español</button>
        <button class="lang-option" data-lang="fr">Français</button>
        <button class="lang-option" data-lang="de">Deutsch</button>
        <button class="lang-option" data-lang="ja">日本語</button>
        <button class="lang-option" data-lang="zh">中文</button>
        <button class="lang-option" data-lang="ko">한국어</button>
        <button class="lang-option" data-lang="pt">Português</button>
      </div>
    </div>

    <div class="content-group">
      <div class="hero-text">
        <div class="hero-title">Wallet Memo</div>
        <div class="hero-tagline">A sticky note for your Apple Wallet</div>
      </div>

      <main class="container">
      <div class="note-wrapper" id="note-wrapper">
        <!-- Shadow layer (behind note) -->
        <img src="./assets/paper-stuff/shadow-layer.svg" class="note-shadow" id="note-shadow" alt="">
        <!-- Sticky note SVG - inlined for dynamic color updates -->
        <svg class="note-paper" id="note-paper" data-state="one" width="287" height="270" viewBox="0 0 287 270" fill="none" xmlns="http://www.w3.org/2000/svg">
          <g filter="url(#noteFilter)">
            <path id="note-shape" d="M34.6016 19.2695L250.102 18.5996C250.102 18.5996 249.602 49.0996 257.602 228.6L28.6016 231.1C36.6029 66.5996 34.6016 19.2695 34.6016 19.2695Z" fill="url(#noteGradient)"/>
          </g>
          <defs>
            <filter id="noteFilter" x="0.00156212" y="-0.000391006" width="286.2" height="269.7" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
              <feFlood flood-opacity="0" result="BackgroundImageFix"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset/>
              <feGaussianBlur stdDeviation="5.14583"/>
              <feColorMatrix id="shadowColor1" type="matrix" values="0 0 0 0 0.101961 0 0 0 0 0.55098 0 0 0 0 1 0 0 0 0 0"/>
              <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset dy="10"/>
              <feGaussianBlur stdDeviation="14.3"/>
              <feColorMatrix id="shadowColor2" type="matrix" values="0 0 0 0 0 0 0 0 0 0.334596 0 0 0 0 0.608357 0 0 0 0 0"/>
              <feBlend mode="normal" in2="effect1_dropShadow" result="effect2_dropShadow"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset dy="0.2"/>
              <feComposite in2="hardAlpha" operator="out"/>
              <feColorMatrix id="shadowColor3" type="matrix" values="0 0 0 0 0.425615 0 0 0 0 0.695906 0 0 0 0 0.842314 0 0 0 1 0"/>
              <feBlend mode="normal" in2="effect2_dropShadow" result="effect3_dropShadow"/>
              <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
              <feTurbulence type="fractalNoise" baseFrequency="1.6666666269302368 1.6666666269302368" stitchTiles="stitch" numOctaves="3" result="noise" seed="6167"/>
              <feComponentTransfer in="noise" result="coloredNoise1">
                <feFuncR type="linear" slope="2" intercept="-0.5"/>
                <feFuncG type="linear" slope="2" intercept="-0.5"/>
                <feFuncB type="linear" slope="2" intercept="-0.5"/>
                <feFuncA type="discrete" tableValues="1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"/>
              </feComponentTransfer>
              <feComposite operator="in" in2="shape" in="coloredNoise1" result="noise1Clipped"/>
              <feComponentTransfer in="noise1Clipped" result="color1">
                <feFuncA type="table" tableValues="0 0.06"/>
              </feComponentTransfer>
              <feMerge result="effect4_noise">
                <feMergeNode in="shape"/>
                <feMergeNode in="color1"/>
              </feMerge>
              <feBlend mode="normal" in="effect4_noise" in2="effect3_dropShadow" result="effect4_noise"/>
            </filter>
            <linearGradient id="noteGradient" x1="153.102" y1="231.1" x2="143.601" y2="18.5996" gradientUnits="userSpaceOnUse">
              <stop id="grad-stop-0" stop-color="#9DD5EE"/>
              <stop id="grad-stop-1" offset="0.255906" stop-color="#98C4DA"/>
              <stop id="grad-stop-2" offset="0.812358" stop-color="#9BC8E7"/>
              <stop id="grad-stop-3" offset="0.864881" stop-color="#ACD7E9"/>
              <stop id="grad-stop-4" offset="0.954264" stop-color="#B8E3F3"/>
              <stop id="grad-stop-5" offset="1" stop-color="#C4E9F5"/>
            </linearGradient>
          </defs>
        </svg>
        <div class="note" id="sticky-note">
          <!-- Ellipsis menu button -->
          <button class="note-menu-btn" id="menu-btn">
            <svg viewBox="0 0 24 24">
              <circle cx="12" cy="5" r="2"/>
              <circle cx="12" cy="12" r="2"/>
              <circle cx="12" cy="19" r="2"/>
            </svg>
          </button>

          <!-- Dropdown menu -->
          <div class="note-dropdown" id="note-dropdown">
            <button class="dropdown-item" id="change-color-btn">
              <span class="color-icon" id="color-icon"></span>
              Change Color
            </button>
            <div class="color-submenu" id="color-submenu">
              <div class="color-swatch" data-color="blue" style="background: #B4DCE8;"></div>
              <div class="color-swatch" data-color="yellow" style="background: #EAD264;"></div>
              <div class="color-swatch" data-color="pink" style="background: #ECBDC5;"></div>
            </div>
            <button class="dropdown-item" id="add-stamp-btn" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="11" width="18" height="10" rx="2"/>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
              </svg>
              Add Stamp <span class="coming-soon-tag">Coming soon</span>
            </button>
            <button class="dropdown-item" id="add-sticker-btn" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                <line x1="9" y1="9" x2="9.01" y2="9"/>
                <line x1="15" y1="9" x2="15.01" y2="9"/>
              </svg>
              Stickers <span class="coming-soon-tag">Coming soon</span>
            </button>
            <button class="dropdown-item" id="draw-btn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                <path d="M2 2l7.586 7.586"/>
              </svg>
              Draw on Note
            </button>
          </div>

          <!-- Drawing layer for finished drawings -->
          <canvas class="note-drawing-layer" id="note-drawing-layer"></canvas>

          <textarea
            id="memo"
            class="textarea"
            placeholder=""
            maxlength="140"
          ></textarea>
        </div>
        <!-- Drawing toolbar -->
        <div class="drawing-toolbar" id="drawing-toolbar">
          <div class="pen-colors">
            <button class="pen-color active" data-color="26,26,26" style="background:#1a1a1a"></button>
            <button class="pen-color" data-color="229,57,53" style="background:#e53935"></button>
            <button class="pen-color" data-color="30,136,229" style="background:#1e88e5"></button>
            <button class="pen-color" data-color="67,160,71" style="background:#43a047"></button>
            <button class="pen-color" data-color="142,36,170" style="background:#8e24aa"></button>
          </div>
          <div class="pen-sizes">
            <button class="pen-size" data-size="1"><span style="width:4px;height:4px"></span></button>
            <button class="pen-size active" data-size="2"><span style="width:6px;height:6px"></span></button>
            <button class="pen-size" data-size="4"><span style="width:10px;height:10px"></span></button>
            <button class="pen-size" data-size="6"><span style="width:14px;height:14px"></span></button>
          </div>
          <div class="pen-actions">
            <button class="toolbar-btn clear" id="clear-drawing"><i class="hgi-stroke hgi-delete-02"></i></button>
            <button class="toolbar-btn cancel" id="cancel-drawing">Cancel</button>
            <button class="toolbar-btn done" id="done-drawing">Done</button>
          </div>
        </div>
      </div>

      <div class="wallet-wrapper">
        <div class="wallet-buttons">
          <a href="#" class="wallet-btn-link" id="apple-wallet-btn">
            <img id="apple-wallet-img" src="./assets/wallet-buttons/apple-wallet-buttons/Locale=EN.svg" alt="Add to Apple Wallet">
          </a>
          <a href="#" class="wallet-btn-link" id="google-wallet-btn" style="display: none;">
            <img id="google-wallet-img" src="./assets/wallet-buttons/google-wallet-buttons/Locale=EN, Type=Primary.svg" alt="Add to Google Wallet">
          </a>
          <a href="mailto:ram@agentmail.to" class="contact-btn">
            <i class="hgi-stroke hgi-mail-02" style="margin-right: 6px; font-size: 16px;"></i>
            Email Us
          </a>
        </div>
        <div class="wallet-message" id="wallet-message">Coming soon!</div>
      </div>
    </main>
    
<!-- build number moved to end of body -->
    </div>

    <script>
      // Randomize default note placeholder on load
      (function() {
        const ph = [
          "Buy oat milk\nText mom\nDon't forget…",
          "Pick up groceries\nCall dentist\nStretch!",
          "Idea: build an app\nResearch competitors\nSketch wireframes",
          "Monday meeting\nBring snacks\nAsk about timeline",
          "Gift ideas:\nNew headphones?\nBook about space",
          "Workout plan\nRun 2 miles\nDrink more water",
          "Movie night picks:\nInterstellar\nEverything Everywhere",
          "Pack for trip\nCharger\nPassport\nSnacks",
          "Learn something new\nWatch a tutorial\nTake notes",
          "Groceries:\nAvocados\nSourdough\nCoffee beans",
          "Weekend plans\nFarmers market\nCook dinner\nRead",
        ];
        const memo = document.getElementById('memo');
        if (memo) memo.placeholder = ph[Math.floor(Math.random() * ph.length)];
      })();

      // Language picker and wallet buttons
      (function() {
        const appleImg = document.getElementById('apple-wallet-img');
        const googleImg = document.getElementById('google-wallet-img');
        const langPicker = document.getElementById('lang-picker');
        const langBtn = document.getElementById('lang-btn');
        const langDropdown = document.getElementById('lang-dropdown');
        const langOptions = document.querySelectorAll('.lang-option');
        const currentLangSpan = document.getElementById('current-lang');

        // Map language codes to button locale codes
        const appleLocaleMap = {
          'en': 'EN', 'es': 'ES', 'fr': 'FR', 'de': 'DE', 'ja': 'JP',
          'zh': 'CN', 'ko': 'KR', 'pt': 'PT'
        };

        const googleLocaleMap = {
          'en': 'EN', 'es': 'esES', 'fr': 'FR', 'de': 'DE', 'ja': 'JP',
          'zh': 'zhHK', 'ko': 'KO', 'pt': 'PT'
        };

        const langDisplayMap = {
          'en': 'EN', 'es': 'ES', 'fr': 'FR', 'de': 'DE',
          'ja': 'JA', 'zh': 'ZH', 'ko': 'KO', 'pt': 'PT'
        };

        // Get initial language from browser or localStorage
        let currentLang = localStorage.getItem('walletmemo-lang');
        if (!currentLang) {
          const browserLang = (navigator.language || navigator.userLanguage).split('-')[0];
          currentLang = appleLocaleMap[browserLang] ? browserLang : 'en';
        }

        function updateWalletButtons(lang) {
          const appleLocale = appleLocaleMap[lang] || 'EN';
          const googleLocale = googleLocaleMap[lang] || 'EN';

          appleImg.src = `./assets/wallet-buttons/apple-wallet-buttons/Locale=${appleLocale}.svg`;
          googleImg.src = `./assets/wallet-buttons/google-wallet-buttons/Locale=${googleLocale}, Type=Primary.svg`;

          // Update display
          currentLangSpan.textContent = langDisplayMap[lang] || 'EN';

          // Update active state
          langOptions.forEach(opt => {
            opt.classList.toggle('active', opt.dataset.lang === lang);
          });
        }

        // Fallback to English if locale file doesn't exist
        appleImg.onerror = () => {
          appleImg.src = './assets/wallet-buttons/apple-wallet-buttons/Locale=EN.svg';
        };
        googleImg.onerror = () => {
          googleImg.src = './assets/wallet-buttons/google-wallet-buttons/Locale=EN, Type=Primary.svg';
        };

        // Initialize
        updateWalletButtons(currentLang);

        // Toggle dropdown
        langBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          langPicker.classList.toggle('open');
        });

        // Close on outside click
        document.addEventListener('click', () => {
          langPicker.classList.remove('open');
        });

        // Language selection
        langOptions.forEach(opt => {
          opt.addEventListener('click', (e) => {
            e.stopPropagation();
            const lang = opt.dataset.lang;
            currentLang = lang;
            localStorage.setItem('walletmemo-lang', lang);
            updateWalletButtons(lang);
            langPicker.classList.remove('open');
          });
        });

        // Google Wallet - coming soon
        const walletMessage = document.getElementById('wallet-message');
        document.getElementById('google-wallet-btn').addEventListener('click', (e) => {
          e.preventDefault();
          walletMessage.classList.add('visible');
        });
      })();

      // ==========================================
      // Sticky Note Menu & Drawing System
      // ==========================================
      (function() {
        // Elements
        const stickyNote = document.getElementById('sticky-note');
        const menuBtn = document.getElementById('menu-btn');
        const dropdown = document.getElementById('note-dropdown');
        const changeColorBtn = document.getElementById('change-color-btn');
        const colorSubmenu = document.getElementById('color-submenu');
        const colorSwatches = document.querySelectorAll('.color-swatch');
        const addStampBtn = document.getElementById('add-stamp-btn');
        const drawBtn = document.getElementById('draw-btn');
        const colorIcon = document.getElementById('color-icon');
        const noteDrawingLayer = document.getElementById('note-drawing-layer');
        const drawingToolbar = document.getElementById('drawing-toolbar');
        const clearBtn = document.getElementById('clear-drawing');
        const cancelBtn = document.getElementById('cancel-drawing');
        const doneBtn = document.getElementById('done-drawing');

        // Color theme definitions
        const colorThemes = {
          blue: {
            gradient: ['#9DD5EE', '#98C4DA', '#9BC8E7', '#ACD7E9', '#B8E3F3', '#C4E9F5'],
            shadow1: [0.101961, 0.55098, 1],      // Blue tint
            shadow2: [0, 0.334596, 0.608357],     // Blue tint
            shadow3: [0.425615, 0.695906, 0.842314] // Blue edge
          },
          yellow: {
            gradient: ['#D8C453', '#D4B94C', '#DEC75E', '#E8D46E', '#F0DF85', '#F7EA9C'],
            shadow1: [0.85, 0.75, 0.25],          // Yellow tint
            shadow2: [0.55, 0.48, 0.15],          // Yellow tint
            shadow3: [0.82, 0.78, 0.42]           // Yellow edge
          },
          pink: {
            gradient: ['#DCABB5', '#D7A0AA', '#E2B4BD', '#ECC4CC', '#F2D1D8', '#F8DEE3'],
            shadow1: [0.9, 0.55, 0.65],           // Pink tint
            shadow2: [0.6, 0.35, 0.45],           // Pink tint
            shadow3: [0.88, 0.72, 0.78]           // Pink edge
          }
        };

        // Weighted random color selection
        function getRandomColor() {
          const rand = Math.random();
          if (rand < 0.6) return 'blue';      // 60% chance
          if (rand < 0.9) return 'yellow';    // 30% chance
          return 'pink';                       // 10% chance
        }

        let currentColor = getRandomColor();

        // Color icon colors (mid-tone for each theme)
        const colorIconColors = {
          blue: '#B4DCE8',
          yellow: '#E2D060',
          pink: '#E4B8C0'
        };

        // Update note colors dynamically
        function updateNoteColors(colorKey) {
          const theme = colorThemes[colorKey];
          if (!theme) return;

          // Update color icon
          if (colorIcon) {
            colorIcon.style.background = colorIconColors[colorKey];
          }

          // Update gradient stops
          theme.gradient.forEach((color, i) => {
            const stop = document.getElementById(`grad-stop-${i}`);
            if (stop) stop.setAttribute('stop-color', color);
          });

          // Update shadow colors
          const shadow1 = document.getElementById('shadowColor1');
          const shadow2 = document.getElementById('shadowColor2');
          const shadow3 = document.getElementById('shadowColor3');

          if (shadow1) {
            const [r, g, b] = theme.shadow1;
            shadow1.setAttribute('values', `0 0 0 0 ${r} 0 0 0 0 ${g} 0 0 0 0 ${b} 0 0 0 0.1 0`);
          }
          if (shadow2) {
            const [r, g, b] = theme.shadow2;
            shadow2.setAttribute('values', `0 0 0 0 ${r} 0 0 0 0 ${g} 0 0 0 0 ${b} 0 0 0 0.09 0`);
          }
          if (shadow3) {
            const [r, g, b] = theme.shadow3;
            shadow3.setAttribute('values', `0 0 0 0 ${r} 0 0 0 0 ${g} 0 0 0 0 ${b} 0 0 0 1 0`);
          }
        }

        // Note state toggle (click to switch between curled and flat)
        const noteWrapper = document.getElementById('note-wrapper');
        const notePaper = document.getElementById('note-paper');
        const noteShape = document.getElementById('note-shape');
        const noteShadow = document.getElementById('note-shadow');
        let isFlat = false;

        // SVG path points for the two states (matching structure for smooth morphing)
        // Structure: [M, L, C1, C2, C3, L, C1, C2, C3]
        const statePoints = {
          curled: [
            [34.6016, 19.2695],    // M - start
            [250.102, 18.5996],    // L - top right
            [250.102, 18.5996],    // C1 - control 1
            [249.602, 49.0996],    // C2 - control 2
            [257.602, 228.6],      // C3 - end (bottom right)
            [28.6016, 231.1],      // L - bottom left
            [36.6029, 66.5996],    // C1 - control 1
            [34.6016, 19.2695],    // C2 - control 2
            [34.6016, 19.2695]     // C3 - end (back to start)
          ],
          flat: [
            [29, 18],              // M - start
            [258, 18],             // L - top right
            [258, 18],             // C1 - control 1 (on line)
            [258, 125],            // C2 - control 2 (midpoint)
            [258, 232],            // C3 - end (bottom right)
            [29, 232],             // L - bottom left
            [29, 125],             // C1 - control 1 (midpoint)
            [29, 18],              // C2 - control 2 (on line)
            [29, 18]               // C3 - end (back to start)
          ]
        };

        // Convert points array to SVG path string
        function pointsToPath(points) {
          return `M${points[0][0]} ${points[0][1]} L${points[1][0]} ${points[1][1]} C${points[2][0]} ${points[2][1]} ${points[3][0]} ${points[3][1]} ${points[4][0]} ${points[4][1]} L${points[5][0]} ${points[5][1]} C${points[6][0]} ${points[6][1]} ${points[7][0]} ${points[7][1]} ${points[8][0]} ${points[8][1]} Z`;
        }

        // Interpolate between two point arrays
        function lerpPoints(from, to, t) {
          return from.map((point, i) => [
            point[0] + (to[i][0] - point[0]) * t,
            point[1] + (to[i][1] - point[1]) * t
          ]);
        }

        // Easing function (ease-out cubic)
        function easeOutCubic(t) {
          return 1 - Math.pow(1 - t, 3);
        }

        // Animate path morphing
        let animationId = null;
        function animatePath(from, to, duration = 400) {
          if (animationId) cancelAnimationFrame(animationId);

          const startTime = performance.now();

          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutCubic(progress);

            const currentPoints = lerpPoints(from, to, easedProgress);
            noteShape.setAttribute('d', pointsToPath(currentPoints));

            if (progress < 1) {
              animationId = requestAnimationFrame(animate);
            }
          }

          animationId = requestAnimationFrame(animate);
        }

        // Flat gradient colors (more uniform, less dynamic)
        const flatGradients = {
          blue: ['#B3DDEE', '#B3DDEE', '#B3DDEE', '#B8E0F0', '#BDE3F2', '#C2E6F4'],
          yellow: ['#E8D66C', '#E8D66C', '#E8D66C', '#ECDA74', '#EEDC78', '#F2E082'],
          pink: ['#EACAD2', '#EACAD2', '#EACAD2', '#EDCED6', '#F0D0D8', '#F2D4DB']
        };

        // Parse hex color to RGB array
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
          ] : [0, 0, 0];
        }

        // Convert RGB array to hex
        function rgbToHex(r, g, b) {
          return '#' + [r, g, b].map(x => {
            const hex = Math.round(x).toString(16);
            return hex.length === 1 ? '0' + hex : hex;
          }).join('');
        }

        // Animate gradient transition
        let gradientAnimationId = null;
        function animateGradient(toFlat, duration = 400) {
          if (gradientAnimationId) cancelAnimationFrame(gradientAnimationId);

          const theme = colorThemes[currentColor];
          const fromColors = toFlat ? theme.gradient : flatGradients[currentColor];
          const toColors = toFlat ? flatGradients[currentColor] : theme.gradient;

          const fromRgb = fromColors.map(hexToRgb);
          const toRgb = toColors.map(hexToRgb);

          const startTime = performance.now();

          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutCubic(progress);

            fromRgb.forEach((from, i) => {
              const r = from[0] + (toRgb[i][0] - from[0]) * easedProgress;
              const g = from[1] + (toRgb[i][1] - from[1]) * easedProgress;
              const b = from[2] + (toRgb[i][2] - from[2]) * easedProgress;
              const stop = document.getElementById(`grad-stop-${i}`);
              if (stop) stop.setAttribute('stop-color', rgbToHex(r, g, b));
            });

            if (progress < 1) {
              gradientAnimationId = requestAnimationFrame(animate);
            }
          }

          gradientAnimationId = requestAnimationFrame(animate);
        }

        // Initialize lift/stick animations on any note wrapper
        window.initNoteAnimations = function(wrapper, colorKey, noteId, stopElements) {
          const shape = wrapper.querySelector('.note-paper path');
          // Use passed-in stops or query from wrapper
          const stops = stopElements || wrapper.querySelectorAll('svg stop') || [];
          let noteIsFlat = false;
          let noteAnimId = null;
          let noteGradAnimId = null;

          const theme = colorThemes[colorKey];
          const flatGrads = flatGradients[colorKey];

          function animateNotePath(from, to, duration = 400) {
            if (noteAnimId) cancelAnimationFrame(noteAnimId);
            const startTime = performance.now();
            function anim(t) {
              const elapsed = t - startTime;
              const progress = Math.min(elapsed / duration, 1);
              const ep = easeOutCubic(progress);
              const pts = lerpPoints(from, to, ep);
              shape.setAttribute('d', pointsToPath(pts));
              if (progress < 1) noteAnimId = requestAnimationFrame(anim);
            }
            noteAnimId = requestAnimationFrame(anim);
          }

          function animateNoteGradient(toFlat, duration = 400) {
            if (noteGradAnimId) cancelAnimationFrame(noteGradAnimId);
            const fromColors = (toFlat ? theme.gradient : flatGrads).map(hexToRgb);
            const toColors = (toFlat ? flatGrads : theme.gradient).map(hexToRgb);
            const startTime = performance.now();
            function anim(t) {
              const elapsed = t - startTime;
              const progress = Math.min(elapsed / duration, 1);
              const ep = easeOutCubic(progress);
              fromColors.forEach((from, i) => {
                const r = from[0] + (toColors[i][0] - from[0]) * ep;
                const g = from[1] + (toColors[i][1] - from[1]) * ep;
                const b = from[2] + (toColors[i][2] - from[2]) * ep;
                if (stops[i]) stops[i].setAttribute('stop-color', rgbToHex(r, g, b));
              });
              if (progress < 1) noteGradAnimId = requestAnimationFrame(anim);
            }
            noteGradAnimId = requestAnimationFrame(anim);
          }

          wrapper.addEventListener('note:lift', () => {
            if (!noteIsFlat) {
              noteIsFlat = true;
              animateNotePath(statePoints.curled, statePoints.flat);
              animateNoteGradient(true);
              wrapper.classList.add('flat');
            }
          });

          wrapper.addEventListener('note:stick', () => {
            if (noteIsFlat) {
              noteIsFlat = false;
              animateNotePath(statePoints.flat, statePoints.curled);
              animateNoteGradient(false);
              wrapper.classList.remove('flat');
            }
          });

          // Click anywhere on note to focus textarea
          const noteTextarea = wrapper.querySelector('textarea');
          if (noteTextarea) {
            wrapper.addEventListener('click', (e) => {
              if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown')) return;
              noteTextarea.focus();
            });

            noteTextarea.addEventListener('focus', () => {
              if (!noteIsFlat) {
                noteIsFlat = true;
                animateNotePath(statePoints.curled, statePoints.flat);
                animateNoteGradient(true);
                wrapper.classList.add('flat');
              }
            });

            noteTextarea.addEventListener('blur', () => {
              if (noteIsFlat) {
                noteIsFlat = false;
                animateNotePath(statePoints.flat, statePoints.curled);
                animateNoteGradient(false);
                wrapper.classList.remove('flat');
              }
            });
          }
        };

        // Get textarea element
        const textarea = document.getElementById('memo');

        // Tap anywhere on the note to focus textarea (fixes mobile double-tap)
        noteWrapper.addEventListener('click', (e) => {
          // Don't steal clicks from menu, dropdown, or drawing layer
          if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown') || e.target.closest('.drawing-toolbar')) return;
          textarea.focus();
        });

        // Calculate mobile scale so note fills width
        function updateMobileLayout() {
          const noteWidth = noteWrapper.offsetWidth || 344;
          const scale = (window.innerWidth / noteWidth) * 1.1;
          document.documentElement.style.setProperty('--mobile-note-scale', scale.toFixed(3));
        }
        updateMobileLayout();
        window.addEventListener('resize', updateMobileLayout);

        // Mobile: touchend for immediate focus without double-tap
        noteWrapper.addEventListener('touchend', (e) => {
          if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown') || e.target.closest('.drawing-toolbar')) return;
          if (noteWrapper.classList.contains('drawing-mode')) return;
          e.preventDefault();
          textarea.focus({ preventScroll: true });
        });

        // Focus/blur on textarea triggers the flat/curled animation
        const focusOverlay = document.getElementById('focus-overlay');
        const langPicker2 = document.getElementById('lang-picker');
        // Custom events for external code (e.g., drag) to trigger flat/curl
        noteWrapper.addEventListener('note:lift', () => {
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            noteWrapper.classList.add('flat');
          }
        });

        noteWrapper.addEventListener('note:stick', () => {
          if (isFlat) {
            isFlat = false;
            animatePath(statePoints.flat, statePoints.curled);
            animateGradient(false);
            noteWrapper.classList.remove('flat');
          }
        });

        textarea.addEventListener('focus', () => {
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            noteShadow.src = './assets/paper-stuff/shadow-layer-two.svg';
            noteWrapper.classList.add('flat');
            focusOverlay.classList.add('active');
            langPicker2.classList.add('hidden');
          }
        });

        textarea.addEventListener('blur', () => {
          // Don't close note when entering drawing mode
          if (isDrawingMode) return;
          if (isFlat) {
            isFlat = false;
            animatePath(statePoints.flat, statePoints.curled);
            animateGradient(false);
            noteShadow.src = './assets/paper-stuff/shadow-layer.svg';
            noteWrapper.classList.remove('flat');
            focusOverlay.classList.remove('active');
            langPicker2.classList.remove('hidden');
          }
        });

        // Menu toggle
        // Prevent menu/dropdown from stealing focus from textarea
        menuBtn.addEventListener('mousedown', (e) => e.preventDefault());
        dropdown.addEventListener('mousedown', (e) => e.preventDefault());
        menuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          menuBtn.classList.toggle('active');
          dropdown.classList.toggle('open');
          // Re-focus textarea so note stays in focused state
          if (isFlat) textarea.focus({ preventScroll: true });
          // Clamp dropdown to viewport
          if (dropdown.classList.contains('open')) {
            requestAnimationFrame(() => {
              const rect = dropdown.getBoundingClientRect();
              if (rect.right > window.innerWidth) {
                const overflow = rect.right - window.innerWidth + 8;
                dropdown.style.right = (8 + overflow) + 'px';
              } else {
                dropdown.style.right = '';
              }
            });
          } else {
            dropdown.style.right = '';
          }
        });

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
          if (!dropdown.contains(e.target) && !menuBtn.contains(e.target)) {
            dropdown.classList.remove('open');
            menuBtn.classList.remove('active');
            colorSubmenu.classList.remove('open');
          }
        });

        // Color change functionality
        changeColorBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          colorSubmenu.classList.toggle('open');
        });

        colorSwatches.forEach(swatch => {
          swatch.addEventListener('click', (e) => {
            e.stopPropagation();
            const colorKey = swatch.dataset.color;
            currentColor = colorKey;
            updateNoteColors(colorKey);

            // Clear drawing when color changes (drawing is tied to note color)
            if (drawingCtx) {
              drawingCtx.clearRect(0, 0, noteDrawingLayer.width, noteDrawingLayer.height);
            }

            // Update active state
            colorSwatches.forEach(s => s.classList.remove('active'));
            swatch.classList.add('active');

            // Close menu
            dropdown.classList.remove('open');
            menuBtn.classList.remove('active');
            colorSubmenu.classList.remove('open');
          });
        });

        // Add stamp (placeholder)
        addStampBtn.addEventListener('click', () => {
          alert('Stamp feature coming soon!');
          dropdown.classList.remove('open');
          menuBtn.classList.remove('active');
        });

        // ==========================================
        // Drawing Mode (draws directly on note)
        // ==========================================
        let isDrawingMode = false;
        let drawingCtx = null;
        let isDrawing = false;
        let savedImageData = null;

        // Initialize note drawing layer
        function initNoteDrawingLayer() {
          noteDrawingLayer.width = stickyNote.offsetWidth * 2;
          noteDrawingLayer.height = stickyNote.offsetHeight * 2;
          drawingCtx = noteDrawingLayer.getContext('2d');
          drawingCtx.scale(2, 2);
          drawingCtx.lineCap = 'round';
          drawingCtx.lineJoin = 'round';
          drawingCtx.strokeStyle = 'rgba(26, 26, 26, 0.9)';
          drawingCtx.lineWidth = 4;
        }
        
        // Pen settings
        let currentPenColor = 'rgba(26, 26, 26, 0.9)';
        let currentPenSize = 4;

        initNoteDrawingLayer();

        // Open drawing mode
        drawBtn.addEventListener('click', () => {
          dropdown.classList.remove('open');
          menuBtn.classList.remove('active');

          isDrawingMode = true;

          // Save current drawing state for cancel
          savedImageData = drawingCtx.getImageData(0, 0, noteDrawingLayer.width, noteDrawingLayer.height);

          // Put note in flat state
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            noteShadow.src = './assets/paper-stuff/shadow-layer-two.svg';
            noteWrapper.classList.add('flat');
          }

          // Hide keyboard but keep note open
          // Temporarily prevent blur from closing the note
          isDrawingMode = true; // already set above, but ensures blur check works
          textarea.blur();
          // Re-assert flat state since blur removes it
          isFlat = true;
          noteWrapper.classList.add('flat');
          focusOverlay.classList.add('active');
          langPicker2.classList.add('hidden');

          // Enable drawing mode
          document.body.classList.add('drawing-mode-active');
          noteWrapper.classList.add('drawing-mode');
        });

        // Drawing on canvas
        noteDrawingLayer.addEventListener('pointerdown', (e) => {
          if (!isDrawingMode) return;
          isDrawing = true;
          const rect = noteDrawingLayer.getBoundingClientRect();
          const scaleX = noteDrawingLayer.width / rect.width / 2;
          const scaleY = noteDrawingLayer.height / rect.height / 2;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          drawingCtx.beginPath();
          drawingCtx.moveTo(x, y);
        });

        noteDrawingLayer.addEventListener('pointermove', (e) => {
          if (!isDrawingMode || !isDrawing) return;

          const rect = noteDrawingLayer.getBoundingClientRect();
          const scaleX = noteDrawingLayer.width / rect.width / 2;
          const scaleY = noteDrawingLayer.height / rect.height / 2;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          drawingCtx.lineTo(x, y);
          drawingCtx.stroke();
          drawingCtx.beginPath();
          drawingCtx.moveTo(x, y);
        });

        noteDrawingLayer.addEventListener('pointerup', () => {
          isDrawing = false;
        });

        noteDrawingLayer.addEventListener('pointerleave', () => {
          isDrawing = false;
        });

        // Clear drawing
        clearBtn.addEventListener('click', () => {
          drawingCtx.clearRect(0, 0, noteDrawingLayer.width, noteDrawingLayer.height);
        });

        // Cancel drawing - restore previous state
        cancelBtn.addEventListener('click', () => {
          if (savedImageData) {
            drawingCtx.putImageData(savedImageData, 0, 0);
          }
          closeDrawingMode();
        });

        // Done drawing
        doneBtn.addEventListener('click', () => {
          closeDrawingMode();
        });

        function closeDrawingMode() {
          isDrawingMode = false;
          isDrawing = false;
          savedImageData = null;
          document.body.classList.remove('drawing-mode-active');
          noteWrapper.classList.remove('drawing-mode');
          // Return to initial closed state
          if (isFlat) {
            isFlat = false;
            animatePath(statePoints.flat, statePoints.curled);
            animateGradient(false);
            noteShadow.src = './assets/paper-stuff/shadow-layer.svg';
            noteWrapper.classList.remove('flat');
            focusOverlay.classList.remove('active');
            langPicker2.classList.remove('hidden');
          }
          textarea.blur();
        }

        // Pen color picker
        document.querySelectorAll('.pen-color').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.pen-color').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const rgb = btn.dataset.color;
            currentPenColor = `rgba(${rgb}, 0.9)`;
            if (drawingCtx) drawingCtx.strokeStyle = currentPenColor;
          });
        });

        // Pen size picker
        document.querySelectorAll('.pen-size').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.pen-size').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentPenSize = parseInt(btn.dataset.size);
            if (drawingCtx) drawingCtx.lineWidth = currentPenSize;
          });
        });

        // Handle window resize
        window.addEventListener('resize', () => {
          initNoteDrawingLayer();
        });

        // Apply random color on load and update active swatch
        updateNoteColors(currentColor);
        colorSwatches.forEach(s => {
          s.classList.toggle('active', s.dataset.color === currentColor);
        });

        // ==========================================
        // Apple Wallet Pass Generation
        // ==========================================
        const appleWalletBtn = document.getElementById('apple-wallet-btn');
        const walletMsg = document.getElementById('wallet-message');
        
        appleWalletBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          
          // Get note content
          const text = document.getElementById('memo').value;
          
          // Get drawing data - always send canvas (backend handles empty gracefully)
          const drawingDataUrl = noteDrawingLayer.toDataURL('image/png');
          
          // Show loading state
          const originalContent = appleWalletBtn.innerHTML;
          appleWalletBtn.style.opacity = '0.6';
          appleWalletBtn.style.pointerEvents = 'none';
          
          try {
            const BACKEND_URL = 'https://sandbox-staging.up.railway.app';
            
            // Simple approach: fetch blob and trigger download
            const response = await fetch(`${BACKEND_URL}/api/generate-pass`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                text: text,
                color: currentColor,
                drawingDataUrl: drawingDataUrl
              })
            });
            
            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.error || 'Failed to generate pass');
            }
            
            // Get the blob and create download link
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            
            // Try opening the blob URL directly - Safari may handle .pkpass
            window.location.href = url;
            
          } catch (error) {
            console.error('Error:', error);
            walletMsg.textContent = error.message.includes('fetch') 
              ? 'Backend not running. Start the server first!'
              : error.message;
            walletMsg.classList.add('visible');
            setTimeout(() => walletMsg.classList.remove('visible'), 3000);
          } finally {
            appleWalletBtn.style.opacity = '1';
            appleWalletBtn.style.pointerEvents = 'auto';
          }
        });
      })();

      // Desktop drag-to-move sticky note + "add new" pad
      (function() {
        if ('ontouchstart' in window) return; // Skip on mobile

        const mainArea = document.querySelector('main') || document.querySelector('.content-wrapper');
        const wrapper = document.getElementById('note-wrapper');
        const dragZoneHeight = 48;
        let noteCounter = 0;
        let hasMoved = false;

        // Create the "add new note" button that sits behind the note
        const addBtn = document.createElement('div');
        addBtn.className = 'add-note-btn';
        addBtn.innerHTML = '<i class="hgi-stroke hgi-add-01"></i>';
        addBtn.style.display = 'none';
        wrapper.parentElement.insertBefore(addBtn, wrapper);

        function makeDraggable(el) {
          let isDragging = false;
          let startX, startY, origX = 0, origY = 0;
          let offsetX = 0, offsetY = 0;

          el.addEventListener('mousemove', (e) => {
            if (isDragging) return;
            const rect = el.getBoundingClientRect();
            const relY = e.clientY - rect.top;
            if (relY < dragZoneHeight && !e.target.closest('.note-menu-btn') && !e.target.closest('.note-dropdown')) {
              el.style.cursor = 'grab';
            } else {
              el.style.cursor = '';
            }
          });

          el.addEventListener('mousedown', (e) => {
            const rect = el.getBoundingClientRect();
            const relY = e.clientY - rect.top;
            if (relY >= dragZoneHeight) return;
            if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown')) return;

            e.preventDefault();
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            origX = offsetX;
            origY = offsetY;
            el.style.cursor = 'grabbing';
            el.style.transition = 'none';
            el.style.zIndex = String(50 + noteCounter);
            // Lift off the wall - go flat
            el.classList.add('flat');
            el.dispatchEvent(new Event('note:lift'));
            el.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(1.03) rotate(3deg)`;
            // Show add button immediately on grab
            if (!hasMoved) {
              hasMoved = true;
              addBtn.style.display = 'flex';
            }
          });

          document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            offsetX = origX + dx;
            offsetY = origY + dy;
            el.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(1.03) rotate(3deg)`;
          });

          document.addEventListener('mouseup', () => {
            if (!isDragging) return;
            isDragging = false;
            el.style.cursor = 'grab';
            el.style.transition = '';
            // Stick back to wall - remove flat, go back to curled
            el.classList.remove('flat');
            el.dispatchEvent(new Event('note:stick'));
            el.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            const ta = el.querySelector('textarea');
            if (ta) ta.blur();
            // Suppress the click event that fires after mouseup
            // so it doesn't re-focus the textarea and flatten the note
            el.addEventListener('click', function suppressClick(evt) {
              evt.stopPropagation();
              evt.preventDefault();
              el.removeEventListener('click', suppressClick, true);
            }, true);
          });
        }

        makeDraggable(wrapper);

        // Add new note button
        const placeholders = [
          "Pick up groceries\nCall dentist\nStretch!",
          "Idea: build an app\nResearch competitors\nSketch wireframes",
          "Monday meeting\nBring snacks\nAsk about timeline",
          "Gift ideas:\nNew headphones?\nBook about space",
          "Workout plan\nRun 2 miles\nDrink more water",
          "Movie night picks:\nInterstellar\nEverything Everywhere",
          "Pack for trip\nCharger\nPassport\nSnacks",
          "Learn something new\nWatch a tutorial\nTake notes",
          "Groceries:\nAvocados\nSourdough\nCoffee beans",
          "Weekend plans\nFarmers market\nCook dinner\nRead",
        ];

        addBtn.addEventListener('click', () => {
          noteCounter++;
          const colors = ['blue', 'yellow', 'pink'];
          const color = colors[noteCounter % 3];

          // Color configs (gradient + shadow colors per theme)
          const colorMap = {
            blue: ['#9DD5EE', '#98C4DA', '#9BC8E7', '#ACD7E9', '#B8E3F3', '#C4E9F5'],
            yellow: ['#D8C453', '#D4B94C', '#DEC75E', '#E8D46E', '#F0DF85', '#F7EA9C'],
            pink: ['#DCABB5', '#D7A0AA', '#E2B4BD', '#ECC4CC', '#F2D1D8', '#F8DEE3']
          };
          const shadowMap = {
            blue: {
              s1: '0 0 0 0 0.101961 0 0 0 0 0.55098 0 0 0 0 1 0 0 0 0 0',
              s2: '0 0 0 0 0 0 0 0 0 0.334596 0 0 0 0 0.608357 0 0 0 0 0',
              s3: '0 0 0 0 0.425615 0 0 0 0 0.695906 0 0 0 0 0.842314 0 0 0 1 0'
            },
            yellow: {
              s1: '0 0 0 0 0.85 0 0 0 0 0.75 0 0 0 0 0.25 0 0 0 0 0',
              s2: '0 0 0 0 0.55 0 0 0 0 0.48 0 0 0 0 0.15 0 0 0 0 0',
              s3: '0 0 0 0 0.82 0 0 0 0 0.78 0 0 0 0 0.42 0 0 0 1 0'
            },
            pink: {
              s1: '0 0 0 0 0.9 0 0 0 0 0.55 0 0 0 0 0.65 0 0 0 0 0',
              s2: '0 0 0 0 0.6 0 0 0 0 0.35 0 0 0 0 0.45 0 0 0 0 0',
              s3: '0 0 0 0 0.88 0 0 0 0 0.72 0 0 0 0 0.78 0 0 0 1 0'
            }
          };
          const g = colorMap[color];
          const s = shadowMap[color];

          const newWrapper = document.createElement('div');
          newWrapper.className = 'note-wrapper dragged-note';
          newWrapper.style.position = 'absolute';
          newWrapper.style.top = wrapper.offsetTop + 'px';
          newWrapper.style.left = wrapper.offsetLeft + 'px';
          newWrapper.style.width = '360px';
          newWrapper.style.height = '340px';
          newWrapper.style.zIndex = String(10 + noteCounter);

          // Use DOMParser to create proper SVG namespace elements
          const svgMarkup = `<svg class="note-paper" width="287" height="270" viewBox="0 0 287 270" fill="none" xmlns="http://www.w3.org/2000/svg">
              <g filter="url(#nf${noteCounter})">
                <path d="M34.6016 19.2695L250.102 18.5996C250.102 18.5996 249.602 49.0996 257.602 228.6L28.6016 231.1C36.6029 66.5996 34.6016 19.2695 34.6016 19.2695Z" fill="url(#ng${noteCounter})"/>
              </g>
              <defs>
                <linearGradient id="ng${noteCounter}" x1="153.102" y1="231.1" x2="143.601" y2="18.5996" gradientUnits="userSpaceOnUse">
                  <stop stop-color="${g[0]}"/>
                  <stop offset="0.255906" stop-color="${g[1]}"/>
                  <stop offset="0.812358" stop-color="${g[2]}"/>
                  <stop offset="0.864881" stop-color="${g[3]}"/>
                  <stop offset="0.954264" stop-color="${g[4]}"/>
                  <stop offset="1" stop-color="${g[5]}"/>
                </linearGradient>
                <filter id="nf${noteCounter}" x="0.00156212" y="-0.000391006" width="286.2" height="269.7" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
                  <feFlood flood-opacity="0" result="BackgroundImageFix"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
                  <feOffset/>
                  <feGaussianBlur stdDeviation="5.14583"/>
                  <feColorMatrix type="matrix" values="${s.s1}"/>
                  <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
                  <feOffset dy="10"/>
                  <feGaussianBlur stdDeviation="14.3"/>
                  <feColorMatrix type="matrix" values="${s.s2}"/>
                  <feBlend mode="normal" in2="effect1_dropShadow" result="effect2_dropShadow"/>
                  <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
                  <feOffset dy="0.2"/>
                  <feComposite in2="hardAlpha" operator="out"/>
                  <feColorMatrix type="matrix" values="${s.s3}"/>
                  <feBlend mode="normal" in2="effect2_dropShadow" result="effect3_dropShadow"/>
                  <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
                  <feTurbulence type="fractalNoise" baseFrequency="1.6666666269302368 1.6666666269302368" stitchTiles="stitch" numOctaves="3" result="noise" seed="${6167 + noteCounter}"/>
                  <feComponentTransfer in="noise" result="coloredNoise1">
                    <feFuncR type="linear" slope="2" intercept="-0.5"/>
                    <feFuncG type="linear" slope="2" intercept="-0.5"/>
                    <feFuncB type="linear" slope="2" intercept="-0.5"/>
                    <feFuncA type="discrete" tableValues="1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"/>
                  </feComponentTransfer>
                  <feComposite operator="in" in2="shape" in="coloredNoise1" result="noise1Clipped"/>
                  <feComponentTransfer in="noise1Clipped" result="color1">
                    <feFuncA type="table" tableValues="0 0.06"/>
                  </feComponentTransfer>
                  <feMerge result="effect4_noise">
                    <feMergeNode in="shape"/>
                    <feMergeNode in="color1"/>
                  </feMerge>
                  <feBlend mode="normal" in="effect4_noise" in2="effect3_dropShadow" result="effect4_noise"/>
                </filter>
              </defs>
            </svg>`;
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(svgMarkup, 'image/svg+xml');
          const svgNode = document.adoptNode(svgDoc.documentElement);
          
          const noteDiv = document.createElement('div');
          noteDiv.className = 'note';
          noteDiv.style.cssText = 'width:360px;height:340px;padding:48px 57px;position:absolute;top:0;left:0;z-index:2;display:flex;flex-direction:column;justify-content:center;';
          const ta = document.createElement('textarea');
          ta.className = 'textarea';
          ta.maxLength = 140;
          ta.style.cssText = "font-family:'Patrick Hand',cursive;font-size:20px;line-height:1.5;color:#1a1a1a;border:none;background:transparent;resize:none;outline:none;text-align:center;width:100%;overflow:hidden;";
          noteDiv.appendChild(ta);
          
          newWrapper.appendChild(svgNode);
          newWrapper.appendChild(noteDiv);

          wrapper.parentElement.insertBefore(newWrapper, addBtn);
          // Set random placeholder
          if (ta) ta.placeholder = placeholders[Math.floor(Math.random() * placeholders.length)];
          makeDraggable(newWrapper);
          // Get stops from the properly-namespaced SVG
          const noteStops = svgNode.querySelectorAll('stop');
          initNoteAnimations(newWrapper, color, noteCounter, noteStops);

          // Hide add button until this new one is dragged
          hasMoved = false;
          addBtn.style.display = 'none';
        });
      })();
    </script>
    <div class="build-hover-area"><span class="build-number">Build 133</span></div>
  </body>
</html>
