<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Wallet Memo</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.hugeicons.com/font/hgi-stroke-rounded.css">
    <link rel="stylesheet" href="./style.css" />
          <!-- GoatCounter analytics -->
    <script data-goatcounter="https://walletmemo.goatcounter.com/count"
            async src="//gc.zgo.at/count.js"></script>
  </head>
  <body>
    <div class="focus-overlay" id="focus-overlay"></div>
    <!-- Language picker -->
    <div class="lang-picker" id="lang-picker">
      <button class="lang-btn" id="lang-btn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <circle cx="12" cy="12" r="10"/>
          <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
        </svg>
        <span id="current-lang">EN</span>
        <svg class="chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M6 9l6 6 6-6"/>
        </svg>
      </button>
      <div class="lang-dropdown" id="lang-dropdown">
        <button class="lang-option" data-lang="en">English</button>
        <button class="lang-option" data-lang="es">Español</button>
        <button class="lang-option" data-lang="fr">Français</button>
        <button class="lang-option" data-lang="de">Deutsch</button>
        <button class="lang-option" data-lang="ja">日本語</button>
        <button class="lang-option" data-lang="zh">中文</button>
        <button class="lang-option" data-lang="ko">한국어</button>
        <button class="lang-option" data-lang="pt">Português</button>
      </div>
    </div>

    <div class="content-group">
      <div class="hero-text">
        <div class="hero-title">Wallet Memo</div>
        <div class="hero-tagline">A sticky note for your Apple Wallet</div>
      </div>

      <main class="container">
      <div class="note-wrapper" id="note-wrapper">
        <!-- Shadow layer (behind note) -->
        <img src="./assets/paper-stuff/shadow-layer.svg" class="note-shadow" id="note-shadow" alt="">
        <!-- Sticky note SVG - inlined for dynamic color updates -->
        <svg class="note-paper" id="note-paper" data-state="one" width="287" height="270" viewBox="0 0 287 270" fill="none" xmlns="http://www.w3.org/2000/svg">
          <g filter="url(#noteFilter)">
            <path id="note-shape" d="M34.6016 19.2695L250.102 18.5996C250.102 18.5996 249.602 49.0996 257.602 228.6L28.6016 231.1C36.6029 66.5996 34.6016 19.2695 34.6016 19.2695Z" fill="url(#noteGradient)"/>
          </g>
          <defs>
            <filter id="noteFilter" x="0.00156212" y="-0.000391006" width="286.2" height="269.7" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
              <feFlood flood-opacity="0" result="BackgroundImageFix"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset/>
              <feGaussianBlur stdDeviation="5.14583"/>
              <feColorMatrix id="shadowColor1" type="matrix" values="0 0 0 0 0.101961 0 0 0 0 0.55098 0 0 0 0 1 0 0 0 0.1 0"/>
              <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset dy="10"/>
              <feGaussianBlur stdDeviation="14.3"/>
              <feColorMatrix id="shadowColor2" type="matrix" values="0 0 0 0 0 0 0 0 0 0.334596 0 0 0 0 0.608357 0 0 0 0.09 0"/>
              <feBlend mode="normal" in2="effect1_dropShadow" result="effect2_dropShadow"/>
              <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
              <feOffset dy="0.2"/>
              <feComposite in2="hardAlpha" operator="out"/>
              <feColorMatrix id="shadowColor3" type="matrix" values="0 0 0 0 0.425615 0 0 0 0 0.695906 0 0 0 0 0.842314 0 0 0 1 0"/>
              <feBlend mode="normal" in2="effect2_dropShadow" result="effect3_dropShadow"/>
              <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
              <feTurbulence type="fractalNoise" baseFrequency="1.6666666269302368 1.6666666269302368" stitchTiles="stitch" numOctaves="3" result="noise" seed="6167"/>
              <feComponentTransfer in="noise" result="coloredNoise1">
                <feFuncR type="linear" slope="2" intercept="-0.5"/>
                <feFuncG type="linear" slope="2" intercept="-0.5"/>
                <feFuncB type="linear" slope="2" intercept="-0.5"/>
                <feFuncA type="discrete" tableValues="1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"/>
              </feComponentTransfer>
              <feComposite operator="in" in2="shape" in="coloredNoise1" result="noise1Clipped"/>
              <feComponentTransfer in="noise1Clipped" result="color1">
                <feFuncA type="table" tableValues="0 0.06"/>
              </feComponentTransfer>
              <feMerge result="effect4_noise">
                <feMergeNode in="shape"/>
                <feMergeNode in="color1"/>
              </feMerge>
              <feBlend mode="normal" in="effect4_noise" in2="effect3_dropShadow" result="effect4_noise"/>
            </filter>
            <linearGradient id="noteGradient" x1="153.102" y1="231.1" x2="143.601" y2="18.5996" gradientUnits="userSpaceOnUse">
              <stop id="grad-stop-0" stop-color="#9DD5EE"/>
              <stop id="grad-stop-1" offset="0.255906" stop-color="#98C4DA"/>
              <stop id="grad-stop-2" offset="0.812358" stop-color="#9BC8E7"/>
              <stop id="grad-stop-3" offset="0.864881" stop-color="#ACD7E9"/>
              <stop id="grad-stop-4" offset="0.954264" stop-color="#B8E3F3"/>
              <stop id="grad-stop-5" offset="1" stop-color="#C4E9F5"/>
            </linearGradient>
          </defs>
        </svg>
        <div class="note" id="sticky-note">
          <!-- Ellipsis menu button -->
          <button class="note-menu-btn" id="menu-btn">
            <svg viewBox="0 0 24 24">
              <circle cx="12" cy="5" r="2"/>
              <circle cx="12" cy="12" r="2"/>
              <circle cx="12" cy="19" r="2"/>
            </svg>
          </button>

          <!-- Dropdown menu -->
          <div class="note-dropdown" id="note-dropdown">
            <button class="dropdown-item" id="change-color-btn">
              <span class="color-icon" id="color-icon"></span>
              Change Color
            </button>
            <div class="color-submenu" id="color-submenu">
              <div class="color-swatch" data-color="blue" style="background: #B4DCE8;"></div>
              <div class="color-swatch" data-color="yellow" style="background: #EAD264;"></div>
              <div class="color-swatch" data-color="pink" style="background: #ECBDC5;"></div>
            </div>
            <button class="dropdown-item" id="add-stamp-btn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="11" width="18" height="10" rx="2"/>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
              </svg>
              Add Stamp
            </button>
            <button class="dropdown-item" id="draw-btn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                <path d="M2 2l7.586 7.586"/>
              </svg>
              Draw on Note
            </button>
          </div>

          <!-- Drawing layer for finished drawings -->
          <canvas class="note-drawing-layer" id="note-drawing-layer"></canvas>

          <textarea
            id="memo"
            class="textarea"
            placeholder="Buy oat milk&#10;Text mom&#10;Don't forget…"
            maxlength="140"
          ></textarea>
          <div class="note-version">Build 90</div>
        </div>
        <!-- Drawing toolbar -->
        <div class="drawing-toolbar" id="drawing-toolbar">
          <div class="pen-colors">
            <button class="pen-color active" data-color="26,26,26" style="background:#1a1a1a"></button>
            <button class="pen-color" data-color="229,57,53" style="background:#e53935"></button>
            <button class="pen-color" data-color="30,136,229" style="background:#1e88e5"></button>
            <button class="pen-color" data-color="67,160,71" style="background:#43a047"></button>
            <button class="pen-color" data-color="142,36,170" style="background:#8e24aa"></button>
          </div>
          <div class="pen-sizes">
            <button class="pen-size" data-size="1"><span style="width:4px;height:4px"></span></button>
            <button class="pen-size active" data-size="2"><span style="width:6px;height:6px"></span></button>
            <button class="pen-size" data-size="4"><span style="width:10px;height:10px"></span></button>
            <button class="pen-size" data-size="6"><span style="width:14px;height:14px"></span></button>
          </div>
          <div class="pen-actions">
            <button class="toolbar-btn clear" id="clear-drawing"><i class="hgi-stroke hgi-delete-02"></i></button>
            <button class="toolbar-btn cancel" id="cancel-drawing">Cancel</button>
            <button class="toolbar-btn done" id="done-drawing">Done</button>
          </div>
        </div>
      </div>

      <div class="wallet-wrapper">
        <div class="wallet-buttons">
          <a href="#" class="wallet-btn-link" id="apple-wallet-btn">
            <img id="apple-wallet-img" src="./assets/wallet-buttons/apple-wallet-buttons/Locale=EN.svg" alt="Add to Apple Wallet">
          </a>
          <a href="#" class="wallet-btn-link" id="google-wallet-btn" style="display: none;">
            <img id="google-wallet-img" src="./assets/wallet-buttons/google-wallet-buttons/Locale=EN, Type=Primary.svg" alt="Add to Google Wallet">
          </a>
          <a href="mailto:ram@agentmail.to" class="contact-btn">
            <i class="hgi-stroke hgi-mail-02" style="margin-right: 6px; font-size: 16px;"></i>
            Email Us
          </a>
        </div>
        <div class="wallet-message" id="wallet-message">Coming soon!</div>
      </div>
    </main>
    
    <div class="build-hover-area"><span class="build-number">v1.0.56</span></div>
    </div>

    <script>
      // Language picker and wallet buttons
      (function() {
        const appleImg = document.getElementById('apple-wallet-img');
        const googleImg = document.getElementById('google-wallet-img');
        const langPicker = document.getElementById('lang-picker');
        const langBtn = document.getElementById('lang-btn');
        const langDropdown = document.getElementById('lang-dropdown');
        const langOptions = document.querySelectorAll('.lang-option');
        const currentLangSpan = document.getElementById('current-lang');

        // Map language codes to button locale codes
        const appleLocaleMap = {
          'en': 'EN', 'es': 'ES', 'fr': 'FR', 'de': 'DE', 'ja': 'JP',
          'zh': 'CN', 'ko': 'KR', 'pt': 'PT'
        };

        const googleLocaleMap = {
          'en': 'EN', 'es': 'esES', 'fr': 'FR', 'de': 'DE', 'ja': 'JP',
          'zh': 'zhHK', 'ko': 'KO', 'pt': 'PT'
        };

        const langDisplayMap = {
          'en': 'EN', 'es': 'ES', 'fr': 'FR', 'de': 'DE',
          'ja': 'JA', 'zh': 'ZH', 'ko': 'KO', 'pt': 'PT'
        };

        // Get initial language from browser or localStorage
        let currentLang = localStorage.getItem('walletmemo-lang');
        if (!currentLang) {
          const browserLang = (navigator.language || navigator.userLanguage).split('-')[0];
          currentLang = appleLocaleMap[browserLang] ? browserLang : 'en';
        }

        function updateWalletButtons(lang) {
          const appleLocale = appleLocaleMap[lang] || 'EN';
          const googleLocale = googleLocaleMap[lang] || 'EN';

          appleImg.src = `./assets/wallet-buttons/apple-wallet-buttons/Locale=${appleLocale}.svg`;
          googleImg.src = `./assets/wallet-buttons/google-wallet-buttons/Locale=${googleLocale}, Type=Primary.svg`;

          // Update display
          currentLangSpan.textContent = langDisplayMap[lang] || 'EN';

          // Update active state
          langOptions.forEach(opt => {
            opt.classList.toggle('active', opt.dataset.lang === lang);
          });
        }

        // Fallback to English if locale file doesn't exist
        appleImg.onerror = () => {
          appleImg.src = './assets/wallet-buttons/apple-wallet-buttons/Locale=EN.svg';
        };
        googleImg.onerror = () => {
          googleImg.src = './assets/wallet-buttons/google-wallet-buttons/Locale=EN, Type=Primary.svg';
        };

        // Initialize
        updateWalletButtons(currentLang);

        // Toggle dropdown
        langBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          langPicker.classList.toggle('open');
        });

        // Close on outside click
        document.addEventListener('click', () => {
          langPicker.classList.remove('open');
        });

        // Language selection
        langOptions.forEach(opt => {
          opt.addEventListener('click', (e) => {
            e.stopPropagation();
            const lang = opt.dataset.lang;
            currentLang = lang;
            localStorage.setItem('walletmemo-lang', lang);
            updateWalletButtons(lang);
            langPicker.classList.remove('open');
          });
        });

        // Google Wallet - coming soon
        const walletMessage = document.getElementById('wallet-message');
        document.getElementById('google-wallet-btn').addEventListener('click', (e) => {
          e.preventDefault();
          walletMessage.classList.add('visible');
        });
      })();

      // ==========================================
      // Sticky Note Menu & Drawing System
      // ==========================================
      (function() {
        // Elements
        const stickyNote = document.getElementById('sticky-note');
        const menuBtn = document.getElementById('menu-btn');
        const dropdown = document.getElementById('note-dropdown');
        const changeColorBtn = document.getElementById('change-color-btn');
        const colorSubmenu = document.getElementById('color-submenu');
        const colorSwatches = document.querySelectorAll('.color-swatch');
        const addStampBtn = document.getElementById('add-stamp-btn');
        const drawBtn = document.getElementById('draw-btn');
        const colorIcon = document.getElementById('color-icon');
        const noteDrawingLayer = document.getElementById('note-drawing-layer');
        const drawingToolbar = document.getElementById('drawing-toolbar');
        const clearBtn = document.getElementById('clear-drawing');
        const cancelBtn = document.getElementById('cancel-drawing');
        const doneBtn = document.getElementById('done-drawing');

        // Color theme definitions
        const colorThemes = {
          blue: {
            gradient: ['#9DD5EE', '#98C4DA', '#9BC8E7', '#ACD7E9', '#B8E3F3', '#C4E9F5'],
            shadow1: [0.101961, 0.55098, 1],      // Blue tint
            shadow2: [0, 0.334596, 0.608357],     // Blue tint
            shadow3: [0.425615, 0.695906, 0.842314] // Blue edge
          },
          yellow: {
            gradient: ['#D8C453', '#D4B94C', '#DEC75E', '#E8D46E', '#F0DF85', '#F7EA9C'],
            shadow1: [0.85, 0.75, 0.25],          // Yellow tint
            shadow2: [0.55, 0.48, 0.15],          // Yellow tint
            shadow3: [0.82, 0.78, 0.42]           // Yellow edge
          },
          pink: {
            gradient: ['#DCABB5', '#D7A0AA', '#E2B4BD', '#ECC4CC', '#F2D1D8', '#F8DEE3'],
            shadow1: [0.9, 0.55, 0.65],           // Pink tint
            shadow2: [0.6, 0.35, 0.45],           // Pink tint
            shadow3: [0.88, 0.72, 0.78]           // Pink edge
          }
        };

        // Weighted random color selection
        function getRandomColor() {
          const rand = Math.random();
          if (rand < 0.6) return 'blue';      // 60% chance
          if (rand < 0.9) return 'yellow';    // 30% chance
          return 'pink';                       // 10% chance
        }

        let currentColor = getRandomColor();

        // Color icon colors (mid-tone for each theme)
        const colorIconColors = {
          blue: '#B4DCE8',
          yellow: '#E2D060',
          pink: '#E4B8C0'
        };

        // Update note colors dynamically
        function updateNoteColors(colorKey) {
          const theme = colorThemes[colorKey];
          if (!theme) return;

          // Update color icon
          if (colorIcon) {
            colorIcon.style.background = colorIconColors[colorKey];
          }

          // Update gradient stops
          theme.gradient.forEach((color, i) => {
            const stop = document.getElementById(`grad-stop-${i}`);
            if (stop) stop.setAttribute('stop-color', color);
          });

          // Update shadow colors
          const shadow1 = document.getElementById('shadowColor1');
          const shadow2 = document.getElementById('shadowColor2');
          const shadow3 = document.getElementById('shadowColor3');

          if (shadow1) {
            const [r, g, b] = theme.shadow1;
            shadow1.setAttribute('values', `0 0 0 0 ${r} 0 0 0 0 ${g} 0 0 0 0 ${b} 0 0 0 0.1 0`);
          }
          if (shadow2) {
            const [r, g, b] = theme.shadow2;
            shadow2.setAttribute('values', `0 0 0 0 ${r} 0 0 0 0 ${g} 0 0 0 0 ${b} 0 0 0 0.09 0`);
          }
          if (shadow3) {
            const [r, g, b] = theme.shadow3;
            shadow3.setAttribute('values', `0 0 0 0 ${r} 0 0 0 0 ${g} 0 0 0 0 ${b} 0 0 0 1 0`);
          }
        }

        // Note state toggle (click to switch between curled and flat)
        const noteWrapper = document.getElementById('note-wrapper');
        const notePaper = document.getElementById('note-paper');
        const noteShape = document.getElementById('note-shape');
        const noteShadow = document.getElementById('note-shadow');
        let isFlat = false;

        // SVG path points for the two states (matching structure for smooth morphing)
        // Structure: [M, L, C1, C2, C3, L, C1, C2, C3]
        const statePoints = {
          curled: [
            [34.6016, 19.2695],    // M - start
            [250.102, 18.5996],    // L - top right
            [250.102, 18.5996],    // C1 - control 1
            [249.602, 49.0996],    // C2 - control 2
            [257.602, 228.6],      // C3 - end (bottom right)
            [28.6016, 231.1],      // L - bottom left
            [36.6029, 66.5996],    // C1 - control 1
            [34.6016, 19.2695],    // C2 - control 2
            [34.6016, 19.2695]     // C3 - end (back to start)
          ],
          flat: [
            [29, 18],              // M - start
            [258, 18],             // L - top right
            [258, 18],             // C1 - control 1 (on line)
            [258, 125],            // C2 - control 2 (midpoint)
            [258, 232],            // C3 - end (bottom right)
            [29, 232],             // L - bottom left
            [29, 125],             // C1 - control 1 (midpoint)
            [29, 18],              // C2 - control 2 (on line)
            [29, 18]               // C3 - end (back to start)
          ]
        };

        // Convert points array to SVG path string
        function pointsToPath(points) {
          return `M${points[0][0]} ${points[0][1]} L${points[1][0]} ${points[1][1]} C${points[2][0]} ${points[2][1]} ${points[3][0]} ${points[3][1]} ${points[4][0]} ${points[4][1]} L${points[5][0]} ${points[5][1]} C${points[6][0]} ${points[6][1]} ${points[7][0]} ${points[7][1]} ${points[8][0]} ${points[8][1]} Z`;
        }

        // Interpolate between two point arrays
        function lerpPoints(from, to, t) {
          return from.map((point, i) => [
            point[0] + (to[i][0] - point[0]) * t,
            point[1] + (to[i][1] - point[1]) * t
          ]);
        }

        // Easing function (ease-out cubic)
        function easeOutCubic(t) {
          return 1 - Math.pow(1 - t, 3);
        }

        // Animate path morphing
        let animationId = null;
        function animatePath(from, to, duration = 400) {
          if (animationId) cancelAnimationFrame(animationId);

          const startTime = performance.now();

          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutCubic(progress);

            const currentPoints = lerpPoints(from, to, easedProgress);
            noteShape.setAttribute('d', pointsToPath(currentPoints));

            if (progress < 1) {
              animationId = requestAnimationFrame(animate);
            }
          }

          animationId = requestAnimationFrame(animate);
        }

        // Flat gradient colors (more uniform, less dynamic)
        const flatGradients = {
          blue: ['#A8D4E8', '#A8D4E8', '#A8D4E8', '#B0D8EB', '#B8DCED', '#C0E0F0'],
          yellow: ['#E2D060', '#E2D060', '#E2D060', '#E6D468', '#EAD870', '#EEDC78'],
          pink: ['#E4B8C0', '#E4B8C0', '#E4B8C0', '#E8C0C8', '#ECC8D0', '#F0D0D8']
        };

        // Parse hex color to RGB array
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
          ] : [0, 0, 0];
        }

        // Convert RGB array to hex
        function rgbToHex(r, g, b) {
          return '#' + [r, g, b].map(x => {
            const hex = Math.round(x).toString(16);
            return hex.length === 1 ? '0' + hex : hex;
          }).join('');
        }

        // Animate gradient transition
        let gradientAnimationId = null;
        function animateGradient(toFlat, duration = 400) {
          if (gradientAnimationId) cancelAnimationFrame(gradientAnimationId);

          const theme = colorThemes[currentColor];
          const fromColors = toFlat ? theme.gradient : flatGradients[currentColor];
          const toColors = toFlat ? flatGradients[currentColor] : theme.gradient;

          const fromRgb = fromColors.map(hexToRgb);
          const toRgb = toColors.map(hexToRgb);

          const startTime = performance.now();

          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutCubic(progress);

            fromRgb.forEach((from, i) => {
              const r = from[0] + (toRgb[i][0] - from[0]) * easedProgress;
              const g = from[1] + (toRgb[i][1] - from[1]) * easedProgress;
              const b = from[2] + (toRgb[i][2] - from[2]) * easedProgress;
              const stop = document.getElementById(`grad-stop-${i}`);
              if (stop) stop.setAttribute('stop-color', rgbToHex(r, g, b));
            });

            if (progress < 1) {
              gradientAnimationId = requestAnimationFrame(animate);
            }
          }

          gradientAnimationId = requestAnimationFrame(animate);
        }

        // Get textarea element
        const textarea = document.getElementById('memo');

        // Tap anywhere on the note to focus textarea (fixes mobile double-tap)
        noteWrapper.addEventListener('click', (e) => {
          // Don't steal clicks from menu, dropdown, or drawing layer
          if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown') || e.target.closest('.drawing-toolbar')) return;
          textarea.focus();
        });

        // Calculate mobile scale so note fills screen width with padding
        function updateMobileScale() {
          const noteWidth = noteWrapper.offsetWidth || 344;
          const scale = (window.innerWidth / noteWidth) * 1.1;
          document.documentElement.style.setProperty('--mobile-note-scale', scale.toFixed(3));
        }
        updateMobileScale();
        window.addEventListener('resize', updateMobileScale);

        // Mobile: touchend for immediate focus without double-tap
        noteWrapper.addEventListener('touchend', (e) => {
          if (e.target.closest('.note-menu-btn') || e.target.closest('.note-dropdown') || e.target.closest('.drawing-toolbar')) return;
          if (noteWrapper.classList.contains('drawing-mode')) return;
          e.preventDefault();
          textarea.focus();
        });

        // Focus/blur on textarea triggers the flat/curled animation
        const focusOverlay = document.getElementById('focus-overlay');
        textarea.addEventListener('focus', () => {
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            noteShadow.src = './assets/paper-stuff/shadow-layer-two.svg';
            noteWrapper.classList.add('flat');
            focusOverlay.classList.add('active');
          }
        });

        textarea.addEventListener('blur', () => {
          if (isFlat) {
            isFlat = false;
            animatePath(statePoints.flat, statePoints.curled);
            animateGradient(false);
            noteShadow.src = './assets/paper-stuff/shadow-layer.svg';
            noteWrapper.classList.remove('flat');
            focusOverlay.classList.remove('active');
          }
        });

        // Menu toggle
        menuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          menuBtn.classList.toggle('active');
          dropdown.classList.toggle('open');
        });

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
          if (!dropdown.contains(e.target) && !menuBtn.contains(e.target)) {
            dropdown.classList.remove('open');
            menuBtn.classList.remove('active');
            colorSubmenu.classList.remove('open');
          }
        });

        // Color change functionality
        changeColorBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          colorSubmenu.classList.toggle('open');
        });

        colorSwatches.forEach(swatch => {
          swatch.addEventListener('click', (e) => {
            e.stopPropagation();
            const colorKey = swatch.dataset.color;
            currentColor = colorKey;
            updateNoteColors(colorKey);

            // Clear drawing when color changes (drawing is tied to note color)
            if (drawingCtx) {
              drawingCtx.clearRect(0, 0, noteDrawingLayer.width, noteDrawingLayer.height);
            }

            // Update active state
            colorSwatches.forEach(s => s.classList.remove('active'));
            swatch.classList.add('active');

            // Close menu
            dropdown.classList.remove('open');
            menuBtn.classList.remove('active');
            colorSubmenu.classList.remove('open');
          });
        });

        // Add stamp (placeholder)
        addStampBtn.addEventListener('click', () => {
          alert('Stamp feature coming soon!');
          dropdown.classList.remove('open');
          menuBtn.classList.remove('active');
        });

        // ==========================================
        // Drawing Mode (draws directly on note)
        // ==========================================
        let isDrawingMode = false;
        let drawingCtx = null;
        let isDrawing = false;
        let savedImageData = null;

        // Initialize note drawing layer
        function initNoteDrawingLayer() {
          noteDrawingLayer.width = stickyNote.offsetWidth * 2;
          noteDrawingLayer.height = stickyNote.offsetHeight * 2;
          drawingCtx = noteDrawingLayer.getContext('2d');
          drawingCtx.scale(2, 2);
          drawingCtx.lineCap = 'round';
          drawingCtx.lineJoin = 'round';
          drawingCtx.strokeStyle = 'rgba(26, 26, 26, 0.9)';
          drawingCtx.lineWidth = 4;
        }
        
        // Pen settings
        let currentPenColor = 'rgba(26, 26, 26, 0.9)';
        let currentPenSize = 4;

        initNoteDrawingLayer();

        // Open drawing mode
        drawBtn.addEventListener('click', () => {
          dropdown.classList.remove('open');
          menuBtn.classList.remove('active');

          isDrawingMode = true;

          // Save current drawing state for cancel
          savedImageData = drawingCtx.getImageData(0, 0, noteDrawingLayer.width, noteDrawingLayer.height);

          // Put note in flat state
          if (!isFlat) {
            isFlat = true;
            animatePath(statePoints.curled, statePoints.flat);
            animateGradient(true);
            noteShadow.src = './assets/paper-stuff/shadow-layer-two.svg';
            noteWrapper.classList.add('flat');
          }

          // Enable drawing mode
          document.body.classList.add('drawing-mode-active');
          noteWrapper.classList.add('drawing-mode');
        });

        // Drawing on canvas
        noteDrawingLayer.addEventListener('pointerdown', (e) => {
          if (!isDrawingMode) return;
          isDrawing = true;
          const rect = noteDrawingLayer.getBoundingClientRect();
          const scaleX = noteDrawingLayer.width / rect.width / 2;
          const scaleY = noteDrawingLayer.height / rect.height / 2;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          drawingCtx.beginPath();
          drawingCtx.moveTo(x, y);
        });

        noteDrawingLayer.addEventListener('pointermove', (e) => {
          if (!isDrawingMode || !isDrawing) return;

          const rect = noteDrawingLayer.getBoundingClientRect();
          const scaleX = noteDrawingLayer.width / rect.width / 2;
          const scaleY = noteDrawingLayer.height / rect.height / 2;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          drawingCtx.lineTo(x, y);
          drawingCtx.stroke();
          drawingCtx.beginPath();
          drawingCtx.moveTo(x, y);
        });

        noteDrawingLayer.addEventListener('pointerup', () => {
          isDrawing = false;
        });

        noteDrawingLayer.addEventListener('pointerleave', () => {
          isDrawing = false;
        });

        // Clear drawing
        clearBtn.addEventListener('click', () => {
          drawingCtx.clearRect(0, 0, noteDrawingLayer.width, noteDrawingLayer.height);
        });

        // Cancel drawing - restore previous state
        cancelBtn.addEventListener('click', () => {
          if (savedImageData) {
            drawingCtx.putImageData(savedImageData, 0, 0);
          }
          closeDrawingMode();
        });

        // Done drawing
        doneBtn.addEventListener('click', () => {
          closeDrawingMode();
        });

        function closeDrawingMode() {
          isDrawingMode = false;
          isDrawing = false;
          savedImageData = null;
          document.body.classList.remove('drawing-mode-active');
          noteWrapper.classList.remove('drawing-mode');
        }

        // Pen color picker
        document.querySelectorAll('.pen-color').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.pen-color').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const rgb = btn.dataset.color;
            currentPenColor = `rgba(${rgb}, 0.9)`;
            if (drawingCtx) drawingCtx.strokeStyle = currentPenColor;
          });
        });

        // Pen size picker
        document.querySelectorAll('.pen-size').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.pen-size').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentPenSize = parseInt(btn.dataset.size);
            if (drawingCtx) drawingCtx.lineWidth = currentPenSize;
          });
        });

        // Handle window resize
        window.addEventListener('resize', () => {
          initNoteDrawingLayer();
        });

        // Apply random color on load and update active swatch
        updateNoteColors(currentColor);
        colorSwatches.forEach(s => {
          s.classList.toggle('active', s.dataset.color === currentColor);
        });

        // ==========================================
        // Apple Wallet Pass Generation
        // ==========================================
        const appleWalletBtn = document.getElementById('apple-wallet-btn');
        const walletMsg = document.getElementById('wallet-message');
        
        appleWalletBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          
          // Get note content
          const text = document.getElementById('memo').value;
          
          // Get drawing data - always send canvas (backend handles empty gracefully)
          const drawingDataUrl = noteDrawingLayer.toDataURL('image/png');
          
          // Show loading state
          const originalContent = appleWalletBtn.innerHTML;
          appleWalletBtn.style.opacity = '0.6';
          appleWalletBtn.style.pointerEvents = 'none';
          
          try {
            const BACKEND_URL = 'https://sandbox-staging.up.railway.app';
            
            // Simple approach: fetch blob and trigger download
            const response = await fetch(`${BACKEND_URL}/api/generate-pass`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                text: text,
                color: currentColor,
                drawingDataUrl: drawingDataUrl
              })
            });
            
            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.error || 'Failed to generate pass');
            }
            
            // Get the blob and create download link
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            
            // Try opening the blob URL directly - Safari may handle .pkpass
            window.location.href = url;
            
          } catch (error) {
            console.error('Error:', error);
            walletMsg.textContent = error.message.includes('fetch') 
              ? 'Backend not running. Start the server first!'
              : error.message;
            walletMsg.classList.add('visible');
            setTimeout(() => walletMsg.classList.remove('visible'), 3000);
          } finally {
            appleWalletBtn.style.opacity = '1';
            appleWalletBtn.style.pointerEvents = 'auto';
          }
        });
      })();
    </script>
  </body>
</html>
